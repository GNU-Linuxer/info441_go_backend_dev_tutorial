<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Go Slices and Maps"><meta property="og:description" content="How to leverage Go&#x27;s built-in complex types"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Go Slices and Maps</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px;margin-bottom:1em}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Go Slices and Maps</h1><p class="subtitle">How to leverage Go&#x27;s built-in complex types</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Oct 2, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>In addition to the <a href="../golang/#secsimpletypes">simple types</a>, Go offers two other complex types that are exceedingly useful: slices and maps. In this tutorial I will explain what these types are, how to use them, and clarify the relationship between slices and their underlying storage, which are known as arrays.</p><h2 id="secarrays">Arrays</h2><p>To understand slices, you first need to understand arrays. In Go an array is simply a fixed-size contiguous memory buffer divided into equally-sized segments according the array's data type. For example, creating an array of three <code>uint8</code> values will allocate a 24-bit memory buffer where each element is 8 bits long. The syntax for creating a fixed-size array looks like this:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//initialize a fixed array of 3 uint8 numbers</span>
<span class="token comment" spellcheck="true">//and initialize them all to 255</span>
rgb <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">uint8</span><span class="token punctuation">{</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">}</span></code></pre><p>If you don't supply values in the initializer, the elements are set to the zero-value for the array's data type:</p><table class="table is-striped"><thead><tr><th>data type</th><th>zero value</th></tr></thead><tbody><tr><td>any number type</td><td><code>0</code></td></tr><tr><td>string</td><td><code>""</code> (zero-length string)</td></tr><tr><td>bool</td><td><code>false</code></td></tr><tr><td>any pointer type</td><td><code>nil</code></td></tr></tbody></table><p>So the expression <code>[3]uint8{}</code> creates an array with three <code>uint8</code> values, all set to <code>0</code>.</p><p>After you create an array, you can access the elements by their zero-based index:</p><pre class="language-go"><code class="language-go">r <span class="token operator">:=</span> rgb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
g <span class="token operator">:=</span> rgb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
b <span class="token operator">:=</span> rgb<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span></code></pre><p>You can also get the length of the array using the built-in <code>len()</code> function:</p><pre class="language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"array length is %d\n"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>rgb<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Arrays are fixed in size: once you create them, you can't expand them or contract them without allocating a new array and copying the elements to the new array. So arrays are useful only when you need a fixed-size memory buffer or when you know you only need a fixed number of elements. For example, if you are reading 1024 bytes at a time from a file, you can allocate one <code>[1024]byte{}</code> array and read chunks into it as you scan the file. Or if you need to store an ordered list of the calendar months, you can safely assume that there are only 12 of them, and thus a fixed-size array would be appropriate:</p><pre class="language-go"><code class="language-go">months <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"January"</span><span class="token punctuation">,</span> <span class="token string">"February"</span><span class="token punctuation">,</span> <span class="token string">"March"</span><span class="token punctuation">,</span> <span class="token string">"April"</span><span class="token punctuation">,</span> 
    <span class="token string">"May"</span><span class="token punctuation">,</span> <span class="token string">"June"</span><span class="token punctuation">,</span> <span class="token string">"July"</span><span class="token punctuation">,</span> <span class="token string">"August"</span><span class="token punctuation">,</span> 
    <span class="token string">"September"</span><span class="token punctuation">,</span> <span class="token string">"October"</span><span class="token punctuation">,</span> <span class="token string">"November"</span><span class="token punctuation">,</span> <span class="token string">"December"</span><span class="token punctuation">}</span></code></pre><p>If you need a more flexible ordered list that can expand as you add elements to it, that's what slices are for.</p><h2 id="secslicingarrays">Slicing Arrays</h2><p>A slice in Go is like a flexible window over an underlying fixed-size array. A slice is actually a small struct that contains three fields:</p><ul><li>a pointer to the first element in the underlying array that the slice can see</li><li>the number of elements after the starting element that the slice can see (length)</li><li>the total number of elements available in the array after the starting element (capacity)</li></ul><p>For example, we can create a slice from our array of months using this syntax:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Q1 is a slice of the months array</span>
<span class="token comment" spellcheck="true">//viewing just the first three months</span>
Q1 <span class="token operator">:=</span> months<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span></code></pre><p>The slice operator specifies two array element indexes: the first element in the array the slice can see; and the element after the last element the slice can see. In other words, the slice will be able to see the elements from the first index up-to but not including the second index. So the expression <code>months[0:3]</code> creates a slice that can see indexes <code>0</code>, <code>1</code>, and <code>2</code>. The expression <code>months[0:1]</code> creates a slice that can see only element <code>0</code>. The following shows this graphically:</p><p><img src="img/slices-1.png" alt="graphic portrayal of slices"></p><p>The reasoning behind the "up-to but not including" second index value is that it makes it easy to use <code>len(months)</code> as the second index to get all the elements from the starting index through the end of the array. In fact, this is such a common operation that the second index defaults to <code>len(months)</code> so you can just omit it: the expression <code>months[9:]</code> is the same as <code>months[9:len(months)]</code>. Similarly, the first index defaults to <code>0</code>, so the expression <code>months[:3]</code> is the same as <code>months[0:3]</code>. Not surprisingly, <code>months[:]</code> is the same as <code>months[0:len(months)]</code>.</p><p>You can create multiple slices off the same array, and they can also overlap each other:</p><p><img src="img/slices-2.png" alt="graphic portrayal of multiple overlapping slices"></p><p>You can also create slices from slices using the same syntax. The expression <code>Q1[0:1]</code> returns a slice pointing to the same starting element in the underlying array, but the length of the new slice would be <code>1</code> instead of <code>3</code>.</p><h2 id="seccreatingandappendingtoslices">Creating and Appending to Slices</h2><p>Slicing existing arrays is useful, but what if you don't know how many elements you might need? What if you just want an ordered list of elements that automatically grows as you add more elements to it?</p><p>Slices combined with the built-in <code>append()</code> function provide this kind of functionality. If you don't know how many elements you might need, you can start by just creating a slice, which automatically allocates an underlying array that is hidden from you:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//create a slice of strings with an automatically-allocated</span>
<span class="token comment" spellcheck="true">//underlying array that you can't see or reference</span>
names <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>The syntax is similar to how you declare a fixed-length array, but you omit the number of elements between the <code>[]</code> symbols. The slice will point to an underlying array, but the slice's length will be zero, and its capacity will be the size of that automatically-allocated underlying array.</p><p>You can then add new values to this slice using the built-in <code>append()</code> function:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//append takes the slice and the value to add to it;</span>
<span class="token comment" spellcheck="true">//it then returns the original slice or a new slice</span>
<span class="token comment" spellcheck="true">//if it has to grow the underlying array</span>
names <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token string">"Alice"</span><span class="token punctuation">)</span>
names <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token string">"Bob"</span><span class="token punctuation">)</span>
names <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token string">"Chang"</span><span class="token punctuation">)</span></code></pre><p>Note that we re-assign the <code>names</code> variable to the return value of <code>append()</code>. The underlying array naturally has a fixed length, and it may be full, so the <code>append()</code> function might need to allocate a new larger array to hold the new value. If so, the <code>append()</code> function will allocate a new larger array, copy the elements from the original array to the new array, and return a new slice pointing to the new underlying array. The old array and slice then fall out of scope and are eventually garbage collected. If the underlying array has a enough capacity to hold the new value, <code>append()</code> will simply put the value into the next available element and return the original slice.</p><p>Note that the <code>append()</code> function is smart enough to handle the first parameter being <code>nil</code>. For example, say you had a struct field that was typed as <code>[]string</code> (a slice of strings), and you create an instance of that struct without providing any field initializers. That field will have the value of <code>nil</code>, but it's OK to pass that as the first argument to <code>append()</code>. When you do, <code>append()</code> will simply create a new underlying array, put the value in the first position, and return a slice over that new underlying array.</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> SharedLink <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    PageURL <span class="token builtin">string</span>
    Keywords <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//create an instance of SharedLink,</span>
    <span class="token comment" spellcheck="true">//setting only the PageURL field.</span>
    <span class="token comment" spellcheck="true">//the PageURL field remains nil</span>
    sl <span class="token operator">:=</span> <span class="token operator">&amp;</span>SharedLink<span class="token punctuation">{</span>
        PageURL<span class="token punctuation">:</span> <span class="token string">"https://ischool.uw.edu"</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//append a keyword to the slice of string</span>
    <span class="token comment" spellcheck="true">//append() will see that sl.Keywords is nil, </span>
    <span class="token comment" spellcheck="true">//and just allocate a new array, returning a </span>
    <span class="token comment" spellcheck="true">//slice over that newly allocated array</span>
    sl<span class="token punctuation">.</span>Keywords <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>sl<span class="token punctuation">.</span>Keywords<span class="token punctuation">,</span> <span class="token string">"iSchool"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><h2 id="seciteratingslices">Iterating Slices</h2><p>Since you can access an element using an index, you can iterate over a slice using a traditional <code>for</code> loop, but go also offers a more convenient <code>for...range</code> loop that works with slices and arrays:</p><pre class="language-go"><code class="language-go"><span class="token keyword">for</span> i<span class="token punctuation">,</span> name <span class="token operator">:=</span> <span class="token keyword">range</span> names <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d = %s"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>The <code>range</code> operator iterates over the slice or array, setting the <code>i</code> variable to the element index and the <code>name</code> variable to the element value. If you only care about the element value and don't need the element index, you can use the <code>_</code> symbol (known as the "blank identifier") for the first variable:</p><pre class="language-go"><code class="language-go"><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> name <span class="token operator">:=</span> <span class="token keyword">range</span> names <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>If you just need to iterate forwards over an entire slice or array, use the <code>for...range</code> loop: it's less error-prone and shorter to type. But if you need to iterate backwards, or skip elements, use a traditional <code>for</code> loop.</p><h2 id="secmaps">Maps</h2><p>In addition to arrays and slices, which are ordered lists, Go also has a built-in map type, which is an associative set of key/value pairs. Maps are currently implemented using hash tables, which are very efficient data structures for storing and retrieving key/value pairs. Go maps are just like JavaScript Objects (which are just hash tables under the hood), except that Go maps are statically-typed: you declare the data types for keys and values when you declare the map, and the Go compiler ensures that only keys and values of those types can be added to the map.</p><p>For example, to create a map where the keys are strings and the values are numbers, you use a syntax like this:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//creates a map of string keys to int values</span>
<span class="token comment" spellcheck="true">//you can supply values in the {} initializer</span>
<span class="token comment" spellcheck="true">//if you want to pre-populate the map with</span>
<span class="token comment" spellcheck="true">//a few key/value pairs</span>
occurrences <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>The syntax for adding a key/value pair to the map, and getting a value for a key, looks like this:</p><pre class="language-go"><code class="language-go">word <span class="token operator">:=</span> <span class="token string">"the"</span>
<span class="token comment" spellcheck="true">//add an entry with key "the" and value 1</span>
occurrences<span class="token punctuation">[</span>word<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment" spellcheck="true">//get the value associated with the key </span>
count <span class="token operator">:=</span> occurrences<span class="token punctuation">[</span>word<span class="token punctuation">]</span></code></pre><p>If you request the value for a key that does not yet exist, the map will return the zero-value for the value's data type. Often times this works out well since your code doesn't have to worry about checking whether the key exists before using the value. For example, since the zero-value of an <code>int</code> is <code>0</code>, we can count the occurrences of words in text with code like this:</p><pre class="language-go"><code class="language-go">text <span class="token operator">:=</span> <span class="token string">"... some long text ..."</span>
words <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span>
occurrences <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> w <span class="token operator">:=</span> <span class="token keyword">range</span> words <span class="token punctuation">{</span>
    occurrences<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">++</span>
<span class="token punctuation">}</span></code></pre><p>This code splits the input text into a slice of words and the iterates over that slice using the <code>for...range</code> loop described <a href="#seciteratingslices">earlier</a>. As it iterates, it increments the integer value associated with the word in the map. If the word is not yet added to the map, the expression <code>occurrences[w]</code> will return <code>0</code>. The <code>++</code> operator then increments that value and sets it as the value for the current word.</p><p>If you really need to know whether a key is in the map, you can add another variable when accessing the map:</p><pre class="language-go"><code class="language-go">count<span class="token punctuation">,</span> exists <span class="token operator">:=</span> occurrences<span class="token punctuation">[</span><span class="token string">"the"</span><span class="token punctuation">]</span></code></pre><p>The <code>count</code> variable will be set to the current value, or the zero-value if the key doesn't exist. The <code>exists</code> variable will be set to <code>true</code> if the key exists in the map, or <code>false</code> if not.</p><h2 id="seciteratingmaps">Iterating Maps</h2><p>Like slices and arrays, maps can be iterated using the <code>for...range</code> loop:</p><pre class="language-go"><code class="language-go"><span class="token keyword">for</span> word<span class="token punctuation">,</span> count <span class="token operator">:=</span> <span class="token keyword">range</span> occurrences <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s appears %d times"</span><span class="token punctuation">,</span> word<span class="token punctuation">,</span> count<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>But since maps are hash tables, the key/value pairs are in no particular order. In fact, Go will <a href="https://blog.golang.org/go-maps-in-action">randomize the iteration order</a> just to make sure you don't depend on some particular ordering that may change in the future (this is another example where it's obvious this language was designed by seasoned developers who have been bitten by bugs resulting from spurious assumptions about past behavior that was not actually guaranteed). Each time you run the <code>for...range</code> loop above, it will list the words in a different order.</p><p>If you want to iterate the map in some particular order (e.g. by the keys sorted alphabetically), you must first extract the keys into a slice, sort the slice, and then iterate that sorted slice:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//make a string slice with enough capacity to hold all the keys</span>
keys <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>occurrences<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//range over the keys and append them to the slice</span>
<span class="token keyword">for</span> k <span class="token operator">:=</span> <span class="token keyword">range</span> occurrences <span class="token punctuation">{</span>
    keys <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>keys<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//sort the slice of keys alphabetically</span>
sort<span class="token punctuation">.</span><span class="token function">Strings</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//iterate over the keys, looking up</span>
<span class="token comment" spellcheck="true">//the associated value in the map</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> k <span class="token operator">:=</span> <span class="token keyword">range</span> keys <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s appears %d times\n"</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> occurrences<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/gajzuHwiw5"><span class="button is-primary">Run in the Go Playground</span></a></p><p>The <a href="https://golang.org/pkg/builtin/#make">make() function</a> is used to create a slice with an underlying array that has a particular capacity. Since we can use the <code>len()</code> function to determine how many keys are in the map, we can save unnecessary memory allocations by presetting the slice capacity to the number of keys in the map. That way the <code>append()</code> function never has to reallocate the underlying array, as it will always have enough room to fit all the keys.</p><p>We then range over the map, but this time we only access the keys in order to append them to the slice. After appending all the keys, we sort the slice alphabetically using the <a href="https://golang.org/pkg/sort/#Strings">sort.Strings()</a> function. Finally, we iterate the sorted slice of keys, using the current key to get the associated value from the original <code>occurrences</code> map.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>