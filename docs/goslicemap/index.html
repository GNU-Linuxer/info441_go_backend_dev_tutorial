<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.4.3/css/bulma.min.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Go Slices and Maps"><meta property="og:description" content="How to leverage Go&#x27;s built-in complex types"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Go Slices and Maps</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Go Slices and Maps</h1><p class="subtitle">How to leverage Go&#x27;s built-in complex types</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jul 11, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>In addition to the <a href="../golang/#secsimpletypes">simple types</a>, Go offers two other complex types that are exceedingly useful: slices and maps. In this tutorial I will explain what these types are, how to use them, and clarify the relationship between slices and their underlying storage, which are known as arrays.</p><h2 id="secarrays">Arrays</h2><p>To understand slices, you first need to understand arrays. In Go an array is simply a fixed-size contiguous memory buffer divided into equally-sized segments according the array's data type. For example, creating an array of three <code>uint8</code> values will allocate a 24-bit memory buffer where each element is 8 bits long. The syntax for creating a fixed-size array looks like this:</p><pre><code class="go language-go">//initialize a fixed array of 3 uint8 numbers
//and initialize them all to 255
rgb := [3]uint8{255, 255, 255}</code></pre><p>If you don't supply values in the initializer, the elements are set to the zero-value for the array's data type:</p><table class="table is-striped"><thead><tr><th>data type</th><th>zero value</th></tr></thead><tbody><tr><td>any number type</td><td><code>0</code></td></tr><tr><td>string</td><td><code>""</code> (zero-length string)</td></tr><tr><td>bool</td><td><code>false</code></td></tr><tr><td>any pointer type</td><td><code>nil</code></td></tr></tbody></table><p>After you create an array, you can access the elements by their zero-based index:</p><pre><code class="go language-go">r := rgb[0]
g := rgb[1]
b := rgb[2]</code></pre><p>You can also get the length of the array using the built-in <code>len()</code> function:</p><pre><code class="go language-go">fmt.Printf("array length is %d\n", len(rgb))</code></pre><p>Arrays are fixed in size: once you create them, you can't expand them or contract them without allocating a new array and copying the elements to the new array. So arrays are useful only when you need a fixed-size memory buffer or when you know you only need a fixed number of elements. For example, if you are reading 1024 bytes at a time from a file, you can allocate one <code>[1024]byte{}</code> array and read chunks into it as you scan the file. Or if you need to store an ordered list of the calendar months, you can safely assume that there are only 12 of them, and thus a fixed-size array would be appropriate:</p><pre><code class="go language-go">months := [12]string{"January", "February", "March", "April", 
    "May", "June", "July", "August", 
    "September", "October", "November", "December"}</code></pre><p>If you need a more flexible ordered list that can expand as you add elements to it, that's what slices are for.</p><h2 id="secslicingarrays">Slicing Arrays</h2><p>A slice in Go is like a flexible window into an underlying fixed-size array. A slice is actually a small struct that contains three fields:</p><ul><li>a pointer to the first element in the underlying array that the slice can see</li><li>the number of elements after the starting element that the slice can see (length)</li><li>the total number of elements available in the array after the starting element (capacity)</li></ul><p>For example, we can create a slice from our array of months using this syntax:</p><pre><code class="go language-go">//Q1 is a slice of the months array
//viewing just the first three months
Q1 := months[0:3]</code></pre><p>The slice operator specifies two array element indexes: the first element in the array the slice can see; and the element after the last element the slice can see. In other words, the slice will be able to see the elements from the first index up-to but not including the second index. So the expression <code>months[0:3]</code> creates a slice that can see indexes <code>0</code>, <code>1</code>, and <code>2</code>. The expression <code>months[0:1]</code> creates a slice that can see only element <code>0</code>. The following shows this graphically:</p><p><img src="img/slices-1.png" alt="graphic portrayal of slices"></p><p>You can create multiple slices off the same array, and they can also overlap each other:</p><p><img src="img/slices-2.png" alt="graphic portrayal of multiple overlapping slices"></p><p>You can also create slices from slices using the same syntax. The expression <code>Q1[0:1]</code> returns a slice pointing to the same starting element in the underlying array, but the length of the new slice would be <code>1</code> instead of <code>3</code>.</p><p>If you omit the first and/or last index in the slice operator, the first index defaults to <code>0</code> and the last index defaults to the length of the array or slice from which you are slicing. For example the expression <code>months[9:]</code> is equivalent to <code>months[9:len(months)]</code>.</p><h2 id="seccreatingandappendingtoslices">Creating and Appending to Slices</h2><p>Slicing existing arrays is useful, but what if you don't know how many elements you might need? What if you just want an ordered list of elements that automatically grows as you add more elements to it?</p><p>Slices combined with the built-in <code>append()</code> function provide this kind of functionality. If you don't know how many elements you might need, you can start by just creating a slice, which automatically allocates an underlying array that is hidden from you:</p><pre><code class="go language-go">//create a slice of strings with an automatically-allocated
//underlying array that you can't see or reference
names := []string{}</code></pre><p>The syntax is similar to how you declare a fixed-length array, but you omit the number of elements between the <code>[]</code> symbols. The slice will point to an underlying array, but the slice's length will be zero, and its capacity will be the size of that automatically-allocated underlying array.</p><p>You can then add new elements to this slice using the built-in <code>append()</code> function:</p><pre><code class="go language-go">//append takes the slice and the element to add to it;
//it then returns the original slice or a new slice
//if it has to grow the underlying array
names = append(names, "Alice")
names = append(names, "Bob")
names = append(names, "Chang")</code></pre><p>Note that we re-assign the <code>names</code> variable to the return value of <code>append()</code>. The underlying array naturally has a fixed length, and it may be full, so the <code>append()</code> function might need to allocate a new larger array to hold the new element. If so, the <code>append()</code> function will allocate a new larger array, copy the elements from the original array to the new array, and return a new slice pointing to the new underlying array. The old array and slice then fall out of scope and are eventually garbage collected. If the underlying array has a enough capacity to hold the new element, <code>append()</code> will simply put the value into the next available element and return the original slice.</p><h2 id="secmaps">Maps</h2></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href="..">table of contents</a></p></div></div></footer><script src="../lib/prism.js"></script><script>Prism.plugins.customClass.map({number:"prism-number"});var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var n=document.createElement("a");n.textContent="#",n.href="#"+e.id,n.classList.add("bookmark-link"),e.appendChild(n)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>