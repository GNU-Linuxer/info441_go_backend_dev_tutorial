<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.4.3/css/bulma.min.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Go Slices and Maps"><meta property="og:description" content="How to leverage Go&#x27;s built-in complex types"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Go Slices and Maps</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Go Slices and Maps</h1><p class="subtitle">How to leverage Go&#x27;s built-in complex types</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jul 11, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>In addition to the <a href="../golang/#secsimpletypes">simple types</a>, Go offers two other complex types that are exceedingly useful: slices and maps. In this tutorial I will explain what these types are, how to use them, and clarify the relationship between slices and their underlying storage, which are known as arrays.</p><h2 id="secarrays">Arrays</h2><p>To understand slices, you first need to understand arrays. In Go an array is simply a fixed-size contiguous memory buffer divided into equally-sized segments according the array's data type. For example, creating an array of three <code>uint8</code> values will allocate a 24-bit memory buffer where each element is 8 bits long. The syntax for creating a fixed-size array looks like this:</p><pre><code class="go language-go">//initialize a fixed array of 3 uint8 numbers
//and initialize them all to 255
rgb := [3]uint8{255, 255, 255}</code></pre><p>If you don't supply values in the initializer, the elements are set to the zero-value for the array's data type:</p><table class="table is-striped"><thead><tr><th>data type</th><th>zero value</th></tr></thead><tbody><tr><td>any number type</td><td><code>0</code></td></tr><tr><td>string</td><td><code>""</code> (zero-length string)</td></tr><tr><td>bool</td><td><code>false</code></td></tr><tr><td>any pointer type</td><td><code>nil</code></td></tr></tbody></table><p>So the expression <code>[3]uint8{}</code> creates an array with three <code>uint8</code> values, all set to <code>0</code>.</p><p>After you create an array, you can access the elements by their zero-based index:</p><pre><code class="go language-go">r := rgb[0]
g := rgb[1]
b := rgb[2]</code></pre><p>You can also get the length of the array using the built-in <code>len()</code> function:</p><pre><code class="go language-go">fmt.Printf("array length is %d\n", len(rgb))</code></pre><p>Arrays are fixed in size: once you create them, you can't expand them or contract them without allocating a new array and copying the elements to the new array. So arrays are useful only when you need a fixed-size memory buffer or when you know you only need a fixed number of elements. For example, if you are reading 1024 bytes at a time from a file, you can allocate one <code>[1024]byte{}</code> array and read chunks into it as you scan the file. Or if you need to store an ordered list of the calendar months, you can safely assume that there are only 12 of them, and thus a fixed-size array would be appropriate:</p><pre><code class="go language-go">months := [12]string{"January", "February", "March", "April", 
    "May", "June", "July", "August", 
    "September", "October", "November", "December"}</code></pre><p>If you need a more flexible ordered list that can expand as you add elements to it, that's what slices are for.</p><h2 id="secslicingarrays">Slicing Arrays</h2><p>A slice in Go is like a flexible window into an underlying fixed-size array. A slice is actually a small struct that contains three fields:</p><ul><li>a pointer to the first element in the underlying array that the slice can see</li><li>the number of elements after the starting element that the slice can see (length)</li><li>the total number of elements available in the array after the starting element (capacity)</li></ul><p>For example, we can create a slice from our array of months using this syntax:</p><pre><code class="go language-go">//Q1 is a slice of the months array
//viewing just the first three months
Q1 := months[0:3]</code></pre><p>The slice operator specifies two array element indexes: the first element in the array the slice can see; and the element after the last element the slice can see. In other words, the slice will be able to see the elements from the first index up-to but not including the second index. So the expression <code>months[0:3]</code> creates a slice that can see indexes <code>0</code>, <code>1</code>, and <code>2</code>. The expression <code>months[0:1]</code> creates a slice that can see only element <code>0</code>. The following shows this graphically:</p><p><img src="img/slices-1.png" alt="graphic portrayal of slices"></p><p>The reasoning behind the "up-to but not including" second index value is that it makes it easy to use <code>len(months)</code> as the second index to get all the elements from the starting index through the end of the array. In fact, this is such a common operation that the second index defaults to <code>len(months)</code> so you can just omit it: the expression <code>months[9:]</code> is the same as <code>months[9:len(months)]</code>. Similarly, the first index defaults to <code>0</code>, so the expression <code>months[:3]</code> is the same as <code>months[0:3]</code>. Not surprisingly, <code>months[:]</code> is the same as <code>months[0:len(months)]</code>.</p><p>You can create multiple slices off the same array, and they can also overlap each other:</p><p><img src="img/slices-2.png" alt="graphic portrayal of multiple overlapping slices"></p><p>You can also create slices from slices using the same syntax. The expression <code>Q1[0:1]</code> returns a slice pointing to the same starting element in the underlying array, but the length of the new slice would be <code>1</code> instead of <code>3</code>.</p><h2 id="seccreatingandappendingtoslices">Creating and Appending to Slices</h2><p>Slicing existing arrays is useful, but what if you don't know how many elements you might need? What if you just want an ordered list of elements that automatically grows as you add more elements to it?</p><p>Slices combined with the built-in <code>append()</code> function provide this kind of functionality. If you don't know how many elements you might need, you can start by just creating a slice, which automatically allocates an underlying array that is hidden from you:</p><pre><code class="go language-go">//create a slice of strings with an automatically-allocated
//underlying array that you can't see or reference
names := []string{}</code></pre><p>The syntax is similar to how you declare a fixed-length array, but you omit the number of elements between the <code>[]</code> symbols. The slice will point to an underlying array, but the slice's length will be zero, and its capacity will be the size of that automatically-allocated underlying array.</p><p>You can then add new elements to this slice using the built-in <code>append()</code> function:</p><pre><code class="go language-go">//append takes the slice and the element to add to it;
//it then returns the original slice or a new slice
//if it has to grow the underlying array
names = append(names, "Alice")
names = append(names, "Bob")
names = append(names, "Chang")</code></pre><p>Note that we re-assign the <code>names</code> variable to the return value of <code>append()</code>. The underlying array naturally has a fixed length, and it may be full, so the <code>append()</code> function might need to allocate a new larger array to hold the new element. If so, the <code>append()</code> function will allocate a new larger array, copy the elements from the original array to the new array, and return a new slice pointing to the new underlying array. The old array and slice then fall out of scope and are eventually garbage collected. If the underlying array has a enough capacity to hold the new element, <code>append()</code> will simply put the value into the next available element and return the original slice.</p><h2 id="seciteratingslices">Iterating Slices</h2><p>Since you can access an element using an index, you can iterate over a slice using a traditional <code>for</code> loop, but go also offers a more convenient <code>for...range</code> loop that works with slices and arrays:</p><pre><code class="go language-go">for i, name := range names {
    fmt.Printf("%d = %s", i, name)
}</code></pre><p>The <code>range</code> operator iterates over the slice or array, setting the <code>i</code> variable to the element index and the <code>name</code> variable to the element value. If you only care about the element value and don't need the element index, you can use the <code>_</code> symbol (known as the "blank identifier") for the first variable:</p><pre><code class="go language-go">for _, name := range names {
    fmt.Printf("%s", name)
}</code></pre><p>If you just need to iterate forwards an entire slice or array, use the <code>for...range</code> loop: it's less error-prone and shorter to type. But if you need to iterate backwards, or skip elements, use a traditional <code>for</code> loop.</p><h2 id="secmaps">Maps</h2><p>In addition to arrays and slices, which are ordered lists, Go also has a built-in map type, which is an associative set of key/value pairs. Maps are currently implemented using hash tables, which are very efficient data structures for storing and retrieving key/value pairs. Go maps are just like JavaScript Objects (which are just hash tables under the covers), except that Go maps are statically-typed: you declare the data types for keys and values when you declare the map, and the Go compiler ensures that only keys and values of those types can be added to the map.</p><p>For example, to create a map where the keys are strings and the values are numbers, you use a syntax like this:</p><pre><code class="go language-go">//creates a map of string keys to int values
//you can supply values in the {} initializer
//if you want to pre-populate the map with
//a few key/value pairs
occurrences := map[string]int{}</code></pre><p>The syntax for adding a key/value pair to the map, and getting a value for a key, looks like this:</p><pre><code class="go language-go">word := "the"
//add an entry with key "the" and value 1
occurrences[word] = 1
//get the value associated with the key 
count := occurrences[word]</code></pre><p>If you request the value for a key that does not yet exist, the map will return the zero-value for the value's data type. Often times this works out well since your code doesn't have to worry about checking whether the key exists before using the value. For example, since the zero-value of an <code>int</code> is <code>0</code>, we can count the occurrences of words in text with code like this:</p><pre><code class="go language-go">text := "... some long text ..."
words := strings.Split(text, " ")
occurrences := map[string]int{}
for _, w := range words {
    occurrences[w]++
}</code></pre><p>This code splits the input text into a slice of words and the iterates over that slice using the <code>for...range</code> loop described <a href="#seciteratingslices">earlier</a>. As it iterates, it increments the integer value associated with the word in the map. If the word is not yet added to the map, the expression <code>occurrences[w]</code> will return <code>0</code>. The <code>++</code> operator then increments that value and sets it as the value for the current word.</p><p>If you really need to know whether a key is in the map, you can add another variable to the assignment:</p><pre><code class="go language-go">count, exists := occurrences["the"]</code></pre><p>The <code>count</code> variable will be set to the current value, or the zero-value if the key doesn't exist. The <code>exists</code> variable will be set to <code>true</code> if the key exists in the map, or <code>false</code> if not.</p><h2 id="seciteratingmaps">Iterating Maps</h2><p>Like slices and arrays, maps can be iterated using the <code>for...range</code> loop:</p><pre><code class="go language-go">for word, count := range occurrences {
    fmt.Printf("%s appears %d times", word, count)
}</code></pre><p>But since maps are hash tables, the key/value pairs are in no particular order. In fact, Go will randomize the iteration order just to make sure you don't depend on some particular ordering that may change in the future. For example, each time you run the <code>for...range</code> loop above, it will list the words in a different order.</p><p>If you want to iterate the map in some particular order (e.g. by the keys sorted alphabetically), you must first extract the keys into a slice, sort the slice, and then iterate that sorted slice:</p><pre><code class="go language-go">//make a string slice with enough capacity to hold all the keys
keys := make([]string, 0, len(occurrences))

//range over the keys and append them to the slice
for k := range occurrences {
    keys = append(keys, k)
}

//sort the slice of keys alphabetically
sort.Strings(keys)

//iterate over the keys, looking up
//the associated value in the map
for _, k := range keys {
    fmt.Printf("%s appears %d times\n", k, occurrences[k])
}</code></pre><p>The <a href="https://golang.org/pkg/builtin/#make">make() function</a> is used to create a slice with an underlying array that has a particular capacity. Since we can use the <code>len()</code> function to determine how many keys are in the map, we can save unnecessary memory allocations by presetting the slice capacity to the number of keys in the map. That way the <code>append()</code> function never has to reallocate the underlying array, as it will always have enough room to fit all the keys.</p><p>We then range over the map, but this time we only access the keys in order to append them to the slice. After appending all the keys, we sort the slice alphabetically using the <a href="https://golang.org/pkg/sort/#Strings">sort.Strings()</a> function. Finally, we iterate the sorted slice of keys, using the current key to get the associated value from the original <code>occurrences</code> map.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href="..">table of contents</a></p></div></div></footer><script src="../lib/prism.js"></script><script>Prism.plugins.customClass.map({number:"prism-number"});var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var n=document.createElement("a");n.textContent="#",n.href="#"+e.id,n.classList.add("bookmark-link"),e.appendChild(n)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>