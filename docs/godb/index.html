<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Talking to Databases from Go"><meta property="og:description" content="Interacting with persistent relational and document-oriented DBMSs"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Talking to Databases from Go</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px;margin-bottom:1em}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Talking to Databases from Go</h1><p class="subtitle">Interacting with persistent relational and document-oriented DBMSs</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Mar 9, 2018 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>Web-based information systems need to store and manage large amounts of data, so they typically enlist the help of a persistent database management system (DBMS). These are separate server processes that manage the data and indexes on disk, while supporting simultaneous access by multiple clients.</p><p>This tutorial assumes you've already taken <a href="https://www.washington.edu/students/crscat/info.html#info340">a relational DBMS course</a> and already know the basics of the Structured Query Language (SQL). I will show you how to interact with a relational DBMS (RDBMS) from Go, and how to avoid SQL injection attacks.</p><p>I will also show you how to interact with the distributed document-oriented DBMS MongoDB. As opposed to a relational database that stores data in flat tables with columns, MongoDB stores full JSON documents that can have arbitrary schema, nested objects, arrays, etc. This flexibility is handy for many types of information systems, but it does come with a few trade-offs that I will discuss in more detail below.</p><h2 id="secinteractingwithrelationaldbmss">Interacting with Relational DBMSs</h2><p>In order to interact with a relational database from Go, we need a relational DBMS instance we can connect to and play with. Since you know how to use <a href="../docker/">Docker</a>, we can use it to spin-up any of the popular open-source relational DBMSs: MySQL, MariaDB, PostgreSQL, etc. There are endless debates about which of these is the best choice, and in truth, the answer depends on what you need the DBMS to do and how willing you are to tune it.</p><p>For purposes of this tutorial, let's use MySQL, though the code will be nearly identical if you choose a different DBMS. The only real differences will be which package you import, and which dialect of SQL you use for your queries.</p><h3 id="secrunningthemysqldockercontainer">Running the MySQL Docker Container</h3><p>Like many relational DBMSs, MySQL implements its own security system, with its own user accounts and passwords that are distinct from the host operating system. New instances automatically have one super-user account, known as <code>root</code>, but you need to supply the password you want that account to have. Let's start by defining a new environment variable to hold this password. Enter this into a new terminal window:</p><pre class="language-bash"><code class="language-bash"><span class="token function">export</span> MYSQL_ROOT_PASSWORD<span class="token operator">=</span><span class="token string">"some super-secret password"</span></code></pre><p>If you want a randomly-generated password, you can use the <code>rand</code> subcommand of <code>openssl</code>:</p><pre class="language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># generate 18 random bytes and base64 encode them</span>
<span class="token function">export</span> MYSQL_ROOT_PASSWORD<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>openssl rand -base64 18<span class="token variable">)</span></span>
<span class="token comment" spellcheck="true"># echo it so that you can see what it generated</span>
<span class="token keyword">echo</span> <span class="token variable">$MYSQL_ROOT_PASSWORD</span></code></pre><p>This sets the environment variable in the host shell, but remember that Docker containers are completely isolated by default, so we need to <a href="../docker/#secsettingenvironmentvariables">forward this environment variable</a> into the container when we run it using the <code>-e</code> flag.</p><p>In production, we would run the MySQL container within a <a href="../sessions/#secrunningredis">Docker private network</a> so that it's accessible only by our other containers, but during development, you typically want to connect to it from your web server running directly on your host, so that you can quickly restart and debug it. So in this case, we also want to publish port 3306, which is the default MySQL port.</p><p>Although you can create multiple databases within a MySQL server, web applications typically put all of their tables in just one database, so we also want to create a new database when the container starts. You can do this automatically by setting the <code>MYSQL_DATABASE</code> <a href="../docker/#secsettingenvironmentvariables">environment variable</a> to the name you want to give this new database.</p><p>To start the MySQL server with these settings, use this command</p><pre class="language-bash"><code class="language-bash">docker run -d \
-p 3306:3306 \
--name mysqldemo \
-e MYSQL_ROOT_PASSWORD<span class="token operator">=</span><span class="token variable">$MYSQL_ROOT_PASSWORD</span> \
-e MYSQL_DATABASE<span class="token operator">=</span>demo \
mysql</code></pre><p>Here we use the <code>-e</code> flag to set the <code>MYSQL_ROOT_PASSWORD</code> environment variable within the container. The value we use for this variable is the current value of the same variable name defined in our host shell (<code>$MYSQL_ROOT_PASSWORD</code>). This effectively forwards the environment variable into the container, though there is no lasting relationship between the two variables: if you change the variable defined in your host shell, it will have no effect on the variable defined within the running container.</p><p>Use <code>docker ps</code> to make sure the server is running. If it's not listed, use <code>docker logs mysqldemo</code> to see what error it wrote to the log file.</p><p>The server is now running, and we will soon connect to it from a Go program, but if you want to play around with the server, you can also connect to it from the MySQL CLI. This is a simple command-line interface that lets you execute SQL statements against the database. The CLI is included in the <code>mysql</code> container image, so we can run it by running another instance of that Docker container, overriding the default entry point:</p><pre class="language-bash"><code class="language-bash">docker run -it \
--rm \
--network host \
mysql sh -c <span class="token string">"mysql -h127.0.0.1 -uroot -p<span class="token variable">$MYSQL_ROOT_PASSWORD</span>"</span></code></pre><p>You've seen <a href="../docker/">many of these flags</a> before, but the <code>--network host</code> might be new to you. This tells Docker to run this container using the host machine's network stack rather than its own isolated network stack. When using this setting, the container's network can see everything your host's network can see, including that published 3306 port from the other MySQL server container.</p><p>The expression <code>sh -c "mysql -h127.0.0.1 -uroot -p$MYSQL_ROOT_PASSWORD"</code> that follows the <code>mysql</code> container image name overrides the default entry point command for that container, running the MySQL CLI instead. That CLI needs to know the host, user, and password to use when connecting, and we supply those values in the command arguments. Since we used double-quotes around the command, our host's shell will expand the <code>$MYSQL_ROOT_PASSWORD</code> expression to the value of the environment variable we set earlier, and pass that expanded value into the container when it starts.</p><p>If all goes well, you should now be at a MySQL CLI prompt inside the CLI container instance, talking to your MySQL server over in the other container instance. Try executing the <code>show databases;</code> query to see the list of databases, and <code>select version();</code> to get the database version number.</p><p>Execute the <code>exit</code> command to exit the CLI and return to your host prompt. Since we used the <code>--rm</code> flag, this CLI container will automatically be removed after it exits, but the server container instance will continue running.</p><h3 id="secinstallingthemysqlclientpackage">Installing the MySQL Client Package</h3><p>Relational databases are very similar to each other, and it's not uncommon for a project to switch engines over time. To make this easier, the Go standard library defines a common set of functions and structs in the <a href="https://golang.org/pkg/database/sql/">database/sql</a> package that are used when interacting with any relational DBMSs. This code in turn calls a RDBMS-specific package, known as a <strong>driver</strong>, to actually communicate with the database. These drivers implement the interfaces defined in the <a href="https://golang.org/pkg/database/sql/driver/">database/sql/driver</a> package for the specific RDBMS protocol.</p><p>To install the <a href="https://github.com/go-sql-driver/mysql">MySQL diver for Go</a> on your system, use this command:</p><pre class="language-bash"><code class="language-bash">go get -u github.com/go-sql-driver/mysql</code></pre><p>If it worked, you won't see any output: no news is good news!</p><h3 id="secconnectingfromagoprogram">Connecting From a Go Program</h3><p>Now let's see how to connect to our MySQL server instance from a Go program. Create a new directory at <code>$GOPATH/src/mysqldemo</code>, and in that directory create a new file named <code>main.go</code>. Add this code to that file:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"database/sql"</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>

    <span class="token boolean">_</span> <span class="token string">"github.com/go-sql-driver/mysql"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//create the data source name, which identifies the</span>
    <span class="token comment" spellcheck="true">//user, password, server address, and default database</span>
    dsn <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"root:%s@tcp(127.0.0.1:3306)/demo"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"MYSQL_ROOT_PASSWORD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//create a database object, which manages a pool of</span>
    <span class="token comment" spellcheck="true">//network connections to the database server</span>
    db<span class="token punctuation">,</span> err <span class="token operator">:=</span> sql<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"mysql"</span><span class="token punctuation">,</span> dsn<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error opening database: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//ensure that the database gets closed when we are done</span>
    <span class="token keyword">defer</span> db<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//for now, just ping the server to ensure we have</span>
    <span class="token comment" spellcheck="true">//a live connection to it</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> db<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error pinging database: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"successfully connected!\n"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>To run this program, execute this at the command line:</p><pre class="language-bash"><code class="language-bash">go run main.go</code></pre><p>The <code>_ "github.com/go-sql-driver/mysql"</code> import line might look strange, but it is essentially importing the MySQL driver without creating a local name for the package in our code. Since we will be using only the common functions and structs in the <code>database/sql</code> package, we will never need to call the MySQL driver directly. As you might have noticed in your own code, Go requires that you actually <em>use</em> all variables you declare, and package names are just like variables. If you import a package but never use anything from it, the Go compiler will generate an error, and the <code>goimports</code> tool will simply remove the import. But if we don't import the package, its code won't be in our built executable, which will cause an error at runtime.</p><p>To import a package that you never call, you can assign the blank identifier (<code>_</code>) to the imported package. This ensures the package gets into your built executable, but avoids the compile error you'd normally get from not calling any functions within that package. This is similar to how we use the blank identifier when ignoring one of the returned values from a function call.</p><p>The code in <code>main()</code> starts by creating a <strong>data source name</strong> string, the <a href="https://github.com/go-sql-driver/mysql#dsn-data-source-name">format</a> of which is defined by the MySQL driver package. Here we tell it to connect as the <code>root</code> user, supplying the value of the <code>MYSQL_ROOT_PASSWORD</code> environment variable as the password. We also specify that we want to connect to the server via TCP/IP at the address <code>127.0.0.1:3306</code>. The final <code>/demo</code> specifies the database name you want to use after connecting to the server. Here we ask for the database named "demo", which is the name we used in the <code>MYSQL_DATABASE</code> environment variable when we started the server.</p><p>The <code>sql.DB</code> object returned from the <code>sql.Open()</code> function is actually a reference to a whole pool of connections to the database server. A Go web server processes HTTP requests concurrently, so many requests may need to interact with the database at the same time. Since you can execute only one query at a time on a given database connection, the Go SQL package automatically maintains a pool of those connections, creating new ones as necessary to ensure that none of your HTTP requests are blocked waiting to talk to the database.</p><p>Since new connections are only made as needed, the last bit of code here just pings the server to ensure that we are able to connect to it. You don't typically need to do this, as it will open a connection the first time you query the database, but for now this will ensure that your Go program can actually connect and interact with the server.</p><h3 id="secbootstrappingthedatabaseschema">Bootstrapping the Database Schema</h3><p>The MySQL database container starts clean with only the basic system tables, so you need to create whatever schema your app needs. The best way to do that is to build your own Docker container image, based on the MySQL image, adding a schema creation script. The MySQL container will execute any <code>.sql</code> scripts you put into the <code>/docker-entrypoint-initdb.d/</code> directory within the container when the container instance starts.</p><p>To try this, create a file named <code>schema.sql</code> in your project directory, and add this SQL statement to it:</p><pre class="language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token keyword">exists</span> contacts <span class="token punctuation">(</span>
    id <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">auto_increment</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>
    email <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>
    first_name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>
    last_name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Then create this Dockerfile to build a new container image that automatically executes this script when it is started:</p><pre class="language-docker"><code class="language-docker"><span class="token keyword">FROM</span> mysql
<span class="token keyword">COPY</span> schema.sql /docker<span class="token punctuation">-</span>entrypoint<span class="token punctuation">-</span>initdb.d/schema.sql</code></pre><p>Then build the new image, giving it a name that starts with your Docker Hub user name:</p><pre class="language-bash"><code class="language-bash">docker build -t your-dockerhub-name/mysqldemo <span class="token keyword">.</span></code></pre><p>To run an instance of this new container image, use all of the same flags as above, but replace the <code>mysql</code> container image name with <code>your-dockerhub-name/mysqldemo</code>. Remember to stop and remove the existing container you ran earlier before running this new one.</p><p>For more details, see the "Initializing a fresh instance" section of the <a href="https://hub.docker.com/_/mysql/">MySQL Docker container documentation</a>.</p><h3 id="secinsertingandgettingautoassignedids">Inserting and Getting Auto-Assigned IDs</h3><p>To insert new rows into the database, use the <a href="https://golang.org/pkg/database/sql/#DB.Exec">.Exec()</a> method:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//insert a new row into the "contacts" table</span>
<span class="token comment" spellcheck="true">//use ? markers for the values to defeat SQL</span>
<span class="token comment" spellcheck="true">//injection attacks</span>
insq <span class="token operator">:=</span> <span class="token string">"insert into contacts(email, first_name, last_name) values (?,?,?)"</span>
res<span class="token punctuation">,</span> err <span class="token operator">:=</span> db<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>insq<span class="token punctuation">,</span> <span class="token string">"test@test.com"</span><span class="token punctuation">,</span> <span class="token string">"Test"</span><span class="token punctuation">,</span> <span class="token string">"Tester"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error inserting new row: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//get the auto-assigned ID for the new row</span>
    id<span class="token punctuation">,</span> err <span class="token operator">:=</span> res<span class="token punctuation">.</span><span class="token function">LastInsertId</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error getting new ID: %v\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"ID for new row is %d\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>The <code>.Exec()</code> method returns a <a href="https://golang.org/pkg/database/sql/#Result">sql.Result</a> object, which exposes a <code>.LastInsertId()</code> method to get the newly-assigned primary key value for an inserted row. When we created the table above, we added the <a href="https://dev.mysql.com/doc/refman/5.7/en/example-auto-increment.html">auto_increment</a> option to the <code>id</code> column, which tells MySQL to automatically assign a unique integer to that column in newly-inserted rows. Since the server assigns this value, your code typically needs to ask for it after insertion so that you can insert other related rows, or return the new primary key value to your web client.</p><h3 id="secguardingagainstsqlinjectionattacks">Guarding Against SQL Injection Attacks</h3><p>Many of the SQL statements you will execute from your web server will include values posted to your server by the web client. The first rule of web security is <strong>assume all requests are hostile</strong>, and the second related rule is <strong>never trust data posted to your web server</strong>. Many amateur developers simply concatenate posted values into their SQL statements, which creates a <a href="https://www.owasp.org/index.php/SQL_Injection">SQL injection</a> vulnerability. For example <strong>you should never do this</strong>:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//NEVER DO THIS!</span>
searchQuereyFromClient <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">FormValue</span><span class="token punctuation">(</span><span class="token string">"q"</span><span class="token punctuation">)</span>
sql <span class="token operator">:=</span> <span class="token string">"select * from users where last_name='"</span> <span class="token operator">+</span> searchQueryFromClient <span class="token operator">+</span> <span class="token string">"'"</span></code></pre><p>SQL is an interpreted language, and this concatenation approach allows clients to inject arbitrary code into your SQL that will be interpreted by the RDBMS. For example, an attacker could post this search query:</p><pre><code>' or 'a'='a</code></pre><p>When concatenated as above, this results in the following SQL query:</p><pre class="language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> users <span class="token keyword">where</span> last_name<span class="token operator">=</span><span class="token string">''</span> <span class="token operator">or</span> <span class="token string">'a'</span><span class="token operator">=</span><span class="token string">'a'</span></code></pre><p>This would select all users, even if that shouldn't be allowed.</p><p>A much more destructive hacker could also take advantage of the way most RDBMSs allow clients to execute multiple statements separated by <code>;</code>. This hacker could post the following, much more devious search query:</p><pre><code>'; drop table users; select '</code></pre><p>When concatenated as above, this results in the following SQL:</p><pre class="language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> users <span class="token keyword">where</span> last_name<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">;</span> <span class="token keyword">drop</span> <span class="token keyword">table</span> users<span class="token punctuation">;</span> <span class="token keyword">select</span> <span class="token string">''</span></code></pre><p>If you send this to your RDBMS, it will execute the first select statement, resulting in zero rows, then drop the entire users table, and finally select an empty string. As you might expect, the results would be rather damaging!</p><p>The correct way to incorporate values posted from a web client is to use parameter markers <code>?</code>, as shown in the previous section. The driver will ensure that these values are encoded or handled separately so that these kinds of SQL injection tricks won't succeed.</p><h3 id="secselectingrows">Selecting Rows</h3><p>When selecting rows, use the <code>db.Query()</code> method. This will execute the query and allow you to read one row at a time from the response stream. To work with the column values, we <strong>scan</strong> them into struct fields or variables:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Contact represents a contact record</span>
<span class="token keyword">type</span> Contact <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    ID        <span class="token builtin">int</span>
    Email     <span class="token builtin">string</span>
    FirstName <span class="token builtin">string</span>
    LastName  <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//select rows from the table</span>
rows<span class="token punctuation">,</span> err <span class="token operator">:=</span> db<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span><span class="token string">"select id,email,first_name,last_name from contacts"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">//ensure the rows are closed</span>
<span class="token keyword">defer</span> rows<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"rows\n-----\n"</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//create a contact struct and scan</span>
<span class="token comment" spellcheck="true">//the columns into the fields</span>
contact <span class="token operator">:=</span> Contact<span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//while there are more rows</span>
<span class="token keyword">for</span> rows<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> rows<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>contact<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token operator">&amp;</span>contact<span class="token punctuation">.</span>Email<span class="token punctuation">,</span>
        <span class="token operator">&amp;</span>contact<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span> <span class="token operator">&amp;</span>contact<span class="token punctuation">.</span>LastName<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error scanning row: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//print the struct values to std out</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d, %s, %s, %s\n"</span><span class="token punctuation">,</span> contact<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> contact<span class="token punctuation">.</span>Email<span class="token punctuation">,</span>
        contact<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span> contact<span class="token punctuation">.</span>LastName<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//if we got an error fetching the next row, report it</span>
<span class="token keyword">if</span> err <span class="token operator">:=</span> rows<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error getting next row: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>There are a few things to note here. First, Go doesn't buffer the entire result set in memory, as it could be enormous. Instead, the <code>.Query()</code> method returns a <code>sql.Rows</code> object, which lets you load one row at time into memory, and scan the columns into struct fields or variables. Each time you call <code>rows.Next()</code>, the internal row buffer is overwritten with the next row's data, so only one row remains in memory at a time.</p><p>Second, to actually work with the column data, you have to scan it into struct fields or variables. This is done using the <code>.Scan()</code> method, passing the address of the target fields/variables. The order of the arguments you pass to <code>.Scan()</code> should match the order of the columns in your <code>select</code> SQL statement. Ensure that the data type of your target field/variable is compatible with the data in the source column; the <code>.Scan()</code> method will do some type conversions if they are safe, but will generate errors if converting to the target type would result in data loss.</p><p>Third, errors could happen at any point: executing the select query; reading the next row; or scanning column values. Check for returned errors and report them in whatever way makes sense for your application. Here we just write to standard out, but in a web server, you'd use the <code>http.Error()</code> function instead.</p><h3 id="seccleaningup">Cleaning Up</h3><p>To stop and remove your MySQL container, use this command, but note that this will also permanently delete all the data in the database:</p><pre class="language-bash"><code class="language-bash">docker <span class="token function">rm</span> -f mysqldemo</code></pre><p>If you want to keep the actual data files between container runs, you need to mount a volume when running the server. See the <a href="https://hub.docker.com/_/mysql/">Where to Store Data section</a> of the MySQL Docker image documentation, as well as the <a href="https://docs.docker.com/engine/tutorials/dockervolumes/">Managing Data in Containers</a> article in the Docker documentation for more details.</p><h2 id="secinteractingwithmongodb">Interacting with MongoDB</h2><p>Distributed document-oriented DBMSs have become a popular alternative to relational DBMSs, as they allow you to change your schema easily over time, and distribute your data amongst multiple machines in a cluster. Instead of storing data in tables with rows and columns, these DBMSs store flexible "documents" that contain whatever data you want. The most popular of these in the open-source world is <a href="https://www.mongodb.com/">MongoDB</a>.</p><p>A MongoDB server can have one or more databases, each of which contains one or more <strong>collections</strong> of binary JSON (BSON) documents. These collections are sort of like tables in a relational database, but they don't enforce any sort of schema on those documents (though recent versions of MongoDB now support <a href="https://docs.mongodb.com/manual/core/document-validation/">simple document validation</a>). Instead collections are just groups of documents that you want to organize together, and they are commonly used to group documents by type (e.g., all user profile documents are saved in a "users" collection).</p><p>Since collections don't really establish schema, they are created automatically as you insert documents into them. Databases are created automatically as well the first time you reference them. This means that a MongoDB server requires no bootstrapping: you can just run it and start inserting documents.</p><p>This lack of schema enforcement is handy in the early days of a system, when requirements are rapidly shifting, but it's also one of the significant drawbacks of document-oriented database like MongoDB. You have to validate the data somewhere, and if the DBMS doesn't do it, your application has to. The burden of validation is still there: it just shifts from the DBMS to your own code.</p><p>The other significant drawback of MongoDB is that it can't join related data in the server. MongoDB does offer some <a href="https://docs.mongodb.com/manual/tutorial/query-documents/">powerful query operations</a> on collections, but it doesn't join related data across collections like the SQL <code>JOIN</code> operator can. Instead, MongoDB encourages you to denormailze your data, duplicating information on the assumption that it changes far less frequently than you will have to read it. Denormalizing definitely increases read performance, but the burden of updating duplicated data falls upon the application developer, and it's easy to forget.</p><h3 id="secrunningthemongodbdockercontainer">Running the MongoDB Docker Container</h3><p>Just like MySQL, MongoDB releases an official Docker container image with the name <code>mongo</code>. Although you can setup a root user password for the MongoDB server, you don't have to. If you run both your MongoDB and application container in a Docker private network, only your application will be allowed to connect to it, so there's not really any need to setup a root password unless you don't trust your system engineers (which is a much bigger problem).</p><p>Just as before, we are going to publish the database server's default port (27017) for this tutorial so that a Go programming running on our host will be able to connect to it. In production, use a private Docker network instead.</p><pre class="language-bash"><code class="language-bash">docker run -d \
-p 27017:27017 \
--name mongodemo \
mongo</code></pre><p>Use <code>docker ps</code> to ensure that it's running.</p><p>We will soon connect to the server from a Go program, but you can also use the MongoDB CLI to interact with the server. The MongoDB CLI is included in the <code>mongo</code> Docker container, so you can run another instance of that container, overriding the default entry point, just like we did with the MySQL CLI:</p><pre class="language-bash"><code class="language-bash">docker run -it \
--rm \
--network host \
mongo sh -c <span class="token string">'exec mongo 127.0.0.1/demo'</span></code></pre><p>If all goes well, the MongoDB CLI container instance will connect to the server container instance you ran earlier, and put you at the CLI prompt. You will be inside a new database named "demo." Try executing <code>help</code> to see a list of commands, or refer to the <a href="https://docs.mongodb.com/manual/reference/mongo-shell/">Mongo Shell Quick Reference</a> for a more detailed list.</p><p>To insert a new test document, use this command:</p><pre class="language-javascript"><code class="language-javascript">db<span class="token punctuation">.</span>contacts<span class="token punctuation">.</span><span class="token function">insertOne</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"email"</span><span class="token punctuation">:</span> <span class="token string">"test@test.com"</span><span class="token punctuation">,</span> <span class="token string">"firstName"</span><span class="token punctuation">:</span> <span class="token string">"Test"</span><span class="token punctuation">,</span> <span class="token string">"lastName"</span><span class="token punctuation">:</span> <span class="token string">"Tester"</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>The <code>db</code> variable refers to the current database, and <code>.contacts</code> refers to a collection named "contacts." Since this collection doesn't exist yet, MongoDB just creates it for you automatically. The <code>.insertOne()</code> method of the collection inserts one new JSON document, which is supplied as the first parameter.</p><p>MongoDB automatically assigns an <code>_id</code> property to every inserted document by default, set to a new <code>ObjectId</code> value. This is a globally-unique value that won't collide with other document IDs in this database or anywhere else. It's like a <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>.</p><p>To see this new property, use the following command to find all the documents in the "contacts" collection:</p><pre class="language-javascript"><code class="language-javascript">db<span class="token punctuation">.</span>contacts<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>To clean up, drop the "contacts" collection with this command:</p><pre class="language-javascript"><code class="language-javascript">db<span class="token punctuation">.</span>contacts<span class="token punctuation">.</span><span class="token function">drop</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>Enter the <code>exit</code> command to exit the CLI and return to your host's shell prompt. Just as in the MySQL example, the server container will continue running in the background, but the CLI container will be stopped and removed automatically because we used the <code>--rm</code> flag when running it.</p><h3 id="secinstallingthemongodbclientpackage">Installing the MongoDB Client Package</h3><p>To connect to a MongoDB server from Go, you need to install the <a href="https://labix.org/mgo">mgo package</a> (pronounced "mango"). Since MongoDB is not a relational database, it doesn't implement a driver for the <code>database/sql</code> package. Instead you use the <code>mgo</code> package directly.</p><pre class="language-bash"><code class="language-bash">go get gopkg.in/mgo.v2</code></pre><p>If all goes well, you won't see any output. Remember, no news is good news!</p><h3 id="secconnectingfromagoprogram-1">Connecting from a Go Program</h3><p>Create a new directory at <code>$GOPATH/src/mongodemo</code> and create a <code>main.go</code> file within that directory. Add the following code to that file:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>

    <span class="token string">"gopkg.in/mgo.v2"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sess<span class="token punctuation">,</span> err <span class="token operator">:=</span> mgo<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error dialing mongo: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"connected successfully!"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Here we use the <a href="http://godoc.org/gopkg.in/mgo.v2#Dial">mgo.Dial()</a> function to connect to the MongoDB server running on our local host (127.0.0.1). As opposed to the <code>database/sql</code> package, this function does actually establish a network connection right away, so if it succeeds, your Go application is able to connect to your server. The <code>sess</code> variable is a reference to an <a href="http://godoc.org/gopkg.in/mgo.v2#Session">mgo.Session</a> object, which has several methods for manipulating the database.</p><h3 id="secinsertingdata">Inserting Data</h3><p>Since MongoDB doesn't use SQL, we insert data a little differently. The <code>mgo</code> package can save any Go struct as a MongoDB document by marshaling it into Mongo's binary JSON (BSON) format. It can also read any saved document back into that Go struct. This makes it ridiculously easy to save and read records.</p><p>When saving a struct, the <code>mgo</code> package marshals it into BSON similarly to how the <code>json</code> package marshals structs into JSON. All struct fields you want to save must be exported (i.e., start with a capital letter) so that the <code>mgo</code> package can see them.</p><p>By default, the property names used in the stored document will be your Go struct field names converted to lower-case. For example, a Go struct field named <code>FirstName</code> will be saved as the property <code>firstname</code> in the database document. Knowing this becomes important when you need to refer to that property name, such as in a filter condition to a query.</p><p>Just as with the JSON marshaler, you can override the property name used in the stored document by adding a <code>bson</code> struct field tag. This is often useful for the struct field you use to hold the unique ID for the document. Recall that MongoDB expects this property to be named <code>_id</code>, but that leading underscore would make for an awkward Go struct field name. We can use the <code>bson</code> struct field tag to map a struct field named <code>ID</code> to a BSON property named <code>_id</code>:</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> Contact <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    ID        bson<span class="token punctuation">.</span>ObjectId <span class="token string">`bson:"_id"`</span> <span class="token comment" spellcheck="true">//saved to mongo as `_id`</span>
    Email     <span class="token builtin">string</span>
    FirstName <span class="token builtin">string</span>
    LastName  <span class="token builtin">string</span>
<span class="token punctuation">}</span></code></pre><p>When creating an instance of this Contact struct, use the <code>bson.NewObjectId()</code> function to generate a new ObjectId for the <code>ID</code> struct field:</p><pre class="language-go"><code class="language-go">c <span class="token operator">:=</span> <span class="token operator">&amp;</span>Contact<span class="token punctuation">{</span>
    ID<span class="token punctuation">:</span>        bson<span class="token punctuation">.</span><span class="token function">NewObjectId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Email<span class="token punctuation">:</span>     <span class="token string">"test@test.com"</span><span class="token punctuation">,</span>
    FirstName<span class="token punctuation">:</span> <span class="token string">"Test"</span><span class="token punctuation">,</span>
    LastName<span class="token punctuation">:</span>  <span class="token string">"Tester"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code></pre><p>If you have a Go extension installed in your editor, it should add an import for the <code>"gopkg.in/mgo.v2/bson"</code> package automatically, but if not, add that to your list of imports manually. The <code>bson</code> package provides an implementation of the binary JSON (BSON) format used for MongoDB documents, as well as those globally unique ObjectIds used by MongoDB. Interestingly, this package doesn't depend upon anything in the <code>mgo</code> package, so you can actually use the <code>bson</code> package on its own whenever you need to generate unique identifiers.</p><p>To insert this new struct instance into the database, use code like this:</p><pre class="language-go"><code class="language-go">    <span class="token comment" spellcheck="true">//get a reference to the "contacts" collection</span>
    <span class="token comment" spellcheck="true">//in the "demo" database</span>
    coll <span class="token operator">:=</span> sess<span class="token punctuation">.</span><span class="token function">DB</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token string">"contacts"</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//insert struct into that collection</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> coll<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error inserting document: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"inserted document with ID %s\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>ID<span class="token punctuation">.</span><span class="token function">Hex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span></code></pre><p>The <code>sess.DB("demo")</code> part selects the "demo" database (creating it automatically if necessary), and the <code>.C("contacts")</code> part selects the "contacts" collection (creating it automatically if necessary). The <code>.Insert()</code> method on the collection inserts the struct instance as a new document, and returns an error if something went wrong. Since we assigned the new ObjectId when we created the struct, we already know what it is.</p><p>When we print the new ID, we use the <a href="http://godoc.org/labix.org/v2/mgo/bson#ObjectId.Hex">.Hex() method</a> on the <code>bson.ObjectId</code>. An ObjectId is actually a 12-byte binary value, so if you want to print it in human-readable form, use the <code>.Hex()</code> method to get a hex-encoded string of the bytes. There is a parallel <a href="http://godoc.org/labix.org/v2/mgo/bson#ObjectIdHex">bson.ObjectIdHex()</a> function that hex-decodes a string back into a <code>bson.ObjectId</code>.</p><h3 id="secfindingdata">Finding Data</h3><p>Finding documents in a collection is also fairly straightforward. If you know that the results will fit comfortably in memory, you can create an empty slice of structs and read all of the results into it:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//create an empty slice of </span>
<span class="token comment" spellcheck="true">//pointers to Contact structs</span>
contacts <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Contact<span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//find all documents where the lastname property contains "Tester"</span>
<span class="token comment" spellcheck="true">//and decode them into the slice</span>
<span class="token comment" spellcheck="true">//(using same `coll` variable from earlier code snippet)</span>
coll<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>bson<span class="token punctuation">.</span>M<span class="token punctuation">{</span><span class="token string">"lastname"</span><span class="token punctuation">:</span> <span class="token string">"Tester"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">All</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>contacts<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//iterate over the slice, printing the data to std out</span>
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> c <span class="token operator">:=</span> <span class="token keyword">range</span> contacts <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s: %s, %s, %s\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>ID<span class="token punctuation">.</span><span class="token function">Hex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>Email<span class="token punctuation">,</span> c<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span> c<span class="token punctuation">.</span>LastName<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>The <code>.Find()</code> method finds all documents in the collection that match the selection document passed as the first argument. Here we use <code>bson.M{"lastname": "Tester"}</code> to create that selection document. <a href="http://godoc.org/labix.org/v2/mgo/bson#M">bson.M</a> is just a type declaration for <code>map[string]interface{}</code>, so this essentially creates a new map containing one key ("lastname") and value ("Tester"). MongoDB uses this selection document like a <code>WHERE</code> clause in SQL: in this case it finds all documents where the <code>"lastname"</code> property is set to <code>"Tester"</code>. Note that the property name is lower-cased because, as I noted earlier, the marshaler converts Go struct field names to lower case by default.</p><p>These selection documents can get quite complex so that you can find just the documents you are looking for. See the <a href="https://docs.mongodb.com/manual/tutorial/query-documents/">Query Documents</a> tutorial on the MongoDB site for a full tour of what's possible.</p><p>In the example above, we use the <code>.All()</code> method to read all of the documents we find into the slice of <code>*Contact</code> structs. This is fine if you know the results will fit into memory all at once, but if you are selecting a large number of documents, you can process them one at a time, similar to the way the <code>database/sql</code> package handles rows. Instead of using <code>.All()</code> use <code>.Iter()</code> to create an iterator:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//declare just one empty contact struct</span>
<span class="token comment" spellcheck="true">//to receive one document at a time</span>
c <span class="token operator">=</span> <span class="token operator">&amp;</span>Contact<span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//create an iterator for the found documents</span>
iter <span class="token operator">:=</span> coll<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>bson<span class="token punctuation">.</span>M<span class="token punctuation">{</span><span class="token string">"lastname"</span><span class="token punctuation">:</span> <span class="token string">"Tester"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//for as long as we get another document from the iterator...</span>
<span class="token keyword">for</span> iter<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//print the data to std out</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s: %s, %s, %s\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>ID<span class="token punctuation">.</span><span class="token function">Hex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>Email<span class="token punctuation">,</span> c<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span> c<span class="token punctuation">.</span>LastName<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//report any errors that occurred</span>
<span class="token keyword">if</span> err <span class="token operator">:=</span> iter<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error iterating found documents: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>The <code>.Next()</code> method of the iterator will return <code>false</code> after all the documents have been read, or if there is an error. To check for errors, use the <code>.Err()</code> method after you exit the loop.</p><p>The <code>mgo</code> package also offers a convenience method for finding one document by its unique ID. Use the <a href="http://godoc.org/gopkg.in/mgo.v2#Collection.FindId">.FindId()</a> method to create a query to find a document by its unique ID, and then use the <a href="http://godoc.org/gopkg.in/mgo.v2#Query.One">.One()</a> method on that query to read the document into your struct. If the document is not found, you will get a <a href="http://godoc.org/gopkg.in/mgo.v2#pkg-variables">mgo.ErrNotFound</a> error.</p><pre class="language-go"><code class="language-go">c <span class="token operator">=</span> <span class="token operator">&amp;</span>Contact<span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//assuming a variable `id`</span>
<span class="token comment" spellcheck="true">//set to the ObjectId you want to find</span>
coll<span class="token punctuation">.</span><span class="token function">FindId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">One</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span></code></pre><h3 id="secupdatingdata">Updating Data</h3><p>Updating data is done by either entirely replacing the current document with a new one, or by sending an update document containing just the properties you want to change and the values you want to change them to. The latter option is typically what you want to do from a web server, and the code would look like this:</p><pre class="language-go"><code class="language-go">id <span class="token operator">:=</span> <span class="token comment" spellcheck="true">//...bson ObjectId of the document you want to update</span>

<span class="token comment" spellcheck="true">//create a map with the properties you want to update</span>
<span class="token comment" spellcheck="true">//you can alternatively use a struct here instead</span>
updates <span class="token operator">:=</span> bson<span class="token punctuation">.</span>M<span class="token punctuation">{</span><span class="token string">"firstname"</span><span class="token punctuation">:</span> <span class="token string">"UPDATED Test"</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//send an update document with a `$set` property set to the updates map</span>
<span class="token keyword">if</span> err <span class="token operator">:=</span> coll<span class="token punctuation">.</span><span class="token function">UpdateId</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> bson<span class="token punctuation">.</span>M<span class="token punctuation">{</span><span class="token string">"$set"</span><span class="token punctuation">:</span> updates<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error updating document: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>The update document we send here has just one property named <code>$set</code>. The value for the property is another map containing the properties we want to update and their new values. MongoDB applies these updates to the document and leaves all the other properties as they were.</p><p>See the <a href="https://docs.mongodb.com/manual/tutorial/update-documents/">Update Documents Tutorial</a> on the MongoDB site for more details on how you can update documents.</p><h3 id="secdeletingdata">Deleting Data</h3><p>Deleting data is similar to finding data, except you use the <a href="http://godoc.org/gopkg.in/mgo.v2#Collection.Remove">.Remove(), .RemoveAll() or .RemoveId()</a> methods. The <code>.RemoveId()</code> method accepts an ObjectId to remove, whereas <code>.Remove()</code> and <code>.RemoveAll()</code> accept selection documents.</p><p>For example, to delete a document with a particular ID, the code would look like this:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//assuming `id` has been set to a bson.ObjectId...</span>
<span class="token keyword">if</span> err <span class="token operator">:=</span> coll<span class="token punctuation">.</span><span class="token function">RemoveId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error deleting document: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><h3 id="seccleaningup-1">Cleaning Up</h3><p>To stop your MongoDB server container, use this command. Just as with the MySQL container, this will also delete all data you've stored in the database:</p><pre class="language-bash"><code class="language-bash">docker <span class="token function">rm</span> -f mongodemo </code></pre><p>To maintain the data between container runs, see the <a href="https://hub.docker.com/_/mongo/">Where to Store Data</a> section of the MongoDB Docker container documentation.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>