<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.4.3/css/bulma.min.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Go Structs and JSON"><meta property="og:description" content="How to encode structs into JSON and decode JSON into structs"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Go Structs and JSON</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Go Structs and JSON</h1><p class="subtitle">How to encode structs into JSON and decode JSON into structs</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jul 12, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>One of the key scenarios for the Go language was <a href="../goweb/">building web servers</a>, and since data on the web is typically transmitted in the <a href="http://www.json.org/">JSON format</a>, Go has excellent <a href="https://golang.org/pkg/encoding/json">support for JSON</a>. It's very easy to encode a Go <a href="../golang/#secstructs">struct</a> into JSON, or decode JSON into a struct. Go also provides us some control over how that encoding/decoding occurs.</p><h2 id="secencoding">Encoding</h2><p>If you have an instance of a struct, you can encode it into JSON like so:</p><pre><code class="go language-go">package main

import (
    "encoding/json" //JSON package from the standard library
    "fmt"
    "os"
)

//Rectangle represents a rectangle shape
type Rectangle struct {
    Top    int
    Left   int
    Width  int
    Height int
}

func main() {
    //create an instance of a Rectangle
    r := Rectangle{10, 20, 30, 40}

    //create a new JSON encoder over stdout
    //and encode the struct into JSON
    enc := json.NewEncoder(os.Stdout)
    if err := enc.Encode(r); err != nil {
        fmt.Printf("error encoding struct into JSON: %v\n", err)
    }
}</code></pre><p><a href="https://play.golang.org/p/Esk_nrSyZ3" class="button is-primary">Run in the Go Playground</a></p><p>The <code>json.NewEncoder()</code> function creates a new <code>json.Encoder</code> object, which can write JSON-encoded data to the stream supplied as the first parameter. Here we pass <code>os.Stdout</code>, which is the <a href="https://en.wikipedia.org/wiki/Standard_streams">standard output stream</a> from the operating system shell. This creates a data transformation pipeline that looks conceptually like this:</p><p><img src="img/json-encoder.png" alt="json encoder data pipeline"></p><p>The output stream can be any writable stream. Here we use standard out, but in a <a href="../goweb/">web server</a> we will use the HTTP response stream to write encoded JSON back to the client.</p><p>The <code>.Encode()</code> method of the encoder does the actually JSON and encoding and writing to the target stream. It will return an error if the data you are trying to encode can't be translated into legal JSON. For example, there are several values in Go that can't be represented in JSON: an infinite number, or the not-a-number (NaN) value. Go <a href="../goslicemap/#secmaps">maps</a> are automatically converted into JSON objects, but Go allows you to use data types for keys other than <code>string</code>, while JSON only supports strings for object keys.</p><p>The encoder will handle all sorts of data types, including maps, slices, and pointers to other structs. Be careful about circular references: the Go garbage collector can handle two struct instances that point to each other, but the JSON encoder will chase those pointers infinitely and hang your program!</p><p>The error checking code above also demonstrates a neat trick in Go that isn't common in other languages: the <code>if</code> statement can have an initializer expression, similar to the first expression in the <code>for</code> statement. The expression before the <code>;</code> is executed and then the condition after the <code>;</code> is evaluated to determine if the code inside the <code>if</code> block should be executed. This use an initializer for error checking is a common idiom in Go programming.</p><h2 id="secfieldsmustbeexportedtobeencoded">Fields Must be Exported to be Encoded</h2><p>One thing that trips up most people who are new to Go is that the JSON encoder can only see, and therefore only encode, exported fields in a struct. Recall that Go uses the package boundary as its primary mechanism for encapsulation, and that <a href="../golang/#secpackagesandcodeorganization">only the identifiers that start with a capital letter are exported</a>. Since the JSON encoder is defined in the <code>json</code> package and not your <code>main</code> package, it can only see the fields in your struct that are exported from your package. Therefore, if you want a field encoded into JSON, it must be exported, so it must start with a capital letter.</p><p>When I first started learning Go, I spent several hours trying to figure out why a struct like this was being encoded into an empty JSON object:</p><pre><code class="go language-go">type Rectangle struct {
    top    int
    left   int
    width  int
    height int
}</code></pre><p>See the difference? The fields are all lower-case, and therefore are not exported from the <code>main</code> package. You can pass this struct to the JSON encoder, but <a href="https://play.golang.org/p/cp21hp1k7g">the result will always be an empty JSON object</a> because the code in the <code>json</code> package can't see those fields.</p><p>This is an easy trap to fall into because the <code>.Encode()</code> method <strong>won't return any sort of error</strong>. On the one hand this makes sense: unexported fields are private to the package, and therefore shouldn't be encoded into JSON, as those fields are probably used to track private implementation details. But on the other hand, it would lead to less frustrating mistakes if the encoder returned an error when there are no exported fields at all. That case is likely the result of a programming error.</p><p>But alas, that's the current behavior, so watch out for it.</p><h2 id="seccustomizingtheencoding">Customizing the Encoding</h2><p>Since fields must be exported to be encoded, and since exported field names must start with a capital letter, if you run the code above you'll notice that the output looks like this:</p><pre><code class="json language-json">{"Top":10,"Left":20,"Width":30,"Height":40}</code></pre><p>Since the JSON keys are named the same as the struct fields, they all start with a capital letter. This is legal JSON, but it's counter to the JavaScript convention of using <code>camelCased</code> property names. Thankfully, Go allows us to customize the JSON encoding, including changing the names of the keys used in the generated JSON.</p><p>For example, say we want the JSON keys to be <code>top</code>, <code>left</code>, <code>width</code>, and <code>height</code>. We can add "tags" to the struct fields to provide these different key names:</p><pre><code class="go language-go">type Rectangle struct {
    Top    int `json:"top"`
    Left   int `json:"left"`
    Width  int `json:"width"`
    Height int `json:"height"`
}</code></pre><p>Field tags are a generic mechanism for encoding extra meta-data about a field, and the JSON encoder uses this mechanism to let you override the key name in the generated JSON. Whatever name you put in the quotes after the <code>json:</code> label will be used both for encoding to and decoding from JSON.</p><p>The JSON encoder allow not only a custom name, but a few other options as well. For example, large structures may have many fields that are set to their zero-value, and therefore don't really need to be encoded into JSON. If you want a field omitted when it is set to its zero-value, use the <code>omitempty</code> option:</p><pre><code class="go language-go">type Rectangle struct {
    Top    int `json:"top,omitempty"`
    Left   int `json:"left,omitempty"`
    Width  int `json:"width,omitempty"`
    Height int `json:"height,omitempty"`
}</code></pre><p>And if you want a field to be exported so that code in your other packages can see it, but never encoded into JSON, you can set the name to <code>"-"</code>, which will always omit it from encoding:</p><pre><code class="go language-go">type Rectangle struct {
    Top    int    `json:"top,omitempty"`
    Left   int    `json:"left,omitempty"`
    Width  int    `json:"width,omitempty"`
    Height int    `json:"height,omitempty"`
    Secret string `json:"-"` //will never be encoded
}</code></pre><p>These tags can be laborious to add, so many of the editor/IDE extensions will generate them for you. In Visual Studio Code, put your cursor somewhere in the struct definition and then open the command palette using <code>Cmd+Shift+P</code> on Mac or <code>Ctrl+Shift+P</code> on Windows and Linux. Type <code>go: add tags</code> and select the command <code>go: Add Tags to Struct Fields</code>. Conversely you can use <code>go: remove tags</code> to remove all tags from a struct's fields.</p><h2 id="secmarshaling">Marshaling</h2><p>The <code>json.Encoder</code> object can write to any writable stream, but sometimes you need the encoded JSON in a variables so that you can manipulate it in memory, or pass it to some other non-stream-oriented function (e.g., a database API). In this case, use the <code>json.Marshal()</code> function:</p><pre><code class="go language-go">//create an instance of a Rectangle
r := Rectangle{10, 20, 30, 40}

//marshal into JSON buffer
buffer, err := json.Marshal(r)
if err != nil {
    fmt.Printf("error marshaling JSON: %v\n", err)
}</code></pre><p>The <code>json.Marshal()</code> function returns a byte slice (<code>[]byte</code>) and potentially an error. The byte slice is a memory buffer that you can iterate and manipulate, just like any other slice. Or you can pass the byte slice to some other function that takes a <code>[]byte</code> as a parameter.</p><h2 id="secdecoding">Decoding</h2><p>To decode JSON from a stream into a struct, the code is very similar to the encoding scenario:</p><pre><code class="go language-go">//create an empty instance of a Rectangle
//to receive the decoded JSON
//note that r is a pointer to a Rectangle
r := &amp;Rectangle{}

//create a new decoder over stdin
//and decode the JSON into the struct
dec := json.NewDecoder(os.Stdin)
if err := dec.Decode(r); err != nil {
    fmt.Printf("error decoding JSON: %v\n", err)
}

fmt.Println(r)</code></pre><p><a href="https://play.golang.org/p/HmU5_1zQ-z" class="button is-primary">Run in the Go Playground</a></p><p>This code will read a JSON string from the standard input stream supplied by the operating system shell, decode that into a new empty <code>*Rectangle</code>, and then just print the struct so you can see it. The Go Playground doesn't have a standard input stream, so the version there uses the <code>strings</code> package to create a readable stream over a simple string instead.</p><p>The JSON decoder will set the values of struct fields that are found in the input JSON, but it will silently ignore other keys that do not match a field in the target struct. This is good, as it allows you to use a struct definition to enforce a particular schema for the input JSON. If nefarious clients post extra JSON data to your web server, it will just be ignored instead of written unwittingly into your database.</p><h2 id="secunmarshaling">Unmarshaling</h2><p>Just as <code>Marshal()</code> encodes to a byte slice rather than a stream, <code>Unmarshal</code> decodes from a byte slice containing JSON.</p><pre><code class="go language-go">//create an empty instance of a Rectangle
//to receive the decoded JSON
r := &amp;Rectangle{}

//unmarshal from a string that is converted to a byte slice
s := `{"top": 10, "left": 20, "width": 30, "height": 40}`
buffer := []byte(s)
if err := json.Unmarshal(buffer, r); err != nil {
    fmt.Printf("error unmarshaling JSON: %v\n", err)
}

fmt.Println(r)</code></pre><p><a href="https://play.golang.org/p/YkEUyDOOW2" class="button is-primary">Run in the Go Playground</a></p><h2 id="secmoredetails">More Details</h2><p>For more details on Go's support for JSON, see the <a href="https://blog.golang.org/json-and-go">JSON and Go</a> article on the Go Blog. For a longer article on the virtue of stream-based interfaces in Go, see <a href="https://www.datadoghq.com/blog/crossing-streams-love-letter-gos-io-reader/">Crossing Streams: a love letter to Go io.Reader</a>.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href="..">table of contents</a></p></div></div></footer><script src="../lib/prism.js"></script><script>Prism.plugins.customClass.map({number:"prism-number"});var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var n=document.createElement("a");n.textContent="#",n.href="#"+e.id,n.classList.add("bookmark-link"),e.appendChild(n)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>