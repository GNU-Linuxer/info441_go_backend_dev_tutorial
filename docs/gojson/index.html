<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../_lib/bulma.min.css"><link rel="stylesheet" href="../_lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../_lib/prism.css"><link rel="icon" href="../_img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Go Structs and JSON"><meta property="og:description" content="How to encode structs into JSON and decode JSON into structs"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Go Structs and JSON</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Go Structs and JSON</h1><p class="subtitle">How to encode structs into JSON and decode JSON into structs</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jul 12, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>One of the key scenarios for the Go language was <a href="../goweb/">building web servers</a>, and since data on the web is typically transmitted in the <a href="http://www.json.org/">JSON format</a>, Go has excellent <a href="https://golang.org/pkg/encoding/json">support for JSON</a>. It's very easy to encode a Go <a href="../golang/#secstructs">struct</a> into JSON, or decode JSON into a struct. Go also provides us some control over how that encoding/decoding occurs.</p><h2 id="secencoding">Encoding</h2><p>If you have an instance of a struct, you can encode it into JSON like so:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"encoding/json"</span> <span class="token comment" spellcheck="true">//JSON package from the standard library</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//Rectangle represents a rectangle shape</span>
<span class="token keyword">type</span> Rectangle <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Top    <span class="token builtin">int</span>
    Left   <span class="token builtin">int</span>
    Width  <span class="token builtin">int</span>
    Height <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//create an instance of a Rectangle</span>
    r <span class="token operator">:=</span> <span class="token operator">&amp;</span>Rectangle<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//create a new JSON encoder over stdout</span>
    <span class="token comment" spellcheck="true">//and encode the struct into JSON</span>
    enc <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">NewEncoder</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> enc<span class="token punctuation">.</span><span class="token function">Encode</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error encoding struct into JSON: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/IgpLrMRJJf" class="button is-primary">Run in the Go Playground</a></p><p>The <code>json.NewEncoder()</code> function creates a new <code>json.Encoder</code> object, which can write JSON-encoded data to the stream supplied as the first parameter. Here we pass <code>os.Stdout</code>, which is the <a href="https://en.wikipedia.org/wiki/Standard_streams">standard output stream</a> from the operating system shell. This creates a data transformation pipeline that looks conceptually like this:</p><p><img src="img/json-encoder.png" alt="json encoder data pipeline"></p><p>The output stream can be any writable stream. Here we use standard out, but in a <a href="../goweb/">web server</a> we will use the HTTP response stream to write encoded JSON back to the client.</p><p>The <code>.Encode()</code> method of the encoder does the actual JSON encoding and writing to the target stream. It will return an error if the data you are trying to encode can't be translated into legal JSON. For example, there are several values in Go that can't be represented in JSON: an infinite number, or the not-a-number (NaN) value. Go <a href="../goslicemap/#secmaps">maps</a> that use a key type other than <code>string</code> also can't be encoded into a JSON object, as JSON objects only support string keys.</p><p>The encoder will handle all sorts of data types, including maps, slices, and pointers to other structs. Be careful about circular references: the Go garbage collector can handle two struct instances that point to each other, but the JSON encoder will chase those pointers infinitely and hang your program!</p><p>The error checking code above also demonstrates a neat trick in Go that isn't common in other languages: the <code>if</code> statement can have an initializer expression, similar to the first expression in the <code>for</code> statement. The expression before the <code>;</code> is executed and then the condition after the <code>;</code> is evaluated to determine if the code inside the <code>if</code> block should be executed. This use an initializer for error checking is a common idiom in Go programming.</p><h2 id="secfieldsmustbeexportedtobeencoded">Fields Must be Exported to be Encoded</h2><p>One thing that trips up new Go developers is forgetting that the JSON encoder can only see, and therefore only encode, <strong>exported</strong> fields in a struct. Recall that Go uses the package boundary as its primary mechanism for encapsulation, and that <a href="../golang/#secpackagesandcodeorganization">only the identifiers that start with a capital letter are exported</a>. Since the JSON encoder is defined in the <code>json</code> package and not your <code>main</code> package, it can only see the fields in your struct that are exported from your package. Therefore, if you want a field encoded into JSON, it must be exported, so it must start with a capital letter.</p><p>When I first started learning Go, I spent several hours trying to figure out why a struct like this was being encoded as an empty JSON object even when the values were set correctly:</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> Rectangle <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    top    <span class="token builtin">int</span>
    left   <span class="token builtin">int</span>
    width  <span class="token builtin">int</span>
    height <span class="token builtin">int</span>
<span class="token punctuation">}</span></code></pre><p>See the difference? The fields are all lower-case, and therefore are not exported from the <code>main</code> package. You can pass this struct to the JSON encoder, but <a href="https://play.golang.org/p/M8E7sX6ukV">the result will always be an empty JSON object</a> because the code in the <code>json</code> package can't see those fields.</p><p>This is an easy trap to fall into because the <code>.Encode()</code> method <strong>won't return any sort of error</strong>. On the one hand this makes sense: unexported fields are private to the package, and therefore shouldn't be encoded into JSON, as those fields are probably used to track private implementation details. But on the other hand, it would lead to less frustrating mistakes if the encoder returned an error when there are <em>no exported fields at all</em>. That case is likely the result of a programming error.</p><p>But alas, that's the current behavior, so watch out for it.</p><h2 id="seccustomizingtheencoding">Customizing the Encoding</h2><p>Since fields must be exported to be encoded, and since exported field names must start with a capital letter, if you run the code above you'll notice that the output looks like this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"Top"</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token property">"Left"</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token property">"Width"</span><span class="token operator">:</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token property">"Height"</span><span class="token operator">:</span><span class="token number">40</span><span class="token punctuation">}</span></code></pre><p>Since the JSON keys are named the same as the struct fields, they all start with a capital letter. This is legal JSON, but it's counter to the JavaScript convention of using <code>camelCased</code> property names. Thankfully, Go allows us to customize the JSON encoding, including changing the names of the keys.</p><p>For example, say we want the JSON keys to be <code>top</code>, <code>left</code>, <code>width</code>, and <code>height</code>. We can add "tags" to the struct fields to provide these different key names:</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> Rectangle <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Top    <span class="token builtin">int</span> <span class="token string">`json:"top"`</span>
    Left   <span class="token builtin">int</span> <span class="token string">`json:"left"`</span>
    Width  <span class="token builtin">int</span> <span class="token string">`json:"width"`</span>
    Height <span class="token builtin">int</span> <span class="token string">`json:"height"`</span>
<span class="token punctuation">}</span></code></pre><p>Field tags are a generic mechanism for encoding extra meta-data about a field, and the JSON encoder uses this mechanism to let you override the key name in the generated JSON. Whatever name you put in the quotes after the <code>json:</code> label will be used both for encoding to and decoding from JSON. It can be a different casing than the struct field name, or something entirely different if you want to use a different name in JSON than in your Go struct.</p><p>The JSON encoder allows not only a custom name, but a few other options as well. For example, large structures may have many fields that are set to their zero-value, and therefore don't really need to be encoded into JSON. If you want a field <a href="https://play.golang.org/p/V9_ZX8sN4u">omitted when it is set to its zero-value</a>, use the <code>omitempty</code> option:</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> Rectangle <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Top    <span class="token builtin">int</span> <span class="token string">`json:"top,omitempty"`</span>
    Left   <span class="token builtin">int</span> <span class="token string">`json:"left,omitempty"`</span>
    Width  <span class="token builtin">int</span> <span class="token string">`json:"width,omitempty"`</span>
    Height <span class="token builtin">int</span> <span class="token string">`json:"height,omitempty"`</span>
<span class="token punctuation">}</span></code></pre><p>And if you want a field to be exported so that code in your other packages can see it, but <a href="https://play.golang.org/p/LgjBB1EtCV">never encoded into JSON</a>, you can set the name to <code>"-"</code>, which will always omit it from encoding:</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> Rectangle <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Top    <span class="token builtin">int</span>    <span class="token string">`json:"top,omitempty"`</span>
    Left   <span class="token builtin">int</span>    <span class="token string">`json:"left,omitempty"`</span>
    Width  <span class="token builtin">int</span>    <span class="token string">`json:"width,omitempty"`</span>
    Height <span class="token builtin">int</span>    <span class="token string">`json:"height,omitempty"`</span>
    Secret <span class="token builtin">string</span> <span class="token string">`json:"-"`</span> <span class="token comment" spellcheck="true">//will never be encoded</span>
<span class="token punctuation">}</span></code></pre><p>These tags can be laborious to add, so many of the editor/IDE extensions will generate them for you. In Visual Studio Code, put your cursor somewhere in the struct definition and then open the command palette using <code>Cmd+Shift+P</code> on Mac or <code>Ctrl+Shift+P</code> on Windows and Linux. Type <code>go: add tags</code> and select the command <code>go: Add Tags to Struct Fields</code>. Conversely you can use <code>go: remove tags</code> to remove all tags from a struct's fields.</p><h2 id="secmarshaling">Marshaling</h2><p>The <code>json.Encoder</code> object can write to any writable stream, but sometimes you need the encoded JSON in a variable so that you can manipulate it in memory, or pass it to some other non-stream-oriented function (e.g., a database API). In this case, use the <code>json.Marshal()</code> function:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//create an instance of a Rectangle</span>
r <span class="token operator">:=</span> Rectangle<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//marshal into JSON buffer</span>
buffer<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error marshaling JSON: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>The <code>json.Marshal()</code> function returns a byte slice (<code>[]byte</code>) and potentially an error. The byte slice is a memory buffer that you can iterate and manipulate, just like any other slice. Or you can pass the byte slice to some other function that takes a <code>[]byte</code> as a parameter.</p><h2 id="secdecoding">Decoding</h2><p>To decode JSON from a stream into a struct, the code is very similar to the encoding scenario:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//create an empty instance of a Rectangle</span>
<span class="token comment" spellcheck="true">//to receive the decoded JSON</span>
<span class="token comment" spellcheck="true">//note that r is a pointer to a Rectangle</span>
r <span class="token operator">:=</span> <span class="token operator">&amp;</span>Rectangle<span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//create a new decoder over stdin</span>
<span class="token comment" spellcheck="true">//and decode the JSON into the struct</span>
dec <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">NewDecoder</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">:=</span> dec<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error decoding JSON: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span></code></pre><p><a href="https://play.golang.org/p/HmU5_1zQ-z" class="button is-primary">Run in the Go Playground</a></p><p>This code will read a JSON string from the standard input stream supplied by the operating system shell, decode that into a new empty <code>*Rectangle</code>, and then just print the struct so you can see it. The Go Playground doesn't have a standard input stream, so the version there uses the <code>strings</code> package to create a readable stream over a simple string instead.</p><p>Note that the variable <code>r</code> is a pointer to a <code>Rectangle</code>, so when we pass that to the <code>.Decode()</code> method, we are passing a pointer, not a copy of the struct. This allows the method to set the fields of the same struct instance so that we can see those values after the method returns.</p><p>The JSON decoder will set the values of struct fields that are found in the input JSON, but it will silently ignore other keys that do not match a field in the target struct. This is good, as it allows you to use a struct definition to enforce a particular schema for the input JSON. If nefarious clients post extra JSON data to your web server, it will just be ignored instead of written unwittingly into your database.</p><h2 id="secunmarshaling">Unmarshaling</h2><p>Just as <code>Marshal()</code> encodes to a byte slice rather than a stream, <code>Unmarshal</code> decodes from a byte slice containing JSON.</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//create an empty instance of a Rectangle</span>
<span class="token comment" spellcheck="true">//to receive the decoded JSON</span>
r <span class="token operator">:=</span> <span class="token operator">&amp;</span>Rectangle<span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//unmarshal from a string that is converted to a byte slice</span>
s <span class="token operator">:=</span> <span class="token string">`{"top": 10, "left": 20, "width": 30, "height": 40}`</span>
buffer <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error unmarshaling JSON: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span></code></pre><p><a href="https://play.golang.org/p/YkEUyDOOW2" class="button is-primary">Run in the Go Playground</a></p><h2 id="secmoredetails">More Details</h2><p>For more details on Go's support for JSON, see the <a href="https://blog.golang.org/json-and-go">JSON and Go</a> article on the Go Blog. For a longer article on the virtue of stream-based interfaces in Go, see <a href="https://www.datadoghq.com/blog/crossing-streams-love-letter-gos-io-reader/">Crossing Streams: a love letter to Go io.Reader</a>.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>