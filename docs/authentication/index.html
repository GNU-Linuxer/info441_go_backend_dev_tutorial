<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../_lib/bulma.min.css"><link rel="stylesheet" href="../_lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../_lib/prism.css"><link rel="icon" href="../_img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Authenticating Users"><meta property="og:description" content="How to properly authenticate users against local names and passwords"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Authenticating Users</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Authenticating Users</h1><p class="subtitle">How to properly authenticate users against local names and passwords</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Aug 3, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>Now that you know how to <a href="../sessions/">track sessions across multiple HTTP requests</a>, it's time to discuss how we authenticate users at the start of authenticated sessions. <strong>Authentication</strong> is the process of establishing and verifying a user's identity; this is related by distinct from <strong>authorization</strong>, which is the process of verifying the user has permission to do what the user is trying to do.</p><p>In this tutorial I will explain how to properly authenticate a user against a name and password managed by our own system, which is known as <strong>local authentication</strong>. In a future tutorial I will show you how you can alternatively delegate this task to another web service, such as Google, Facebook, or Twitter, using the OAuth 2.0 protocol.</p><h2 id="secsigningup">Signing Up</h2><p>Local authentication involves two steps: the process of creating a new account (which we call <strong>sign-up</strong>); and the process of authenticating against an existing account (which we call <strong>sign-in</strong>).</p><p>When a user signs up for a new account on our system, the user provides two critical pieces of information:</p><ul><li>a <strong>unique name</strong> that identifies the account, which is often an email address, since those are already unique.</li><li>a <strong>secret that only the user knows</strong>, which we commonly refer to as a password, though it can be anything known only to the user.</li></ul><p>If the system manages especially sensitive information, or provides access to stored payment methods, we may also encourage (or even require) the user to establish a second authentication factor. This is typically something the user <em>has</em>, such as a mobile phone, USB device, or personal token generator. In highly-secure systems, a third factor based on something the user <em>is</em> may also be required, such as a biometric test.</p><h2 id="secstoringthepasswordproperly">Storing the Password Properly</h2><p>In order to authenticate the user during later sign-in attempts, we need to store these credentials in our persistent database. Your first instinct might be to just write the user name and password to the database in plain text, but you should <strong>never store passwords in plain text</strong>. If an attacker compromises your database, plain text passwords would give the attacker instant access to the user accounts not only in your system, but also many other systems, as people often reuse names and passwords across multiple sites.</p><p>Instead, the current best practice is to use an adaptive cryptographic hashing algorithm to hash new passwords with a random "salt" value, and store only the resulting hash in the database. These hashing algorithms have five important qualities:</p><ul><li><strong>Irreversible</strong>: Hashing algorithms are one-way operations, so it is impossible to directly calculate the input value from an output hash. This is in contrast to encryption, which can be reversed using the matching decryption algorithm and key.</li><li><strong>Deterministic</strong>: Hashing algorithms always produce the same output hash given the same input value. If you hash the same input value, it will match a previous hash of that same input value. This allows us to verify the user's password during a later sign-in attempt.</li><li><strong>Unique</strong>: Hashing algorithms are also unique: if you change just one bit of the input value, you will get a very different output hash. This allows us to know if the sign-in password is incorrect.</li><li><strong>Unguessable</strong>: A stolen output hash reveals no information that would help you guess what sort of input value created it. Although you can't reverse a hashing algorithm, the deterministic quality means that it is possible to hash many possible input values until the output hash matches some stolen hash. The unguessable property means that the list of possible values can't be narrowed down by examining the stolen hash, so the attacker is limited to a brute-force search over all possible values.</li><li><strong>Adaptive</strong>: Since brute-force attacks on stolen hashes are possible, password hashing algorithms allow us to control the speed at which the algorithm runs so that we can keep it relatively constant as hardware speeds increase. The goal is to keep the hashing algorithm fast enough that users won't notice the delay when signing up/in, but slow enough that a brute-force attack takes longer than the attacker's patience.</li></ul><p>If an attacker wants to crack a stolen password hash, the unguessable property forces the attacker to do a brute-force search over all possible values. But over the years, attackers have built up large databases of well-known passwords and their equivalent hashes using several different hashing algorithms. Sadly, these well-known passwords were revealed when <a href="https://arstechnica.com/tech-policy/2011/06/sony-hacked-yet-again-plaintext-passwords-posted/">several sites that stored passwords in plain text were hacked</a>. Even more sadly, developers continue to make sites that store passwords in plain text, even though they are <a href="http://plaintextoffenders.com/">eventually shamed for it</a>.</p><p>With these existing tables, an attacker could compare a stolen hash against the pre-calculated hashes, and if the attacker found a match, the attacker would know the plain text password that produced it (the deterministic quality).</p><p>To defeat these pre-calculated tables, we also add a unique, cryptographically-random value, known as the <strong>salt value</strong>, to each new password when we hash it. This salt value changes the input to the hashing function, which causes it to produce a very different output hash (the unique quality) than the one in the attacker's pre-computed table. Since the value is cryptographically-random, the attacker can't predict what that would be ahead of time.</p><p>Of course, this salt value must also be stored in the user's database record, or we wouldn't be able to verify the user's password later during a sign-in attempt. In order to generate the same hash as the one we stored, we must combine the user's password with the same salt value that was used when generating that stored hash. If one bit is different, the resulting hash will be different (the unique quality).</p><p>Since the salt value is stored in the database, attackers who comprise our database will know what it is, but remember that this value is unique per-password, so the attacker would have to hash every known password with this unique salt value in order to find a match. If our adaptive hashing speed is around one second, generating hashes for one million known passwords with just one unique salt value would take around one million seconds, or almost 12 days of non-stop hashing to crack just one stolen hash, and that's only if the original password was in the attacker's well-known password list. A strong password would require a much slower exhaustive brute-force attack, that could easily take many months or years. Unless the data attached to those user accounts was really worth it, most attackers would lose patience and abandon the attack.</p><p>For example, when <a href="https://arstechnica.com/information-technology/2015/08/cracking-all-hacked-ashley-madison-passwords-could-take-a-lifetime/">security researchers tried to crack the 36 million stolen Ashley Madison password hashes</a>, they were able to crack only 4,000 of them after 5 days of non-stop hashing. These were also very weak passwords that could have been guessed even without a sophisticated cracking attempt (e.g., "password). The site used the <a href="#secbcrypt">bcrypt algorithm</a>, but used a relatively low adaptive cost factor that allowed the researchers to hash 156 passwords a second. If that cost factor had slowed the algorithm down to 2 hashes a second, users wouldn't have noticed when signing-in, but it would have taken far longer to crack even those very weak passwords.</p><h2 id="secpasswordhashingalgorithms">Password Hashing Algorithms</h2><p>The most commonly-used password hashing algorithms are <a href="https://en.wikipedia.org/wiki/Bcrypt">bcrypt</a>, <a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>, <a href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a>, and <a href="https://en.wikipedia.org/wiki/Argon2">argon2</a>. The latter two are fairly new, so they have received far less field-testing, but they may become more standard in the future.</p><h3 id="secbcrypt">bcrypt</h3><p>The bcrypt algorithm is oldest, but that also means it's the most field-tested and well-understood. It has some vulnerabilities, but it is still highly-recommended because an easy-to-use but slightly-vulnerable algorithm is better than a less-vulnerable algorithm that doesn't get used due to its complexity. This is how you use bcrypt in Go:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>

    <span class="token string">"golang.org/x/crypto/bcrypt"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pwd <span class="token operator">:=</span> <span class="token string">"my secret password"</span>

    <span class="token comment" spellcheck="true">//automatically generates salt while hashing</span>
    <span class="token comment" spellcheck="true">//second parameter is the adaptive cost factor; increase to slow it down</span>
    <span class="token comment" spellcheck="true">//it wants the password as a byte slice, so convert using []byte()</span>
    hash<span class="token punctuation">,</span> err <span class="token operator">:=</span> bcrypt<span class="token punctuation">.</span><span class="token function">GenerateFromPassword</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error generating bcrypt hash: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//the resulting hash contains the salt and cost factor, </span>
    <span class="token comment" spellcheck="true">//so you only need to store this one value in your database</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//compare a password against this hash</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> bcrypt<span class="token punctuation">.</span><span class="token function">CompareHashAndPassword</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"password doesn't match stored hash!"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"password is valid"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>The bcrypt package for Go automatically generates a new salt value each time you call <code>GenerateFromPassword()</code> and stores that value as the first part of the returned hash, so you only need to store that one return value in your database. When the user supplies a password at sign-in, you use the <code>CompareHashAndPassword</code> function to compare it against your stored hash. If it returns an error, the password doesn't match the hash.</p><p>Like most cryptographic algorithms, bcrypt accepts byte slices as input, so string-based passwords must be converted to byte slices using <code>[]byte()</code>.</p><p>The cost factor can be increased to slow down the algorithm as hardware speeds increase. Each increase makes the algorithm exponentially slower, so be careful. You should use the highest value that still results in acceptable performance in your production system. Since the algorithm is run only during sign-up and sign-in, users should be OK waiting a half or even full second, especially if the information you are protecting is valuable.</p><h3 id="secpbkdf2">PBKDF2</h3><p>The PBKDF2 algorithm was originally designed to derive a symmetric encryption key from a password, and is commonly used when encrypting a file or entire disk based on a password. But it can also be used for password hashing, as it has all the same qualities listed above. The output encryption key can be stored as the password hash.</p><p>Here's what using the PBKDF2 algorithm looks like in Go:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"crypto/rand"</span>
    <span class="token string">"crypto/sha512"</span>
    <span class="token string">"crypto/subtle"</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>

    <span class="token string">"golang.org/x/crypto/pbkdf2"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pwd <span class="token operator">:=</span> <span class="token string">"my secret password"</span>
    iterations <span class="token operator">:=</span> <span class="token number">300000</span>

    <span class="token comment" spellcheck="true">//generate a salt value using the crypto/rand package</span>
    salt <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>
    <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> rand<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>salt<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"error generating salt: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
        os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//derive a PBKDf2 key from the password and salt</span>
    <span class="token comment" spellcheck="true">//use SHA-512 as the hashing function, and enough iterations</span>
    hash <span class="token operator">:=</span> pbkdf2<span class="token punctuation">.</span><span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token punctuation">,</span> salt<span class="token punctuation">,</span> iterations<span class="token punctuation">,</span> sha512<span class="token punctuation">.</span>Size<span class="token punctuation">,</span> sha512<span class="token punctuation">.</span>New<span class="token punctuation">)</span>

    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//store the hash, salt, and iterations values in your database...</span>

    <span class="token comment" spellcheck="true">//when comparing a password to the stored values,</span>
    <span class="token comment" spellcheck="true">//re-generate the key and compare</span>
    hash2 <span class="token operator">:=</span> pbkdf2<span class="token punctuation">.</span><span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token punctuation">,</span> salt<span class="token punctuation">,</span> iterations<span class="token punctuation">,</span> sha512<span class="token punctuation">.</span>Size<span class="token punctuation">,</span> sha512<span class="token punctuation">.</span>New<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//ConstantTimeCompare will compare every byte even if one</span>
    <span class="token comment" spellcheck="true">//doesn't match, so that an attacker can't do a timing attack</span>
    <span class="token comment" spellcheck="true">//to determine how much of the hash was correct</span>
    <span class="token keyword">if</span> subtle<span class="token punctuation">.</span><span class="token function">ConstantTimeCompare</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> hash2<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"password matches stored hash/salt"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"password doesn't match stored hash/salt"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>The Go PBKDF2 package has only one function: <code>Key()</code>, which derives an encryption key from a password, salt value, and number of iterations. That means you must generate your own salt value, and store that with the hash in your database, as you'll need to provide it when you re-hash the supplied password during sign-in. This salt value should be generated using the <code>crypto/rand</code> package, which is cryptographically-random, as opposed to the <code>math/rand</code> package, which is only pseudo-random.</p><p>Increasing the iterations will slow down the algorithm, and you should use the highest value that still results in acceptable performance in your production system.</p><h2 id="secsigningin">Signing In</h2><p>When an existing user attempts to sign-in, your web server should follow these steps:</p><ul><li>Fetch the user profile with the supplied user name from your persistent data store.</li><li>If you don't find a matching profile, spend the same amount of time doing something as you would have hashing the password, and then respond with an Unauthorized (401) status code, and a vague message like "invalid credentials".</li><li>If you find a matching profile, hash the supplied password using the same algorithm and parameters as you used when generating the password hash during sign-up.</li><li>Compare the two hashes: if they match, the password was correct and you should start a new authenticated session; if not, the password was invalid, and you should respond with an Unauthorized (401) status code, and the same vague message used when you can't find the user profile.</li></ul><p>The goal here is to authenticate the user while not giving any clues to an attacker about which part of the credentials were incorrect. If you return more specific errors like "user name not found" and "invalid password," an attacker with a valid user name but invalid password will be able to discover that half of the credentials are correct.</p><p>Attackers also watch how long it takes to get an error response: if the server responds right away, the attacker assumes the user name was not found, but if it takes a bit longer, the attacker assumes the user name was correct but the slower adaptive hashing algorithm discovered the password was incorrect. If you don't find the user profile, do something that takes the same amount of time as hashing a password so that the attacker can't see a timing difference.</p><h2 id="secfurtherreading">Further Reading</h2><p>Authentication is a complex and controversial subject, but these articles do a nice job explaining all of this in even more detail:</p><ul><li><a href="https://crackstation.net/hashing-security.htm">Salted Password Hashing—Doing it Right</a></li><li><a href="https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016">How to Safely Store Your Users' Passwords in 2016</a></li><li><a href="https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet">OWASP Password Storage Cheat Sheet</a></li><li><a href="https://cryptosense.com/parameter-choice-for-pbkdf2/">Parameter Choice for PBKDF2</a></li></ul></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>