<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.4.3/css/bulma.min.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/highlight/styles/default.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="The Go Language"><meta property="og:description" content="A brief introduction to the Go language and built-in types"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>The Go Language</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">The Go Language</h1><p class="subtitle">A brief introduction to the Go language and built-in types</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jul 10, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>Although Go is <a href="../gointro/">fully-compiled</a> like C and C++, its syntax and built-in types are more akin to higher-level languages like Python and JavaScript. This makes the language very approachable and functional right out of the box.</p><h2 id="seclanguagesyntax">Language Syntax</h2><p>The syntax of Go is based on the C family of languages, with a few contemporary upgrades, so Java and JavaScript developers will find most of it very familiar. Most of the contemporary upgrades are best described in context, but a few general differences should be noted at the outset.</p><p>First, Go eliminates the need to put semi-colons at the end of single-statement lines (hooray!). Semi-colons are still necessary to separate compound statements on the same line (e.g., a <code>for</code> loop with initializer, test, and step statements), but in all other cases you can omit them.</p><p>Second, Go eliminates the need for parentheses around various structures like <code>if</code> expressions and <code>for</code> loop statements. For example, <code>if</code> statements in most C-like languages look like this:</p><pre><code class="javascript language-javascript">if (x == 5) {
    //...
}</code></pre><p>but those parenthesis around the condition aren't really necessary for the parser, so Go eliminates them, resulting in a cleaner syntax like this;</p><pre><code class="go language-go">if x == 5 {
    //...
} </code></pre><p>Third, as opposed to JavaScript, string literals in Go are always expressed in double-quotes. Single quotes are only used for a single character, which Go refers to as a "rune." Go also allows you to wrap string literals in a back-tick symbol, which allows for multi-line strings that preserve embedded line breaks and tabs:</p><pre><code class="go language-go">"my string" //a string of UTF-8 characters
'x'         //a single UTF-8 character

`this is a
    multi-line string
with embedded line breaks and tabs`</code></pre><p>Go also defines a strict code style that is enforced by the <code>gofmt</code> tool. Most editor/IDE extensions will automatically run this tool on your source code whenever you save the file, and it will adjust your source code as needed. Go noobs are often taken-aback when this happens, but this is actually a good thing: it makes everyone's Go code consistent and easy-to-read. The good news is that if you use <code>gofmt</code>, you'll never loose points for sloppy code style!</p><h2 id="sechelloworldingo">Hello, World in Go</h2><p>When describing a new programming language, it's traditional to show what it takes to print "Hello, World!" to the screen. In Go, that program looks like this:</p><pre><code class="go language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}</code></pre><p>This rather simple program gives us a chance to learn some of the basic constructs of Go that you will use in every program.</p><h3 id="secpackagesandcodeorganization">Packages and Code Organization</h3><p>The first line is the package declaration. All Go source files are organized into packages, and the package name <code>main</code> is used for the source file containing your program's <code>main()</code> function. When your program is run, this <code>main()</code> function is invoked, so it serves as the entry point for the program.</p><p>You can put all of the code for a given program in the <code>main</code> package, but this quickly becomes unwieldy as your code base grows. Instead, most Go developers (affectionately known as "gophers") organize their code into packages with the same name as the subdirectory in which the code files exist. For example, a web server might use a code organization along these lines:</p><pre><code>$GOPATH/src/github.com/username/reponame
|--main.go (package main)
|--models/
|  |--user.go (package models)
|  |-- ... etc ...
|--handlers/
   |--users.go (package handlers)
   |-- ... etc ...</code></pre><p>For details on the organization of the <code>$GOPATH/src</code> directory, see the <a href="../gointro/#secstructureofthesrcsubdirectory">Introduction to Go Tutorial</a>.</p><p>Packages are also Go's main encapsulation mechanism. All functions, global variables, and structure fields within a package are accessible by all other code in that same package, but code in other packages can only access exported functions, globals, and fields. This allows us to write reusable libraries that protect their data while providing a public API to other packages.</p><p>Interestingly, Go doesn't include an <code>export</code> keyword for exporting things from a package. Instead, it uses the convention that all identifiers that start with a capital letter are exported, and all that start with a lower-case letter are not. This may seem strangely arbitrary at first, but since the exported/unexported nature of the identifier is encoded into its name, it does make it easy to determine if an identifier is exported or not when you are debugging a code block that someone else wrote (or that you wrote a long time ago).</p><p>These subtleties show that Go was a language designed by people who have spent decades writing production software. Go's creators set out to design a language that would make it easier to not only build, but also maintain large, complex, long-lived software systems.</p><h3 id="secimportingotherpackages">Importing Other Packages</h3><p>The next line of our hello world program demonstrates how one imports code from other packages:</p><pre><code class="go language-go">import "fmt"</code></pre><p>This line imports <a href="https://golang.org/pkg/fmt/">the <code>fmt</code> package</a> from the Go standard library, which exports several functions for writing formatted output. The package name becomes a prefix for all functions exported by the package, so calling one of those functions looks like this:</p><pre><code class="go language-go">fmt.Println("Hello, World!")</code></pre><p>Syntactically, it looks like <code>fmt</code> is an object that has a method named <code>Println</code>, but <code>Println</code> is really just an exported function in the <code>fmt</code> package. Using the package as a prefix allows different packages to export functions of the same name, while still allowing the importing code to delineate between them.</p><p>When importing packages from the standard library, you only need to list the package name after the <code>import</code> keyword, but when importing your own packages, or those defined in other reusable libraries, you need to use a path to the source code that is relative to the <code>$GOPATH/src</code> directory. For example, to import the <code>handlers</code> package shown in the directory listing above, your import statement would look like this:</p><pre><code class="go language-go">import "github.com/username/reponame/handlers"</code></pre><p>Importing multiple package is typically done using this parenthetical syntax:</p><pre><code class="go language-go">import (
    "fmt"
    "os"
    "log"
)</code></pre><p>If you use one of the excellent editor/IDE extension for Go, you generally don't need to type these import statements: as soon as you type a line like <code>fmt.Println()</code> the extension will call the <code>goimports</code> tool (or similar) to automatically maintain the imports list based on the code you've written.</p><h3 id="secfunctions">Functions</h3><p>As noted earlier, the main entry point for all Go programs is the <code>main()</code> function in the <code>main</code> package. Declaring this function looks like this:</p><pre><code class="go language-go">func main() {
    //function body
}</code></pre><p>This function has no arguments, and no return value, so it's pretty simple to declare. The <code>func</code> keyword starts a function declaration, the function name follows, and inside the parenthesis are the parameters. To declare a function that takes a single string parameter, the syntax looks like this:</p><pre><code class="go language-go">func sayHello(name string) {
    fmt.Printf("Hello %s!\n", name)
}</code></pre><p>Note how the data type <code>string</code> <em>follows</em> the parameter name rather than proceeding it. This is becoming common in newer languages such as Go and Swift. If you have multiple parameters of the same type, you can omit the type on all but the last one:</p><pre><code class="go language-go">func sayHello(title, name string) {
    fmt.Printf("Hello %s %s!\n", title, name)
}</code></pre><p>If your function returns a value, you must also declare what type it returns. Just like the parameters, the return type of a function <em>follows</em> the function declaration rather than proceeding it:</p><pre><code class="go language-go">func getGreeting(title, name string) string {
    return fmt.Sprintf("Hello %s %s!", title, name)
}</code></pre><p>One of the nice features of Go is that we can also return <em>multiple</em> values from a single function, and this is commonly used for error handling. When returning multiple values, wrap the return type list in parentheses.</p><pre><code class="go language-go">//getGretting returns a greeting for a name, or an error
//if `name` is zero-length
func getGreeting(title, name string) (string, error) {
    if len(name) == 0 {
        return "", fmt.Errorf("the 'name' parameter is required")
    }
    return fmt.Sprintf("Hello %s %s!", title, name), nil
}</code></pre><p>Unlike Java and JavaScript, Go doesn't support exceptions with <code>try/catch</code> handling. Instead, any function that might generate an error returns that error as the last return value. If an error occurs, it returns it, but if no error occurs, it returns <code>nil</code> for the error (similar to <code>null</code> in other languages). The calling function then checks whether the returned error is non-nil, and handles the error accordingly. For example:</p><pre><code class="go language-go">greeting, err := getGreeting("Mr", "Anderson")
if err != nil {
    //handle error
}</code></pre><h2 id="secvariables">Variables</h2><p>Variables in Go are statically typed, and may not change their type over time. They are formally declared like so:</p><pre><code class="go language-go">//declares a string variable named `name` initialized to "Anderson" 
var name string = "Anderson"</code></pre><p>Just like the parameters above, note that the type <em>follows</em> the variable name.</p><p>This longer form is rarely used, because the Go compiler can work out from the initializing expression that <code>name</code> is a string, and the keyword <code>var</code> is not strictly necessary for the parser to recognize that this is a variable declaration. So Go offers this much more compact syntax for declaring and initializing variables:</p><pre><code class="go language-go">//treated the same as above
name := "Anderson"</code></pre><p>The <code>:=</code> operator declares and initializes the variable in one step. If you don't have an initial value, then you must use the more formal syntax shown earlier.</p><p>You can declare and initialize multiple variables in the same statement, which is exactly what we did earlier when we declared variables to hold he results of the <code>getGreeting()</code> function.</p><pre><code class="go language-go">//declare and initialize both `title` and `name`
title, name := "Mr", "Anderson"

//pass them to getGreeting() and 
//declare/init `greeting` and `err` with the results
greeting, err := getGreeting(title, name)</code></pre><p>Variables are block-scoped in Go, just as they are in Java: variables declared within a block are visible only within that block. When combined with Go's <code>if</code> statement initializers, this comes in handy when checking for errors:</p><pre><code class="go language-go">if err := doSomethingThatCouldFail(); err != nil {
    //the `err` variable is visible only within this if block
}</code></pre><p>The expression before the <code>;</code> is executed, and the result is assigned to a new variable named <code>err</code>. The expression after the <code>;</code> then checks if that variable is non-nil, and if so, the <code>if</code> block body is executed. That <code>err</code> variable is visible only within the <code>if</code> block, and as soon as it exits, the variable is marked for garbage collection.</p><h2 id="secothersimpletypes">Other Simple Types</h2><p>In addition to strings, Go offers several other simple types:</p><ul><li><code>bool</code>: true/false booleans</li><li><code>int</code> and <code>uint</code>: implementation-dependent signed and unsigned integers (64 or 32 bits depending on the target architecture)</li><li><code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, and the unsigned equivalents: specific-sized signed and unsigned integers</li><li><code>float32</code> and <code>float64</code>: 32 and 64-bit floating point numbers</li><li><code>complex64</code> and <code>complex128</code>: complex numbers containing both the real and imaginary parts</li><li><code>byte</code>: an alias for <code>uint8</code></li><li><code>rune</code>: an alias for <code>int32</code></li></ul><p>When working with large volumes of data in memory, consider whether you really need 64 bits to hold your values, or whether you could get away with 32, 16, or even 8 bits per number. If so, you will significantly reduce the amount of memory consumed by using <code>int32</code>, <code>int16</code>, <code>int8</code> rather than <code>int</code>.</p><h2 id="secstructs">Structs</h2><p>Many times we want to combine a set of variables together into a single unit so that we can work with them together. In object-oriented languages, we define a class and include the variables as data members. Although Go has some features that quasi-object-oriented, there are no classes like there are in Java. But we can define a simple struct instead:</p><pre><code class="go language-go">type Rectangle struct {
    Top int
    Left int
    Width int
    Height int
}</code></pre><p>This declares a new type with the name <code>rectangle</code>, which is a structure containing the four fields described in the body of the declaration. After we declare this type, we can then create instances of this struct and access the fields:</p><pre><code class="go language-go">//construct a Rectangle
//fields are initialized in the order
//they are declared
r := Rectangle{10, 20, 30, 40}

//directly access the fields
fmt.Printf("area is %d\n", r.Width*r.Height)</code></pre><p>Since <code>Rectangle</code> is now a type, we can declare function parameters to be that type, and the Go compiler will ensure that only a <code>Rectangle</code> instance can be passed to that parameter:</p><pre><code class="go language-go">func area(r Rectangle) int {
    return r.Width * r.Height
}

func main() {
    r := Rectangle{10, 20, 30, 40}
    fmt.Printf("area is %d\n", area(r))
}</code></pre><h2 id="secpointers">Pointers</h2><p>In the <code>area()</code> example above, the <code>Rectangle</code> instance is actually passed by value, meaning that the four integers are copied in memory as the <code>Rectangle</code> is passed to the function. Although that's generally fine for simple types like integers and strings (which are immutable), copying larger structs can result in a unnecessary memory allocation and copying.</p><p>In Go we can pass any type by reference by using pointers, which are simple integers that represent the address in memory where the actual value lies. For example, we can adjust the <code>area()</code> function to accept <em>a pointer to</em> a <code>Rectangle</code> rather than <em>a copy of</em> a <code>Rectangle</code>, and pass the address of our <code>Rectangle</code> instance to the function:</p><pre><code class="go language-go">func area(r *Rectangle) int {
    return r.Width * r.Height
}

func main() {
    r := Rectangle{10, 20, 30, 40}
    fmt.Printf("area is %d\n", area(&amp;r))
}</code></pre><p>The pointer to a type is expressed as <code>*T</code> where <code>T</code> is the name of the type. The <code>&amp;</code> operator takes the address of the variable to the right, and in this case, that address is passed to the <code>area()</code> function. Note that code inside that function didn't have to change: Go will let you use <code>.</code> to access the fields of a struct, even if the value on the left is a pointer to a struct instead of a struct value.</p><p>Since the data type of <code>r</code> in the code above is <code>Rectangle</code> and not <code>*Rectangle</code>, we have to use the <code>&amp;</code> operator to get a pointer to it. But we can declare and initialize <code>r</code> to a <code>*Rectangle</code> from the start by using the <code>&amp;</code> operator in the initialization expression:</p><pre><code class="go language-go">func area(r *Rectangle) int {
    return r.Width * r.Height
}

func main() {
    r := &amp;Rectangle{10, 20, 30, 40}
    fmt.Printf("area is %d\n", area(r))
}</code></pre><p>This code creates a <code>Rectangle</code> struct, but then takes the address of it and assigns that to <code>r</code>, making that variable's type a <code>*Rectangle</code>. We can then pass that directly to <code>area()</code> without having to take the address of it first.</p><h2 id="secreceivers">Receivers</h2><p>The <code>area()</code> function above accepts a <code>*Rectangle</code> as a parameter, but in object-oriented languages, we would commonly make this a method of the <code>Rectangle</code> class so that you can call it using an expression like <code>r.area()</code>. In Go, we can do something similar, but since there are no classes, we use a slightly different mechanism called a "receiver" parameter:</p><pre><code class="go language-go">//the parameter just moves to the left
//of the function name and becomes a
//"receiver", which allows us to call
//it using the syntax `r.area()`
func (r *Rectangle) area() int {
    return r.Width * r.Height
}

func main() {
    r := &amp;Rectangle{10, 20, 30, 40}
    fmt.Printf("area is %d\n", r.area())
}</code></pre><p>A receiver is just like a parameter, except that it is declared on the left side of the function name. You can give the receiver parameter whatever name you want, but we typically use something short like the first letter of the receiver's data type. You then use that name in the function's code, just like any other parameter. In the example above, I literally just moved the parameter declaration to the left and the function body remained unchanged.</p><p>The main benefit of using a receiver is syntax-sugar on the calling side: you can now call this function using the syntax <code>r.area()</code> rather than <code>area(r)</code>. The former feels more like an object-oriented method. In truth, the compiler just turns <code>r</code> into a special parameter passed to the function <code>area</code>, so the compiled code will be almost identical. But receivers do become very handy when working with functions that must conform to a particular signature, such as Go's HTTP handler functions (more on those later).</p><p>If you've ever wondered how the magic <code>this</code> keyword works in Java, it is essentially a receiver. There are no such things as "classes" in a computer. Object-oriented programming is an abstraction over what the computer really supports: blocks of memory that can either hold data or instructions that operate on those data.</p><h2 id="seccommentsanddocumentation">Comments and Documentation</h2><p>As you declare new structs and functions, it's a good idea to provide some documentation explaining what they are and what they do. Go uses a mechanism that is similar to JavaDoc and JSDoc, but much simpler:</p><pre><code class="go language-go">//Rectangle represents a Rectangle
type Rectangle struct {
    Top int
    Left int
    Width int
    Height int
}

//area returns the area of the Rectangle on which it is called
func (r *Rectangle) area() int {
    return r.Width * r.Height
}</code></pre><p>Comments added above a function declaration are used as a description of the function in the generated documentation. By convention, your comment should start with the name of the function or struct.</p><p>In IDEs like Visual Studio Code, these descriptions are shown in the various tips regarding those types.</p><h2 id="secthetour">The Tour</h2><p>To learn more about the Go language, complete their <a href="https://tour.golang.org/welcome/1">interactive tour</a>. This walks you through the language features, step-by-step, while allowing you to experiment in their sand-boxed <a href="https://play.golang.org/">Go Playground</a>.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href="..">table of contents</a></p></div></div></footer><script src="../lib/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad()</script><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>