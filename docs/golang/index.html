<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="The Go Language"><meta property="og:description" content="A brief introduction to the Go language and built-in types"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>The Go Language</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">The Go Language</h1><p class="subtitle">A brief introduction to the Go language and built-in types</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jul 12, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>Although Go is <a href="../gointro/">fully-compiled</a> like C and C++, its syntax and built-in types are more akin to higher-level languages like Python and JavaScript. This makes the language very approachable and functional right out of the box.</p><h2 id="seclanguagesyntax">Language Syntax</h2><p>The syntax of Go is based on the C family of languages, with a few contemporary upgrades, so Java and JavaScript developers will find most of it very familiar. Most of the contemporary upgrades are best described in context, but a few general differences should be noted at the outset.</p><p>First, Go eliminates the need to put semi-colons at the end of single-statement lines! Semi-colons are still necessary to separate compound statements on the same line (e.g., a <code>for</code> loop with initializer, test, and step expressions), but in all other cases you can omit them.</p><p>Second, Go eliminates the need for parentheses around various structures like <code>if</code> and <code>for</code> expressions. For example, <code>if</code> statements in most C-like languages look like this:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span></code></pre><p>but those parenthesis around the condition aren't really necessary for the parser, so Go eliminates them, resulting in a cleaner syntax like this;</p><pre class="language-go"><code class="language-go"><span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">5</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span> </code></pre><p>Third, as opposed to JavaScript, string literals in Go are always expressed in double-quotes. Single quotes are only used for a single character, which Go refers to as a "rune." Go also allows you to wrap string literals in a back-tick symbol, which allows for multi-line strings that preserve embedded line breaks and tabs:</p><pre class="language-go"><code class="language-go"><span class="token string">"my string"</span> <span class="token comment" spellcheck="true">//a string of UTF-8 characters</span>
<span class="token string">'x'</span>         <span class="token comment" spellcheck="true">//a single UTF-8 character</span>

<span class="token string">`this is a
    multi-line string
with embedded line breaks and tabs`</span></code></pre><p>Go defines a strict code style that is enforced by the <code>gofmt</code> tool. Most editor/IDE extensions will automatically run this tool on your source code whenever you save the file, and it will adjust your source code as needed. Go noobs are often taken-aback when this happens, but this is actually a good thing: it makes everyone's Go code consistent and easy-to-read. The good news is that if you use <code>gofmt</code>, you'll never loose points for sloppy code style!</p><h2 id="sechelloworldingo">Hello World in Go</h2><p>When describing a new programming language, it's traditional to show what it takes to print "Hello, World!" to the screen. In Go, that program looks like this:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/1UzYk90llO"><span class="button is-primary">Run in the Go Playground</span></a></p><p>This rather simple program gives us a chance to learn some of the basic constructs of Go that you will use in every program.</p><h3 id="secpackagesandcodeorganization">Packages and Code Organization</h3><p>The first line is the package declaration. All Go source files are organized into packages, and the package name <code>main</code> is used for the source file containing your program's <code>main()</code> function. When your program runs, this <code>main()</code> function is invoked, so it serves as the entry point for the program.</p><p>You can put all of the code for a given program in the <code>main</code> package, but this quickly becomes unwieldy as your code base grows. Instead, most Go developers (affectionately known as "<a href="https://blog.golang.org/gopher">gophers</a>") organize their code into packages with the same name as the subdirectory in which the code files exist. For example, a web server might use a code organization along these lines:</p><pre><code class="nohighlight language-nohighlight">$GOPATH/src/github.com/username/reponame
├── handlers
│   └── users.go (package handlers)
├── models
│   └── user.go  (package models)
└── main.go      (package main)</code></pre><p>For details on the organization of the <code>$GOPATH/src</code> directory, including what <code>username</code> and <code>reponame</code> should be replaced with, see the <a href="../gointro/#secstructureofthesrcsubdirectory">Introduction to Go Tutorial</a>.</p><p>Packages are also Go's main encapsulation mechanism. All functions, global variables, and structure fields within a package are accessible by all other code in that same package, but code in other packages can only access exported functions, globals, and fields. This allows us to write reusable libraries that protect their data while providing a public API to other packages.</p><p>Interestingly, Go doesn't include an <code>export</code> keyword for exporting things from a package. Instead, it uses a simple convention: all identifiers that start with a capital letter are exported, and all that start with a lower-case letter are not. This may seem strangely arbitrary at first, but since the exported/unexported nature of the identifier is encoded into its name, it does make it easy to determine if an identifier is exported or not when you are debugging a block of code that someone else wrote (or that you wrote a long time ago).</p><p>These subtleties show that Go was a language designed by people who have spent decades writing production software. Go's creators set out to design a language that would make it easier to not only build, but also <em>maintain</em> large, complex, long-lived software systems.</p><h3 id="secimportingotherpackages">Importing Other Packages</h3><p>The next line of our hello world program demonstrates how one imports code from other packages:</p><pre class="language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"fmt"</span></code></pre><p>This line imports <a href="https://golang.org/pkg/fmt/">the <code>fmt</code> package</a> from the Go standard library, which exports several functions for writing formatted output. The package name becomes a prefix for all functions exported by the package, so calling one of those functions looks like this:</p><pre class="language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span></code></pre><p>Syntactically, it looks like <code>fmt</code> is an object that has a method named <code>Println</code>, but <code>Println</code> is really just an exported function in the <code>fmt</code> package. Using the package as a prefix allows different packages to export functions of the same name, while still allowing the importing code to distinguish them.</p><p>When importing packages from the standard library, you only need to list the package name after the <code>import</code> keyword, but when importing your own packages, or those defined in other reusable libraries, you need to use a path to the source code that is relative to the <code>$GOPATH/src</code> directory. For example, to import the <code>handlers</code> package shown in the directory listing above, your import statement would look like this:</p><pre class="language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"github.com/username/reponame/handlers"</span></code></pre><p>Importing multiple package is typically done using this parenthetical syntax:</p><pre class="language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"os"</span>
    <span class="token string">"log"</span>
<span class="token punctuation">)</span></code></pre><p>If you use one of the excellent editor/IDE extension for Go, you generally don't need to type these import statements: as soon as you type a line like <code>fmt.Println()</code> the extension will call the <code>goimports</code> tool (or similar) to automatically maintain the imports list based on the code you've written.</p><h3 id="secfunctions">Functions</h3><p>As noted earlier, the main entry point for all Go programs is the <code>main()</code> function in the <code>main</code> package. Declaring this function looks like this:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//function body</span>
<span class="token punctuation">}</span></code></pre><p>This function has no arguments, and no return value, so it's pretty simple to declare. The <code>func</code> keyword starts a function declaration, the function name follows, and inside the parenthesis are the parameters. To declare a function that takes a single string parameter, the syntax looks like this:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Hello %s!\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>Note how the data type <code>string</code> <em>follows</em> the parameter name rather than proceeding it. This is <a href="https://golang.org/doc/faq#declarations_backwards">becoming common</a> in newer languages such as Go and Swift (for more details on why Go does this, see their <a href="https://blog.golang.org/gos-declaration-syntax">Go Declaration Syntax</a> article). If you have multiple parameters of the same type, you can omit the type on all but the last one:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Hello %s %s!\n"</span><span class="token punctuation">,</span> title<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>If your function returns a value, you must also declare what type it returns. Just like the parameters, the return type of a function <em>follows</em> the function declaration rather than proceeding it:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">getGreeting</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"Hello %s %s!"</span><span class="token punctuation">,</span> title<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>One of the nice features of Go is that we can also <a href="https://golang.org/doc/effective_go.html#multiple-returns">return <em>multiple</em> values</a> from a single function, and this is commonly used for error handling. When returning multiple values, wrap the return type list in parentheses.</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//getGretting returns a greeting for a name, or an error</span>
<span class="token comment" spellcheck="true">//if `name` is zero-length</span>
<span class="token keyword">func</span> <span class="token function">getGreeting</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"the 'name' parameter is required"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"Hello %s %s!"</span><span class="token punctuation">,</span> title<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span></code></pre><p>Unlike Java and JavaScript, <a href="https://golang.org/doc/faq#exceptions">Go doesn't support exceptions</a> with <code>try/catch</code> handling. Instead, any function that might generate an error returns that error as the last return value. If an error occurs, the error is returned, but if no error occurs, the function returns <code>nil</code> for the error (similar to <code>null</code> in other languages). The calling function then checks whether the returned error is non-nil, and handles the error accordingly. For example:</p><pre class="language-go"><code class="language-go">greeting<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">getGreeting</span><span class="token punctuation">(</span><span class="token string">"Mr"</span><span class="token punctuation">,</span> <span class="token string">"Anderson"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//handle error</span>
<span class="token punctuation">}</span></code></pre><h2 id="secvariables">Variables</h2><p>Variables in Go are statically typed, and may not change their type over time. They are formally declared like so:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//declares a string variable named `name` initialized to "Anderson" </span>
<span class="token keyword">var</span> name <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"Anderson"</span></code></pre><p>Just like the parameters above, note that the type <em>follows</em> the variable name.</p><p>This longer form is rarely used, because the Go compiler can work out from the initializing expression that <code>name</code> is a string, and the keyword <code>var</code> is not strictly necessary for the parser to recognize that this is a variable declaration. So Go offers this much more compact syntax for declaring and initializing variables in one step:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//treated the same as above</span>
name <span class="token operator">:=</span> <span class="token string">"Anderson"</span></code></pre><p>You can declare and initialize multiple variables in the same statement, which is exactly what we did earlier when we declared variables to hold he results of the <code>getGreeting()</code> function.</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//declare and initialize both `title` and `name`</span>
title<span class="token punctuation">,</span> name <span class="token operator">:=</span> <span class="token string">"Mr"</span><span class="token punctuation">,</span> <span class="token string">"Anderson"</span>

<span class="token comment" spellcheck="true">//pass them to getGreeting() and </span>
<span class="token comment" spellcheck="true">//declare/init `greeting` and `err` with the results</span>
greeting<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">getGreeting</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> name<span class="token punctuation">)</span></code></pre><p>Variables are block-scoped in Go, just as they are in Java: variables declared within a block are visible only within that block. When combined with Go's <code>if</code> statement initializers, this comes in handy when checking for errors:</p><pre class="language-go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">doSomethingThatCouldFail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//the `err` variable is visible only within this if block</span>
<span class="token punctuation">}</span></code></pre><p>In the code above, the expression before the <code>;</code> is executed, and the result is assigned to a new variable named <code>err</code>. The expression after the <code>;</code> then checks if that variable is non-nil, and if so, the <code>if</code> block body is executed. That <code>err</code> variable is visible only within the <code>if</code> block, and as soon as it exits, the variable falls out of scope and is eventually gargage collected.</p><h2 id="secsimpletypes">Simple Types</h2><p>Go offers the usual set of simple types:</p><ul><li><code>string</code>: an <a href="https://en.wikipedia.org/wiki/Immutable_object">immutable</a> array of <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8 encoded characters</a></li><li><code>bool</code>: true/false booleans</li><li><code>int</code> and <code>uint</code>: implementation-dependent signed and unsigned integers (64 or 32 bits depending on the target architecture)</li><li><code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, and the unsigned equivalents <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>: specific-sized signed and unsigned integers</li><li><code>float32</code> and <code>float64</code>: 32 and 64-bit floating point numbers</li><li><code>complex64</code> and <code>complex128</code>: complex numbers containing both the real and imaginary parts</li><li><code>byte</code>: an alias for <code>uint8</code></li><li><code>rune</code>: an alias for <code>int32</code>, and is used for UTF-8 encoded characters</li></ul><p>Note that Go strings are <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8 encoded</a>, which means that individual characters may be anywhere between one and four bytes long depending on their Unicode number.s UTF-8 encoding can save significant space if most of your characters are in the ASCII range, but the variable byte length makes working with strings a bit precarious. For example, if you use a typical <code>for</code> loop to iterate over a string, you are actually iterating over the <em>bytes</em> in the string buffer, not necessarily the characters:</p><pre class="language-go"><code class="language-go">s <span class="token operator">:=</span> <span class="token string">"Hello, 世界"</span>

<span class="token comment" spellcheck="true">//ANTI-PATTERN: this will iterate over the bytes</span>
<span class="token comment" spellcheck="true">//not the characters, producing bad results</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d = %s\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/TRy7QA8c6E"><span class="button is-primary">Run in the Go Playground</span></a></p><p>Thankfully Go provides several ways to interact with the characters in a string, regardless of how many bytes they occupy. The first uses their <code>for...range</code> looping construct, which works over not only strings, but also <a href="../goslicemap/">slices and maps</a>:</p><pre class="language-go"><code class="language-go">s <span class="token operator">:=</span> <span class="token string">"Hello, 世界"</span>

<span class="token comment" spellcheck="true">//CORRECT: loops over characters, not bytes</span>
<span class="token comment" spellcheck="true">//r will be set to a complete "rune" (UTF-8 char)</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> r <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d = %c\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/22Dsr64dTp"><span class="button is-primary">Run in the Go Playground</span></a></p><p>The second option is to convert the string to a slice of runes and iterate over that:</p><pre class="language-go"><code class="language-go">s <span class="token operator">:=</span> <span class="token string">"Hello, 世界"</span>

<span class="token comment" spellcheck="true">//CORRECT: convert to slice of runes </span>
<span class="token comment" spellcheck="true">//and iterate over the runes</span>
runes <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>runes<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d = %c\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> runes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/jCqcXeHrch"><span class="button is-primary">Run in the Go Playground</span></a></p><p>Lastly, the <a href="https://golang.org/pkg/unicode/utf8/">utf8</a> package in the standard library provides several functions for reading and extracting characters from UTF-8 encoded strings. These can be useful when you only need the first character from a string and you need to know how many bytes that character occupies.</p><h2 id="secstructs">Structs</h2><p>Many times we want to combine a set of variables into a single unit so that we can work with them together. In object-oriented languages, we define a class and include the variables as data members. Although Go has some features that quasi-object-oriented, there are no classes like there are in Java. But we can define a simple struct instead:</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> Rectangle <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Top <span class="token builtin">int</span>
    Left <span class="token builtin">int</span>
    Width <span class="token builtin">int</span>
    Height <span class="token builtin">int</span>
<span class="token punctuation">}</span></code></pre><p>This declares a new type with the name <code>rectangle</code>, which is a structure containing the four fields described in the body of the declaration. After we declare this type, we can then create instances of this struct and access the fields:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//construct a Rectangle</span>
<span class="token comment" spellcheck="true">//the fields are initialized in the order</span>
<span class="token comment" spellcheck="true">//they are declared</span>
r <span class="token operator">:=</span> Rectangle<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//directly access the fields</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"area is %d\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Width<span class="token operator">*</span>r<span class="token punctuation">.</span>Height<span class="token punctuation">)</span></code></pre><p>The syntax <code>Rectangle{}</code> is known as a static initializer. If you supply only a list of values, the struct fields are initialized with those values in the order in which they are declared (i.e., the first value goes into the <code>Top</code> fields, the second into the <code>Left</code> field, and so on). If you want to be more explicit, or use a different order, you can also name the fields as you initialize them, similar to a JavaScript object declaration:</p><pre class="language-go"><code class="language-go">r <span class="token operator">:=</span> Rectangle<span class="token punctuation">{</span>
    Width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span> 
    Height<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">,</span>
    Top<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> 
    Left<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span> 
<span class="token punctuation">}</span></code></pre><p>Note that when you spread the values onto separate lines, Go syntax requires a comma after <em>every</em> value <em>including the last one</em>. This is different than JavaScript, but it's actually a good thing, as it makes it much easier to add a new value to the end of the list when you add a new field to the struct. Since every line gets a comma on the end, you don't need to alter the current last line to add another one after it.</p><p>When initializing a struct, if you omit one of the fields the value for that field will be set to the "zero value" for the field's data type:</p><table class="table is-striped"><thead><tr><th>data type</th><th>zero value</th></tr></thead><tbody><tr><td>any number type</td><td><code>0</code></td></tr><tr><td>string</td><td><code>""</code> (zero-length string)</td></tr><tr><td>bool</td><td><code>false</code></td></tr><tr><td>any pointer type</td><td><code>nil</code></td></tr></tbody></table><p>Since <code>Rectangle</code> is now a type, we can declare function parameters to be that type, and the Go compiler will ensure that only a <code>Rectangle</code> instance can be passed to that parameter:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Area</span><span class="token punctuation">(</span>r Rectangle<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> r<span class="token punctuation">.</span>Width <span class="token operator">*</span> r<span class="token punctuation">.</span>Height
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    r <span class="token operator">:=</span> Rectangle<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"area is %d\n"</span><span class="token punctuation">,</span> <span class="token function">Area</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><h2 id="secpointers">Pointers</h2><p>In the <code>Area()</code> function above, the <code>Rectangle</code> instance is actually passed by value, meaning that the four integers are copied in memory as the <code>Rectangle</code> is passed to the function. Although that's generally fine for simple types like single integers and immutable strings, copying larger structs can result in unnecessary memory allocations and copying.</p><p>In Go we can pass any type by reference by using pointers, which are simple integers that represent the address in memory where the actual value lies. For example, we can adjust the <code>Area()</code> function to accept <em>a pointer to</em> a <code>Rectangle</code> rather than <em>a copy of</em> a <code>Rectangle</code>, and pass the address of our <code>Rectangle</code> instance to the function:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Area</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Rectangle<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> r<span class="token punctuation">.</span>Width <span class="token operator">*</span> r<span class="token punctuation">.</span>Height
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    r <span class="token operator">:=</span> Rectangle<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"area is %d\n"</span><span class="token punctuation">,</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>Now when we call the <code>Area()</code> function, we are passing only one 64-bit number rather than four of them. When passing by reference, the function may also make changes to the struct that are visible in the calling code when the function returns.</p><p>The pointer to a type is expressed syntactically as <code>*T</code> where <code>T</code> is the name of the type. The <code>&amp;</code> operator takes the address of the variable to the right, and in this case, that address is passed to the <code>Area()</code> function. Note that code inside that function didn't have to change: Go will let you use <code>.</code> to access the fields of a struct, even if the value on the left is a pointer to the struct instead of the struct value. This is in contrast to C/C++ where you have to use a different operator with pointers.</p><p>Since the data type of <code>r</code> in the code above is <code>Rectangle</code> and not <code>*Rectangle</code>, we have to use the <code>&amp;</code> operator to get a pointer to the <code>Rectangle</code> value assigned to the <code>r</code> variable. But we can instead declare and initialize <code>r</code> to a <code>*Rectangle</code> from the start by using the <code>&amp;</code> operator in the initialization expression:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Area</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Rectangle<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> r<span class="token punctuation">.</span>Width <span class="token operator">*</span> r<span class="token punctuation">.</span>Height
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    r <span class="token operator">:=</span> <span class="token operator">&amp;</span>Rectangle<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"area is %d\n"</span><span class="token punctuation">,</span> <span class="token function">Area</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>This code creates a <code>Rectangle</code> struct, but then takes the address of it and assigns that address to <code>r</code>, making that variable's type a <code>*Rectangle</code>. We can then pass that directly to <code>Area()</code>.</p><h2 id="secreceivers">Receivers</h2><p>The adjusted <code>Area()</code> function above accepts a <code>*Rectangle</code> as a parameter, but in object-oriented languages, we would commonly make this a method of the <code>Rectangle</code> class so that you can call it using an expression like <code>r.Area()</code>. In Go, we can do something similar, but since there are no classes, we use a slightly different mechanism called a "receiver" parameter:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//the parameter just moves to the left</span>
<span class="token comment" spellcheck="true">//of the function name and becomes a</span>
<span class="token comment" spellcheck="true">//"receiver", which allows us to call</span>
<span class="token comment" spellcheck="true">//the function using the syntax `r.Area()`</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Rectangle<span class="token punctuation">)</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> r<span class="token punctuation">.</span>Width <span class="token operator">*</span> r<span class="token punctuation">.</span>Height
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    r <span class="token operator">:=</span> <span class="token operator">&amp;</span>Rectangle<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"area is %d\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span><span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://play.golang.org/p/oz6HshrnkB"><span class="button is-primary">Run in the Go Playground</span></a></p><p>A receiver is just like a parameter, except that it is declared on the left side of the function name. You can give the receiver parameter whatever name you want, but we typically use something short like the first letter of the receiver's data type. You then use that name in the function's code, just like any other parameter. In the example above, I literally just moved the parameter declaration to the left, while the function body remained unchanged.</p><p>The main benefit of using a receiver is syntax-sugar on the calling side: you can now call this function using the syntax <code>r.Area()</code> rather than <code>Area(r)</code>. The former feels more like an object-oriented method. In truth, the compiler just turns this into <code>Area(r)</code>, so the compiled code will be pretty much the same. But receivers do become very handy when working with functions that must conform to a particular parameter signature, such as Go's HTTP handler functions (more on those later).</p><p>If this all sounds weird, it really isn't. Have you ever wondered how the magic <code>this</code> keyword works in Java? Go's receivers are just a more explicit form of what happens with Java's <code>this</code> keyword under the hood. When you invoke something like <code>r.Area()</code> in Java, it must bind the <code>this</code> keyword to the object instance assigned to <code>r</code>, and then call the <code>Area()</code> function. That's the same thing as passing the object instance as a special parameter that you don't see in your source code, but is nevertheless there on the call stack. Go just makes this hidden parameter explicit, and allows you to give it whatever name you want. To drive this home, we can rename the receiver parameter to <code>this</code> and you'll probably start to see the resemblance to object-oriented languages like Java:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//receivers are just a more explicit form of `this`</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>Rectangle<span class="token punctuation">)</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> this<span class="token punctuation">.</span>Width <span class="token operator">*</span> this<span class="token punctuation">.</span>Height
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    r <span class="token operator">:=</span> <span class="token operator">&amp;</span>Rectangle<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"area is %d\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span><span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>You won't commonly see Go programmers using <code>this</code> for receiver names, as it implies that Go is more object-oriented than it really is, but it is legal since <code>this</code> is not (yet) a keyword in the language.</p><h2 id="seccommentsanddocumentation">Comments and Documentation</h2><p>Comments in Go are the same as in all other C-like languages: <code>//</code> makes everything following to the end of the current line a comment, and <code>/* */</code> allows for multi-line comments. But like Java and other more recent languages, comments before types and functions are used by the <code>godoc</code> tool to generate documentation automatically. Unlike <a href="http://www.oracle.com/technetwork/articles/java/index-137868.html">Javadoc</a> or <a href="http://usejsdoc.org/about-tutorials.html">JSDoc</a>, the format used in Go is very simple and uncomplicated:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Rectangle represents a Rectangle.</span>
<span class="token keyword">type</span> Rectangle <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Top <span class="token builtin">int</span>
    Left <span class="token builtin">int</span>
    Width <span class="token builtin">int</span>
    Height <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//Area returns the area of the Rectangle on which it is called.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Rectangle<span class="token punctuation">)</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> r<span class="token punctuation">.</span>Width <span class="token operator">*</span> r<span class="token punctuation">.</span>Height
<span class="token punctuation">}</span></code></pre><p>By convention, your comment should start with the name of the function or struct, and then form a full sentence that describes what the struct represents, or what the function does. The field/parameter names and types are extracted automatically from the code. If you want to explain more about a struct field, add a comment above the field. If you want to explain more about a function parameter, just refer to it by name in the comment above the function.</p><p>In IDEs like Visual Studio Code, this documentation is automatically loaded as you add it, and shown whenever you refer to the struct or function.</p><h2 id="seckeeplearning">Keep Learning</h2><p>To learn more about the Go language, complete their <a href="https://tour.golang.org/welcome/1">interactive tour</a>. This walks you through the language features, step-by-step, while allowing you to experiment in their sand-boxed <a href="https://play.golang.org/">Go Playground</a>.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href="..">table of contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>