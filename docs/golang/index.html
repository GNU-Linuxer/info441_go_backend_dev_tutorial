<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.4.3/css/bulma.min.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="The Go Language"><meta property="og:description" content="A brief introduction to the Go language and built-in types"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>The Go Language</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">The Go Language</h1><p class="subtitle">A brief introduction to the Go language and built-in types</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jul 10, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>Although Go is <a href="../gointro/">fully-compiled</a> like C and C++, its syntax and built-in types are more akin to higher-level languages like Python and JavaScript. This makes the language very approachable and functional right out of the box.</p><h2 id="seclanguagesyntax">Language Syntax</h2><p>The syntax of Go is based on the C family of languages, with a few contemporary upgrades, so Java and JavaScript developers will find most of it very familiar. Most of the contemporary upgrades are best described in context, but a few general differences should be noted at the outset.</p><p>First, Go eliminates the need to put semi-colons at the end of single-statement lines (ðŸŽ‰!). Semi-colons are still necessary to separate compound statements on the same line (e.g., a <code>for</code> loop with initializer, test, and step expressions), but in all other cases you can omit them.</p><p>Second, Go eliminates the need for parentheses around various structures like <code>if</code> and <code>for</code> expressions. For example, <code>if</code> statements in most C-like languages look like this:</p><pre><code class="javascript language-javascript">if (x == 5) {
    //...
}</code></pre><p>but those parenthesis around the condition aren't really necessary for the parser, so Go eliminates them, resulting in a cleaner syntax like this;</p><pre><code class="go language-go">if x == 5 {
    //...
} </code></pre><p>Third, as opposed to JavaScript, string literals in Go are always expressed in double-quotes. Single quotes are only used for a single character, which Go refers to as a "rune." Go also allows you to wrap string literals in a back-tick symbol, which allows for multi-line strings that preserve embedded line breaks and tabs:</p><pre><code class="go language-go">"my string" //a string of UTF-8 characters
'x'         //a single UTF-8 character

`this is a
    multi-line string
with embedded line breaks and tabs`</code></pre><p>Go defines a strict code style that is enforced by the <code>gofmt</code> tool. Most editor/IDE extensions will automatically run this tool on your source code whenever you save the file, and it will adjust your source code as needed. Go noobs are often taken-aback when this happens, but this is actually a good thing: it makes everyone's Go code consistent and easy-to-read. The good news is that if you use <code>gofmt</code>, you'll never loose points for sloppy code style!</p><h2 id="sechelloworldingo">Hello World in Go</h2><p>When describing a new programming language, it's traditional to show what it takes to print "Hello, World!" to the screen. In Go, that program looks like this:</p><pre><code class="go language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}</code></pre><p>This rather simple program gives us a chance to learn some of the basic constructs of Go that you will use in every program.</p><h3 id="secpackagesandcodeorganization">Packages and Code Organization</h3><p>The first line is the package declaration. All Go source files are organized into packages, and the package name <code>main</code> is used for the source file containing your program's <code>main()</code> function. When your program runs, this <code>main()</code> function is invoked, so it serves as the entry point for the program.</p><p>You can put all of the code for a given program in the <code>main</code> package, but this quickly becomes unwieldy as your code base grows. Instead, most Go developers (affectionately known as "<a href="https://blog.golang.org/gopher">gophers</a>") organize their code into packages with the same name as the subdirectory in which the code files exist. For example, a web server might use a code organization along these lines:</p><pre><code class="nohighlight language-nohighlight">$GOPATH/src/github.com/username/reponame
â”œâ”€â”€ handlers
â”‚   â””â”€â”€ users.go (package handlers)
â”œâ”€â”€ models
â”‚   â””â”€â”€ user.go  (package models)
â””â”€â”€ main.go      (package main)</code></pre><p>For details on the organization of the <code>$GOPATH/src</code> directory, including what <code>username</code> and <code>reponame</code> should be replaced with, see the <a href="../gointro/#secstructureofthesrcsubdirectory">Introduction to Go Tutorial</a>.</p><p>Packages are also Go's main encapsulation mechanism. All functions, global variables, and structure fields within a package are accessible by all other code in that same package, but code in other packages can only access exported functions, globals, and fields. This allows us to write reusable libraries that protect their data while providing a public API to other packages.</p><p>Interestingly, Go doesn't include an <code>export</code> keyword for exporting things from a package. Instead, it uses a simple convention: all identifiers that start with a capital letter are exported, and all that start with a lower-case letter are not. This may seem strangely arbitrary at first, but since the exported/unexported nature of the identifier is encoded into its name, it does make it easy to determine if an identifier is exported or not when you are debugging a block of code that someone else wrote (or that you wrote a long time ago).</p><p>These subtleties show that Go was a language designed by people who have spent decades writing production software. Go's creators set out to design a language that would make it easier to not only build, but also <em>maintain</em> large, complex, long-lived software systems.</p><h3 id="secimportingotherpackages">Importing Other Packages</h3><p>The next line of our hello world program demonstrates how one imports code from other packages:</p><pre><code class="go language-go">import "fmt"</code></pre><p>This line imports <a href="https://golang.org/pkg/fmt/">the <code>fmt</code> package</a> from the Go standard library, which exports several functions for writing formatted output. The package name becomes a prefix for all functions exported by the package, so calling one of those functions looks like this:</p><pre><code class="go language-go">fmt.Println("Hello, World!")</code></pre><p>Syntactically, it looks like <code>fmt</code> is an object that has a method named <code>Println</code>, but <code>Println</code> is really just an exported function in the <code>fmt</code> package. Using the package as a prefix allows different packages to export functions of the same name, while still allowing the importing code to distinguish them.</p><p>When importing packages from the standard library, you only need to list the package name after the <code>import</code> keyword, but when importing your own packages, or those defined in other reusable libraries, you need to use a path to the source code that is relative to the <code>$GOPATH/src</code> directory. For example, to import the <code>handlers</code> package shown in the directory listing above, your import statement would look like this:</p><pre><code class="go language-go">import "github.com/username/reponame/handlers"</code></pre><p>Importing multiple package is typically done using this parenthetical syntax:</p><pre><code class="go language-go">import (
    "fmt"
    "os"
    "log"
)</code></pre><p>If you use one of the excellent editor/IDE extension for Go, you generally don't need to type these import statements: as soon as you type a line like <code>fmt.Println()</code> the extension will call the <code>goimports</code> tool (or similar) to automatically maintain the imports list based on the code you've written.</p><h3 id="secfunctions">Functions</h3><p>As noted earlier, the main entry point for all Go programs is the <code>main()</code> function in the <code>main</code> package. Declaring this function looks like this:</p><pre><code class="go language-go">func main() {
    //function body
}</code></pre><p>This function has no arguments, and no return value, so it's pretty simple to declare. The <code>func</code> keyword starts a function declaration, the function name follows, and inside the parenthesis are the parameters. To declare a function that takes a single string parameter, the syntax looks like this:</p><pre><code class="go language-go">func sayHello(name string) {
    fmt.Printf("Hello %s!\n", name)
}</code></pre><p>Note how the data type <code>string</code> <em>follows</em> the parameter name rather than proceeding it. This is <a href="https://golang.org/doc/faq#declarations_backwards">becoming common</a> in newer languages such as Go and Swift (for more details on why Go does this, see their <a href="https://blog.golang.org/gos-declaration-syntax">Go Declaration Syntax</a> article). If you have multiple parameters of the same type, you can omit the type on all but the last one:</p><pre><code class="go language-go">func sayHello(title, name string) {
    fmt.Printf("Hello %s %s!\n", title, name)
}</code></pre><p>If your function returns a value, you must also declare what type it returns. Just like the parameters, the return type of a function <em>follows</em> the function declaration rather than proceeding it:</p><pre><code class="go language-go">func getGreeting(title, name string) string {
    return fmt.Sprintf("Hello %s %s!", title, name)
}</code></pre><p>One of the nice features of Go is that we can also <a href="https://golang.org/doc/effective_go.html#multiple-returns">return <em>multiple</em> values</a> from a single function, and this is commonly used for error handling. When returning multiple values, wrap the return type list in parentheses.</p><pre><code class="go language-go">//getGretting returns a greeting for a name, or an error
//if `name` is zero-length
func getGreeting(title, name string) (string, error) {
    if len(name) == 0 {
        return "", fmt.Errorf("the 'name' parameter is required")
    }
    return fmt.Sprintf("Hello %s %s!", title, name), nil
}</code></pre><p>Unlike Java and JavaScript, <a href="https://golang.org/doc/faq#exceptions">Go doesn't support exceptions</a> with <code>try/catch</code> handling. Instead, any function that might generate an error returns that error as the last return value. If an error occurs, the error is returned, but if no error occurs, the function returns <code>nil</code> for the error (similar to <code>null</code> in other languages). The calling function then checks whether the returned error is non-nil, and handles the error accordingly. For example:</p><pre><code class="go language-go">greeting, err := getGreeting("Mr", "Anderson")
if err != nil {
    //handle error
}</code></pre><h2 id="secvariables">Variables</h2><p>Variables in Go are statically typed, and may not change their type over time. They are formally declared like so:</p><pre><code class="go language-go">//declares a string variable named `name` initialized to "Anderson" 
var name string = "Anderson"</code></pre><p>Just like the parameters above, note that the type <em>follows</em> the variable name.</p><p>This longer form is rarely used, because the Go compiler can work out from the initializing expression that <code>name</code> is a string, and the keyword <code>var</code> is not strictly necessary for the parser to recognize that this is a variable declaration. So Go offers this much more compact syntax for declaring and initializing variables in one step:</p><pre><code class="go language-go">//treated the same as above
name := "Anderson"</code></pre><p>You can declare and initialize multiple variables in the same statement, which is exactly what we did earlier when we declared variables to hold he results of the <code>getGreeting()</code> function.</p><pre><code class="go language-go">//declare and initialize both `title` and `name`
title, name := "Mr", "Anderson"

//pass them to getGreeting() and 
//declare/init `greeting` and `err` with the results
greeting, err := getGreeting(title, name)</code></pre><p>Variables are block-scoped in Go, just as they are in Java: variables declared within a block are visible only within that block. When combined with Go's <code>if</code> statement initializers, this comes in handy when checking for errors:</p><pre><code class="go language-go">if err := doSomethingThatCouldFail(); err != nil {
    //the `err` variable is visible only within this if block
}</code></pre><p>In the code above, the expression before the <code>;</code> is executed, and the result is assigned to a new variable named <code>err</code>. The expression after the <code>;</code> then checks if that variable is non-nil, and if so, the <code>if</code> block body is executed. That <code>err</code> variable is visible only within the <code>if</code> block, and as soon as it exits, the variable falls out of scope and is eventually gargage collected.</p><h2 id="secothersimpletypes">Other Simple Types</h2><p>In addition to strings, Go offers several other simple types:</p><ul><li><code>bool</code>: true/false booleans</li><li><code>int</code> and <code>uint</code>: implementation-dependent signed and unsigned integers (64 or 32 bits depending on the target architecture)</li><li><code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, and the unsigned equivalents <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>: specific-sized signed and unsigned integers</li><li><code>float32</code> and <code>float64</code>: 32 and 64-bit floating point numbers</li><li><code>complex64</code> and <code>complex128</code>: complex numbers containing both the real and imaginary parts</li><li><code>byte</code>: an alias for <code>uint8</code></li><li><code>rune</code>: an alias for <code>int32</code></li></ul><p>When working with large amounts of data in memory, consider whether you really need 64 bits to hold your numeric values, or whether you could get away with 32, 16, or even 8 bits per number. If so, you will significantly reduce the amount of memory consumed by using <code>int32</code>, <code>int16</code>, <code>int8</code> rather than <code>int</code>.</p><h2 id="secstructs">Structs</h2><p>Many times we want to combine a set of variables into a single unit so that we can work with them together. In object-oriented languages, we define a class and include the variables as data members. Although Go has some features that quasi-object-oriented, there are no classes like there are in Java. But we can define a simple struct instead:</p><pre><code class="go language-go">type Rectangle struct {
    Top int
    Left int
    Width int
    Height int
}</code></pre><p>This declares a new type with the name <code>rectangle</code>, which is a structure containing the four fields described in the body of the declaration. After we declare this type, we can then create instances of this struct and access the fields:</p><pre><code class="go language-go">//construct a Rectangle
//the fields are initialized in the order
//they are declared
r := Rectangle{10, 20, 30, 40}

//directly access the fields
fmt.Printf("area is %d\n", r.Width*r.Height)</code></pre><p>The syntax <code>Rectangle{}</code> is known as a static initializer. If you supply only a list of values, the struct fields are initialized with those values in the order in which they are declared (i.e., the first value goes into the <code>Top</code> fields, the second into the <code>Left</code> field, and so on). If you want to be more explicit, or use a different order, you can also name the fields as you initialize them, similar to a JavaScript object declaration:</p><pre><code class="go language-go">r := Rectangle{
    Width: 30, 
    Height: 40,
    Top: 10, 
    Left: 20, 
}</code></pre><p>Note that when you spread the values onto separate lines, Go syntax requires a comma after <em>every</em> value <em>including the last one</em>. This is different than JavaScript, but it's actually a good thing, as it makes it much easier to add a new value to the end of the list when you add a new field to the struct. Since every line gets a comma on the end, you don't need to alter the current last line to add another one after it.</p><p>Since <code>Rectangle</code> is now a type, we can declare function parameters to be that type, and the Go compiler will ensure that only a <code>Rectangle</code> instance can be passed to that parameter:</p><pre><code class="go language-go">func Area(r Rectangle) int {
    return r.Width * r.Height
}

func main() {
    r := Rectangle{10, 20, 30, 40}
    fmt.Printf("area is %d\n", Area(r))
}</code></pre><h2 id="secpointers">Pointers</h2><p>In the <code>Area()</code> function above, the <code>Rectangle</code> instance is actually passed by value, meaning that the four integers are copied in memory as the <code>Rectangle</code> is passed to the function. Although that's generally fine for simple types like single integers and immutable strings, copying larger structs can result in unnecessary memory allocations and copying.</p><p>In Go we can pass any type by reference by using pointers, which are simple integers that represent the address in memory where the actual value lies. For example, we can adjust the <code>Area()</code> function to accept <em>a pointer to</em> a <code>Rectangle</code> rather than <em>a copy of</em> a <code>Rectangle</code>, and pass the address of our <code>Rectangle</code> instance to the function:</p><pre><code class="go language-go">func Area(r *Rectangle) int {
    return r.Width * r.Height
}

func main() {
    r := Rectangle{10, 20, 30, 40}
    fmt.Printf("area is %d\n", Area(&amp;r))
}</code></pre><p>Now when we call the <code>Area()</code> function, we are passing only one 64-bit number rather than four of them. When passing by reference, the function may also make changes to the struct that are visible in the calling code when the function returns.</p><p>The pointer to a type is expressed syntactically as <code>*T</code> where <code>T</code> is the name of the type. The <code>&amp;</code> operator takes the address of the variable to the right, and in this case, that address is passed to the <code>Area()</code> function. Note that code inside that function didn't have to change: Go will let you use <code>.</code> to access the fields of a struct, even if the value on the left is a pointer to the struct instead of the struct value. This is in contrast to C/C++ where you have to use a different operator with pointers.</p><p>Since the data type of <code>r</code> in the code above is <code>Rectangle</code> and not <code>*Rectangle</code>, we have to use the <code>&amp;</code> operator to get a pointer to the <code>Rectangle</code> value assigned to the <code>r</code> variable. But we can instead declare and initialize <code>r</code> to a <code>*Rectangle</code> from the start by using the <code>&amp;</code> operator in the initialization expression:</p><pre><code class="go language-go">func Area(r *Rectangle) int {
    return r.Width * r.Height
}

func main() {
    r := &amp;Rectangle{10, 20, 30, 40}
    fmt.Printf("area is %d\n", Area(r))
}</code></pre><p>This code creates a <code>Rectangle</code> struct, but then takes the address of it and assigns that address to <code>r</code>, making that variable's type a <code>*Rectangle</code>. We can then pass that directly to <code>Area()</code>.</p><h2 id="secreceivers">Receivers</h2><p>The adjusted <code>Area()</code> function above accepts a <code>*Rectangle</code> as a parameter, but in object-oriented languages, we would commonly make this a method of the <code>Rectangle</code> class so that you can call it using an expression like <code>r.Area()</code>. In Go, we can do something similar, but since there are no classes, we use a slightly different mechanism called a "receiver" parameter:</p><pre><code class="go language-go">//the parameter just moves to the left
//of the function name and becomes a
//"receiver", which allows us to call
//the function using the syntax `r.Area()`
func (r *Rectangle) Area() int {
    return r.Width * r.Height
}

func main() {
    r := &amp;Rectangle{10, 20, 30, 40}
    fmt.Printf("area is %d\n", r.Area())
}</code></pre><p>A receiver is just like a parameter, except that it is declared on the left side of the function name. You can give the receiver parameter whatever name you want, but we typically use something short like the first letter of the receiver's data type. You then use that name in the function's code, just like any other parameter. In the example above, I literally just moved the parameter declaration to the left, while the function body remained unchanged.</p><p>The main benefit of using a receiver is syntax-sugar on the calling side: you can now call this function using the syntax <code>r.Area()</code> rather than <code>Area(r)</code>. The former feels more like an object-oriented method. In truth, the compiler just turns this into <code>Area(r)</code>, so the compiled code will be pretty much the same. But receivers do become very handy when working with functions that must conform to a particular parameter signature, such as Go's HTTP handler functions (more on those later).</p><p>If this all sounds weird, it really isn't. Have you ever wondered how the magic <code>this</code> keyword works in Java? Go's receivers are just a more explicit form of what happens with Java's <code>this</code> keyword under the hood. When you invoke something like <code>r.Area()</code> in Java, it must bind the <code>this</code> keyword to the object instance assigned to <code>r</code>, and then call the <code>Area()</code> function. That's the same thing as passing the object instance as a special parameter that you don't see in your source code, but is nevertheless there on the call stack. Go just makes this hidden parameter explicit, and allows you to give it whatever name you want. To drive this home, we can rename the receiver parameter to <code>this</code> and you'll probably start to see the resemblance to object-oriented languages like Java:</p><pre><code class="go language-go">//receivers are just a more explicit form of `this`
func (this *Rectangle) Area() int {
    return this.Width * this.Height
}

func main() {
    r := &amp;Rectangle{10, 20, 30, 40}
    fmt.Printf("area is %d\n", r.Area())
}</code></pre><p>You won't commonly see Go programmers using <code>this</code> for receiver names, as it implies that Go is more object-oriented than it really is, but it is legal since <code>this</code> is not (yet) a keyword in the language.</p><h2 id="seccommentsanddocumentation">Comments and Documentation</h2><p>Comments in Go are the same as in all other C-like languages: <code>//</code> makes everything following to the end of the current line a comment, and <code>/* */</code> allows for multi-line comments. But like Java and other more recent languages, comments before types and functions are used by the <code>godoc</code> tool to generate documentation automatically. Unlike <a href="http://www.oracle.com/technetwork/articles/java/index-137868.html">Javadoc</a> or <a href="http://usejsdoc.org/about-tutorials.html">JSDoc</a>, the format used in Go is very simple and uncomplicated:</p><pre><code class="go language-go">//Rectangle represents a Rectangle.
type Rectangle struct {
    Top int
    Left int
    Width int
    Height int
}

//Area returns the area of the Rectangle on which it is called.
func (r *Rectangle) Area() int {
    return r.Width * r.Height
}</code></pre><p>By convention, your comment should start with the name of the function or struct, and then form a full sentence that describes what the struct represents, or what the function does. The field/parameter names and types are extracted automatically from the code. If you want to explain more about a struct field, add a comment above the field. If you want to explain more about a function parameter, just refer to it by name in the comment above the function.</p><p>In IDEs like Visual Studio Code, this documentation is automatically loaded as you add it, and shown whenever you refer to the struct or function.</p><h2 id="seckeeplearning">Keep Learning</h2><p>To learn more about the Go language, complete their <a href="https://tour.golang.org/welcome/1">interactive tour</a>. This walks you through the language features, step-by-step, while allowing you to experiment in their sand-boxed <a href="https://play.golang.org/">Go Playground</a>.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href="..">table of contents</a></p></div></div></footer><script src="../lib/prism.js"></script><script>Prism.plugins.customClass.map({number:"prism-number"});var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var n=document.createElement("a");n.textContent="#",n.href="#"+e.id,n.classList.add("bookmark-link"),e.appendChild(n)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>