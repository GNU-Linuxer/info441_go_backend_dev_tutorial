<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Automated Testing in Go"><meta property="og:description" content="A brief introduction to automated testing and how to do it in Go"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Automated Testing in Go</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Automated Testing in Go</h1><p class="subtitle">A brief introduction to automated testing and how to do it in Go</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Aug 5, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>Anyone can learn to hack together an information system that works for one version, but building a system that continues to run reliably over many releases and years requires learning not only a good architecture, but also the discipline of automated testing. In fact, the thing that separates professional from amateur developers the most is a commitment to writing automated tests for their features.</p><p>As your project grows in size and complexity, a suite of automated tests will help you ensure that small bug fixes or changes made for new features don't break your existing functionality. If your tests are complete (i.e., they exercise all of your code paths by test both success and failure cases), you can make changes and release new versions with confidence.</p><p>If you do it right, your test code will actually be longer than your feature code. For example, <a href="https://www.sqlite.org/testing.html">the SQLite library has 730 times more automated test code than feature code</a>. They can fix bugs or make changes to their most core code yet know within a few minutes that the features their users depend upon are still functioning as expected. Before releasing a new version, they run all of their tests on multiple platforms, with multiple build configurations. Doing all that testing manually would be unthinkable.</p><h2 id="secwhatareautomatedtests">What are Automated Tests?</h2><p>An automated test is just another program that calls your feature code, passing various kinds of inputs, and testing the outputs to ensure they are what you expect them to be. These programs should test both valid and invalid inputs, and if possible, trigger unusual error conditions to ensure that the feature code handles them properly.</p><p>Ideally, your tests should invoke every line of your feature code at some point. The percentage of lines invoked is known as your <strong>code coverage</strong>, and it should be as high as possible. In some cases you can achieve 100%, but in others there will be code paths that are run only when very unexpected errors occur that your tests can't fabricate.</p><p>You can write automated tests in any language, but some languages offer specialized tools or environments for writing and running these tests. For example, Go defines a way to write automated tests that are automatically excluded from your compiled executable, but can be run at development time using their <code>go test</code> tool. This tool also provides <a href="https://blog.golang.org/cover">code coverage analysis</a>, showing you exactly which lines were exercised by your tests, and which were not. In the Node.js ecosystem, the tool <a href="https://mochajs.org/">mocha.js</a> is often used to run tests.</p><h2 id="seclevelsoftesting">Levels of Testing</h2><p>We can write automated tests at several levels: individual functions or classes in isolation; groups of integrated components; or entire systems running like they will in production.</p><h3 id="secunittests">Unit Tests</h3><p>The most common automated tests are those that test functions or classes in isolation. These are known as <strong>unit tests</strong>, as they are testing just one unit of the system at a time. These tests should be as exhaustive as possible, and cover all code paths.</p><p>These tests are often written in a data-driven style: you define multiple sets of input parameters and expected outputs, and then iteratively test each input/output pair. As you discover new possible input combinations, you just add those to the list, and the testing code automatically tests them. See <a href="#secwritingtestsingo">below</a> for an example of this in Go.</p><h3 id="secintegrationtests">Integration Tests</h3><p>Once you know that your system units are working in isolation, you then can test how they behave when they are integrated with other units into a sub-system. This is also where you test how your own units interact with code written by other people: for example, reusable libraries, database management systems, or the operating system. These are known as <strong>integration tests</strong>, as you are testing how your code units integrate with other code.</p><p>Integration tests are less about exhaustively testing input and outputs, and more about testing how units interact through a transaction flow. For example, a code module you write to manage user accounts in a DMBS (a user store) will expose several functions, and you will test those functions in isolation in your unit tests, but in your integration tests you will ensure that the functions work correctly together in a typical Create/Read/Update/Delete (CRUD) cycle. Your integration test would do the following:</p><ul><li>create a new record</li><li>read the record and ensure it was saved correctly</li><li>update the record</li><li>read it again to make sure it was actually updated</li><li>delete it</li><li>ensure that you can no longer read it</li></ul><p>Integration tests verify the dependencies <em>between</em> units, and thus can reveal errors that the unit tests miss. For example, if you added local caching to your user store to increase performance, but forgot to invalidate or patch the cache entry when the user record is updated, your integration test will catch it while your unit tests probably won't.</p><p>To run a test like this, your will naturally have to talk to the DBMS, but in many languages you can create a <em>mock implementation</em> of the DBMS so that your tests are easier to run. A mock implements the same interface as the DBMS client library, but uses a simple in-memory data store instead of talking to the actual database server. When using a mock, developers don't need to have the DBMS running locally in order to run the tests, and your tests aren't affected by data that might already be in the DBMS. Mocks also make it easier to trigger unusual runtime errors that might be impossible to trigger when using the actual DBMS, so they can help you achieve a higher code coverage ratio.</p><h3 id="secsystemtests">System Tests</h3><p>Both unit and integration tests focus on one piece of your system at a time, but <strong>system tests</strong> are meant to test your entire system in a context similar to production. For example, a unit test for a web server handler function would just invoke the function directly, but a system test for a web server would actually start the server and it's dependencies (ephemeral and persistent DBMSs, message queues, etc.), and then send real HTTP requests to the server, evaluating the HTTP responses.</p><p>System tests can uncover problems that would occur only in a production environment. For example, a system test could uncover issues that occur if the network socket is closed before the entire request body is received, or while the response is being written.</p><p>System tests can also verify system-level features, such as automatically restarting a microservice instance when it fails, automatically failing-over to a backup system when the primary system goes down.</p><h3 id="secstresstests">Stress Tests</h3><p>The final type of automated tests to mention are <strong>stress tests</strong>. These are a bit different than the previous types of tests as they are not really about testing features, <em>per se</em>. Instead they are about testing how your system behaves under stressful conditions, such as a very high transaction load. Stress tests will determine how much your system can handle, and at what point it will fail without more resources.</p><p>Stress tests require a bit more in terms of test infrastructure. In order to mimic a high transaction load on a web server, you really need to have dozens of clients all making multiple requests to the server at the same time. Each client measures how long each request took to process, and the server monitors things like request queue size, CPU/memory usage, and DBMS query duration.</p><p>One you build a stress test infrastructure, you can run several tests with different system configurations and actually measure the results to see which configuration gives you the scalability you need for the least cost. Without this, you can only guess and hope.</p><h2 id="secwritingtestsingo">Writing Tests in Go</h2><p>Now that you know the distinctions between automated tests, let's see how we write unit tests in Go. Follow along in your own code editor. Start by creating a new directory within your <code>$GOPATH/src/</code> directory, and creating a file named <code>reverse.go</code> within that directory. Then copy this function into it:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token comment" spellcheck="true">//Reverse returns the reverse of the string passed as `s`</span>
<span class="token keyword">func</span> <span class="token function">Reverse</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//convert string to a slice so we can manipulate it</span>
    <span class="token comment" spellcheck="true">//since strings are immutable, this creates a copy of</span>
    <span class="token comment" spellcheck="true">//the string so we won't be modifying the original</span>
    chars <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//starting from each end, swap the values in the slice</span>
    <span class="token comment" spellcheck="true">//elements, stopping when we get to the middle</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token number">-1</span> <span class="token punctuation">{</span>
        chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//return the reversed slice as a string</span>
    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>If you were paying attention during the <a href="../golang/#secsimpletypes">Go language tutorial</a>, you'll probably spot a bug in the code above. If not, don't worry: our automated tests will soon uncover it.</p><p>Create another file named <code>reverse_test.go</code> in the same directory. Go treats files that end with <code>_test</code> as automated test files, so it won't compile these into your built executable, but it will run the tests within them when you invoke the <code>go test</code> tool.</p><p>Since we are writing a unit test for our <code>Reverse()</code> function, we will make the test data-driven. We will specify several pairs of input strings and expected output strings, and test each case to make sure we get what we expect. The cases should include not only common cases, but also unexpected ones such as an empty string for the input.</p><p>Add this code to your <code>reverse_test.go</code> file:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"testing"</span>

<span class="token keyword">func</span> <span class="token function">TestReverse</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cases <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>
        input          <span class="token builtin">string</span>
        expectedOutput <span class="token builtin">string</span>
    <span class="token punctuation">}</span><span class="token punctuation">{</span>
        <span class="token punctuation">{</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"ba"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"cba"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">"dcba"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"aibohphobia"</span><span class="token punctuation">,</span> <span class="token string">"aibohphobia"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> c <span class="token operator">:=</span> <span class="token keyword">range</span> cases <span class="token punctuation">{</span>
        <span class="token keyword">if</span> output <span class="token operator">:=</span> <span class="token function">Reverse</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span> output <span class="token operator">!=</span> c<span class="token punctuation">.</span>expectedOutput <span class="token punctuation">{</span>
            t<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"incorrect output for `%s`: expected `%s` but got `%s`"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>input<span class="token punctuation">,</span> c<span class="token punctuation">.</span>expectedOutput<span class="token punctuation">,</span> output<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>All test functions must start with the word <code>Test</code>, and it's conventional to follow that with the name of the function you are testing. The test function must also accept only one parameter of type <code>*testing.T</code>, which is typically named <code>t</code>. This parameter gives you access to functions like <code>t.Errorf()</code> that let you report errors. If any of the error methods on the <code>t</code> parameter are called, the test fails.</p><p>The crazy-looking syntax at the top of the function is declaring and initializing a slice of anonymous structs, each of which will have two string fields: <code>input</code> and <code>expectedOutput</code>. Anonymous structs are like anonymous functions—they are declared in-line with no name. We could have declared a separate struct type and then referred to it like so:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//same effect as above, this just declares</span>
<span class="token comment" spellcheck="true">//the struct type first with a name and then</span>
<span class="token comment" spellcheck="true">//uses it when creating the slice of structs</span>
<span class="token keyword">type</span> testcase <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    input <span class="token builtin">string</span>
    expectedOutput <span class="token builtin">string</span>
<span class="token punctuation">}</span>
cases <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>testcase<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* initializer */</span> <span class="token punctuation">}</span></code></pre><p>But since we never need to refer to that struct type anywhere else in the function, it's simpler to just declare it in-line as an anonymous struct.</p><p>The initializer expression that follows the anonymous struct definition populates the slice of structs with several input and expected output pairs. We start with the unexpected case of an empty string, which should result in another empty string. Then we try various string lengths to make sure our algorithm works for both even and odd-numbered lengths. And finally we test a palindrome, which is a word spelled the same forwards and backwards.</p><p>After declaring and initializing the slice of structs, we just iterate over the slice, passing the <code>input</code> field of each struct to our <code>Reverse()</code> function, and verifying that the output matches the <code>expectedOutput</code> field. If they don't match, we report an error using <code>t.Errorf()</code>.</p><p>The message you pass to <code>t.Errorf()</code> should provide enough information for a developer to know which case failed and why. Keep in mind that the test may fail years after you wrote it due to a careless bug fix by another developer, so be as descriptive as possible.</p><p>To run this test, go to your terminal window, make sure you are in the directory containing the <code>reverse.go</code> and <code>reverse_test.go</code> files, and then execute this command:</p><pre class="language-bash"><code class="language-bash">go <span class="token function">test</span></code></pre><p>It should pass, as we haven't yet included a test case that will reveal our latent bug. Let's do that now.</p><p>So far all of our test cases use characters in the ASCII range, and since Go uses the UTF-8 encoding scheme for strings, each character takes up only one byte. But what would happen if we tried a string containing characters beyond the ASCII range that require multiple bytes in UTF-8?</p><p>Since we built this unit test to be data-driven, adding another case to test characters beyond the ASCII range is a snap. Add this additional case to the slice-of-structs initializer:</p><pre class="language-go"><code class="language-go">    cases <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>
        input          <span class="token builtin">string</span>
        expectedOutput <span class="token builtin">string</span>
    <span class="token punctuation">}</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//...existing cases...</span>
        <span class="token punctuation">{</span><span class="token string">"Hello, 世界"</span><span class="token punctuation">,</span> <span class="token string">"界世 ,olleH"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span></code></pre><p>And now run <code>go test</code> again. This time you should see a failure:</p><pre><code>--- FAIL: TestReverse (0.00s)
    reverse_test.go:21: incorrect output for `Hello, 世界`: expected `界世 ,olleH` but got `??疸? ,olleH`
FAIL
exit status 1</code></pre><p>Why is this case failing? Let's look at the <code>Reverse</code> function again:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token comment" spellcheck="true">//Reverse returns the reverse of the string passed as `s`</span>
<span class="token keyword">func</span> <span class="token function">Reverse</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//convert string to a slice so we can manipulate it</span>
    <span class="token comment" spellcheck="true">//since strings are immutable, this creates a copy of</span>
    <span class="token comment" spellcheck="true">//the string so we won't be modifying the original</span>
    chars <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//starting from each end, swap the values in the slice</span>
    <span class="token comment" spellcheck="true">//elements, stopping when we get to the middle</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token number">-1</span> <span class="token punctuation">{</span>
        chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//return the reversed slice as a string</span>
    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>See the problem? The first executable line of the function converts the input string in a slice of bytes, and then we manipulate those bytes as if each one is a complete character. But Go uses <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8 encoding</a> for strings, so a character may consume anywhere from one to four bytes depending on its Unicode value. Thankfully, Go allows us to convert strings not only into a slice of bytes, but also a slice of <a href="https://blog.golang.org/strings">runes</a>, which is their term for a complete Unicode character.</p><p>Fix your <code>Reverse()</code> function by converting the input parameter <code>s</code> to a slice of runes instead of a slice of bytes, like so:</p><pre class="language-go"><code class="language-go">    chars <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span></code></pre><p>And now go back to your terminal and re-run your tests using <code>go test</code>. They should now all pass.</p><h3 id="secdeterminingcodecoverage">Determining Code Coverage</h3><p>As noted earlier, your unit tests should exercise as many lines of your feature code as possible. The ratio of lines exercised to total lines is known as your test coverage, and you should strive to be as close to 100% as possible.</p><p>Go makes it really easy to determine your coverage—just add the <code>-cover</code> flag to the <code>go test</code> command:</p><pre class="language-bash"><code class="language-bash">go <span class="token function">test</span> -cover</code></pre><p>Since our test exercises every line of our <code>Reverse()</code> function, we have 100% test coverage!</p><p>Go can also show you exactly what lines were and were not executed by your tests. Use these commands:</p><pre class="language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># run tests and capture coverage details</span>
go <span class="token function">test</span> -coverprofile<span class="token operator">=</span>coverage.out
<span class="token comment" spellcheck="true"># generate HTML report showing lines run and not run</span>
go tool cover -html<span class="token operator">=</span>coverage.out</code></pre><p>This will open a web browser showing you the source files that were tested. Lines that were executed by your tests will be green, and those that were not will be red. If your feature code is in multiple source files, you can use the drop-down at the top left to switch between them.</p><p><img src="img/coverage.png" alt="screenshot of go coverage analysis report" class="screenshot"></p><h3 id="secintegrationtestsingo">Integration Tests in Go</h3><p>The example above was a unit test, so we wrote it to be data-driven and exhaustive. As noted earlier, integration tests are more about testing a series of calls, such as a typical CRUD cycle, to ensure that they are working correctly together. And if those calls interact with external components such as a DBMS, we often try to use a mock implementation of the DBMS client library so that our tests don't require a running instance of the DBMS.</p><p>Go's static typing makes it difficult to build mocks, unless the DBMS client library defines its API as a Go <code>interface</code>. An <code>interface</code> is a type that can be implemented by multiple structs in multiple packages, including a mock implementation that we build and use for automated testing.</p><p>Unfortunately, most DBMS client packages do not define their APIs as an <code>interface</code>. Instead, they just define structs and functions, which can't be implemented transparently by a mock. This is an architectural flaw that I hope will be remedied in future versions of these packages, but for now we have to deal with it.</p><p>One approach is to define your own interface to encapsulate a "store" for your model objects. This interface would define various functions for finding, inserting, updating, and deleting models in the data store. For example, an interface for managing a store of "messages" might look like this:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> <span class="token string">"messages"</span>

<span class="token keyword">type</span> Store <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function">Insert</span><span class="token punctuation">(</span>newMessage <span class="token operator">*</span>NewMessage<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Message<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token function">Get</span><span class="token punctuation">(</span>id bson<span class="token punctuation">.</span>ObjectId<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Message<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token function">Find</span><span class="token punctuation">(</span>q <span class="token operator">*</span>Query<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Message<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token function">Update</span><span class="token punctuation">(</span>message <span class="token operator">*</span>Message<span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token keyword">func</span> <span class="token function">Delete</span><span class="token punctuation">(</span>id bson<span class="token punctuation">.</span>ObjectId<span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">}</span></code></pre><p>You then build two implementations of this interface: one backed by your chosen DBMS that you use for system tests and production; and one backed by a simple in-memory data structure that you use for integration tests. The in-memory version can also support additional functions that trigger unexpected runtime errors, so that you can test your error handling code and achieve 100% coverage.</p><p>For more information on Go interfaces, see <a href="https://gobyexample.com/interfaces">Go By Example: Interfaces</a> and the <a href="https://golang.org/doc/effective_go.html#interfaces">Interfaces section of Effective Go</a>.</p><h2 id="sectestdrivenandbehaviordrivendevelopment">Test-Driven and Behavior-Driven Development</h2><p>Organizations that take automated testing seriously often practice what is known as <strong>test-driven development (TDD)</strong>. With this approach, developers write their automated tests first based on the specifications, and then implement their features by adding only the code necessary to make the tests pass. This is the reverse of how it's normally done, but TDD proponents argue that implementing tests after features tends to have two detrimental effects:</p><ul><li>Developers often get carried away when implementing features, adding more functionality and options than is required by the specifications, which just creates more opportunities for bugs and security vulnerabilities.</li><li>Since writing software typically takes longer than one expects, especially if developers add unnecessary features, waiting until the end to write tests results in rushed, weak, and incomplete tests.</li></ul><p>TDD proponents argue that their approach leads to faster development cycles and more reliable software. This enables organizations to respond more quickly to rapidly changing contexts without destabilizing their systems in the process.</p><p>Organizations that follow a TDD process often subscribe to <strong>behavior-driven development (BDD)</strong> as well, which attempts to bring the language used in the requirements and functional specifications into the automated tests. BDD testing frameworks allow you to write tests that look almost like English sentences:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//JavaScript test using popular mocha.js and chai.js frameworks</span>
<span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">"reverse"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"should reverse strings"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>should<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token string">"olleh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"should handle high Unicode characters"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">"Hello, 世界"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>should<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token string">"界世 ,olleH"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"should return an empty string for an empty string"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span>should<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"should return null for null"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span>should<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//etc...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>BDD works better in dynamically-typed languages like JavaScript than it does in statically-typed languages, but the <a href="https://onsi.github.io/ginkgo/">Gingko</a> and <a href="https://onsi.github.io/gomega/">Gomega</a> frameworks provide an implementation of BDD for Go that works well, albeit with a little clumsier syntax. Here's what a similar BDD-style test would look like using Ginko and Gomega:</p><pre class="language-go"><code class="language-go"><span class="token keyword">var</span> <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">Describe</span><span class="token punctuation">(</span><span class="token string">"reverse"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">It</span><span class="token punctuation">(</span><span class="token string">"should reverse strings"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Expect</span><span class="token punctuation">(</span><span class="token function">Reverse</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">To</span><span class="token punctuation">(</span><span class="token function">Equal</span><span class="token punctuation">(</span><span class="token string">"olleh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token function">It</span><span class="token punctuation">(</span><span class="token string">"should handle high Unicode characters"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">Expect</span><span class="token punctuation">(</span><span class="token function">Reverse</span><span class="token punctuation">(</span><span class="token string">"Hello, 世界"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">To</span><span class="token punctuation">(</span><span class="token function">Equal</span><span class="token punctuation">(</span><span class="token string">"界世 ,olleH"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//etc...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>The key with TDD and BDD is to not let perfection become the enemy of good. It's better to crank out a suite of simple unit tests like those described above than to get caught up in arguments about proper TDD methods and BDD styles. Use the TDD methods that make the most sense for your organization and context, and don't worry about the rest. Use BDD if it makes sense to you and your team, or just write more straightforward tests like those described above. Ultimately, your job is to help your organization meet its objectives, and you should use the methods and styles that best help you get that job done.</p><h2 id="seccontinuousintegrationtesting">Continuous Integration Testing</h2><p>All of these automated tests are great, but only if you remember to run them! Ideally, every developer on the team should run a suite of automated tests before committing changes to the repo, but we all know that sometimes they will forget to to do it. That's why many development teams use a <strong>continuous integration testing server</strong> to run all of the tests every time commits are pushed the central repo.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>