<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Automated Testing in Go"><meta property="og:description" content="A brief introduction to automated testing and how to do it in Go"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Automated Testing in Go</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Automated Testing in Go</h1><p class="subtitle">A brief introduction to automated testing and how to do it in Go</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Aug 4, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>Anyone can learn to hack together an information system that works for one version, but building a system that continues to run reliably over many releases and years requires learning not only a good architecture, but also the discipline of automated testing. In fact, the thing that separates professional from amateur developers the most is a commitment to writing automated tests for their features.</p><p>As your project grows in size and complexity, a suite of automated tests will help you ensure that small bug fixes or changes made for new features don't break your existing functionality. If your tests are complete (i.e., they exercise all of your code paths by test both success and failure cases), you can make changes and release new versions with confidence.</p><p>If you do it right, your test code will actually be longer than your feature code. For example, <a href="https://www.sqlite.org/testing.html">the SQLite library has 730 times more automated test code than feature code</a>. They can fix bugs or make changes to their most core code yet know within a few minutes that the features their users depend upon are still functioning as expected. Before releasing a new version, they run all of their tests on multiple platforms, with multiple build configurations. Doing all that testing manually would be unthinkable.</p><h2 id="secwhatareautomatedtests">What are Automated Tests?</h2><p>An automated test is just another program that calls your feature code, passing various kinds of inputs, and testing the outputs to ensure they are what you expect them to be. These programs should test both valid and invalid inputs, and if possible, trigger unusual error conditions to ensure that the feature code handles them properly.</p><p>Ideally, your tests should invoke every line of your feature code at some point. The percentage of lines invoked is known as your <strong>code coverage</strong>, and it should be as high as possible. In some cases you can achieve 100%, but in others there will be code paths that are run only when very unexpected errors occur that your tests can't fabricate.</p><p>You can write automated tests in any language, but some languages offer specialized tools or environments for writing and running these tests. For example, Go defines a way to write automated tests that are automatically excluded from your compiled executable, but can be run at development time using their <code>go test</code> tool. This tool also provides <a href="https://blog.golang.org/cover">code coverage analysis</a>, showing you exactly which lines were exercised by your tests, and which were not. In the Node.js ecosystem, the tool <a href="https://mochajs.org/">mocha.js</a> is often used to run tests.</p><h2 id="seclevelsoftesting">Levels of Testing</h2><p>We can write automated tests at several levels: individual functions or classes in isolation; groups of integrated components; or entire systems running like they will in production.</p><h3 id="secunittests">Unit Tests</h3><p>The most common automated tests are those that test functions or classes in isolation. These are known as <strong>unit tests</strong>, as they are testing just one unit of the system at a time. These tests should be as exhaustive as possible, and cover all code paths.</p><p>These tests are often written in a data-driven style: you define multiple sets of input parameters and expected outputs, and then iteratively test each input/output pair. As you discover new possible input combinations, you just add those to the list, and the testing code automatically tests them. See <a href="#secwritingtestsingo">below</a> for an example of this in Go.</p><h3 id="secintegrationtests">Integration Tests</h3><p>Once you know that your system units are working in isolation, you then can test how they behave when they are integrated with other units into a sub-system. This is also where you test how your own units interact with code written by other people: for example, reusable libraries, database management systems, or the operating system. These are known as <strong>integration tests</strong>, as you are testing how your code units integrate with other code.</p><p>Integration tests are less about exhaustively testing input and outputs, and more about testing how units interact through a transaction flow. For example, a code module you write to manage user accounts in a DMBS (a user store) will expose several functions, and you will test those functions in isolation in your unit tests, but in your integration tests you will ensure that the functions work correctly together in a typical Create/Read/Update/Delete (CRUD) cycle. Your integration test would do the following:</p><ul><li>create a new record</li><li>read the record and ensure it was saved correctly</li><li>update the record</li><li>read it again to make sure it was actually updated</li><li>delete it</li><li>ensure that you can no longer read it</li></ul><p>Integration tests verify the dependencies <em>between</em> units, and thus can reveal errors that the unit tests miss. For example, if you added local caching to your user store to increase performance, but forgot to invalidate or patch the cache entry when the user record is updated, your integration test will catch it while your unit tests probably won't.</p><p>To run a test like this, your will naturally have to talk to the DBMS, but in many languages you can create a <em>mock implementation</em> of the DBMS so that your tests are easier to run. A mock implements the same interface as the DBMS client library, but uses a simple in-memory data store instead of talking to the actual database server. When using a mock, developers don't need to have the DBMS running locally in order to run the tests, and your tests aren't affected by data that might already be in the DBMS. Mocks also make it easier to trigger unusual runtime errors that might be impossible to trigger when using the actual DBMS, so they can help you achieve a higher code coverage ratio.</p><h3 id="secsystemtests">System Tests</h3><p>Both unit and integration tests focus on one piece of your system at a time, but <strong>system tests</strong> are meant to test your entire system in a context similar to production. For example, a unit test for a web server handler function would just invoke the function directly, but a system test for a web server would actually start the server and it's dependencies (ephemeral and persistent DBMSs, message queues, etc.), and then send real HTTP requests to the server, evaluating the HTTP responses.</p><p>System tests can uncover problems that would occur only in a production environment. For example, a system test could uncover issues that occur if the network socket is closed before the entire request body is received, or while the response is being written.</p><p>System tests can also verify system-level features, such as automatically restarting a microservice instance when it fails, automatically failing-over to a backup system when the primary system goes down.</p><h3 id="secstresstests">Stress Tests</h3><p>The final type of automated tests to mention are <strong>stress tests</strong>. These are a bit different than the previous types of tests as they are not really about testing features, <em>per se</em>. Instead they are about testing how your system behaves under stressful conditions, such as a very high transaction load. Stress tests will determine how much your system can handle, and at what point it will fail without more resources.</p><p>Stress tests require a bit more in terms of test infrastructure. In order to mimic a high transaction load on a web server, you really need to have dozens of clients all making multiple requests to the server at the same time. Each client measures how long each request took to process, and the server monitors things like request queue size, CPU/memory usage, and DBMS query duration.</p><p>One you build a stress test infrastructure, you can run several tests with different system configurations and actually measure the results to see which configuration gives you the scalability you need for the least cost. Without this, you can only guess and hope.</p><h2 id="secwritingtestsingo">Writing Tests in Go</h2><p>Now that you know the distinctions between automated tests, let's see how we can write unit tests in Go.</p><h2 id="sectestdrivendevelopment">Test-Driven Development</h2><p>TDD and BDD</p><h2 id="seccontinuousintegrationtesting">Continuous Integration Testing</h2></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>