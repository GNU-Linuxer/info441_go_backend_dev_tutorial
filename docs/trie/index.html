<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="The Trie Data Structure"><meta property="og:description" content="Providing fast prefix searching"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>The Trie Data Structure</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px;margin-bottom:1em}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-SQFSBJB996"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-SQFSBJB996")</script></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">The Trie Data Structure</h1><p class="subtitle">Providing fast prefix searching</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Oct 23, 2021 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>On many social media systems, you can refer to other users in your posts. As soon as you start typing a name, you often get a list of possible matches. The system might have millions of users, but it's able to show you suggestions as quickly as you can type.</p><p>Enabling this sort of suggest-as-you-type feature requires a fast, in-memory index. These indexes can use several different kinds of data structures depending on what kind of queries they need to answer. The data structure we commonly use when we need to find entries that match a prefix string is known as a <strong>trie</strong> (pronounced "tree" or "try"). The name comes from the word re<strong>trie</strong>val, which indicates that this structure is designed for search and retrieval operations, specifically searching for things that match a prefix string.</p><h2 id="secwhatisatrie">What is a Trie?</h2><p>A trie is a type of tree structure. You might remember tree structures from your computer science courses, but in case you don't, a tree is a hierarchical structure that is comprised of <strong>nodes</strong>. Each node is implemented as an object or struct, depending on your programming language. Each node may point to multiple child nodes, and conversely most nodes have a single parent node. The node at the start of the tree is known as the <strong>root node</strong> and it is the only node with no parent. If a node has no child nodes, it's known as a <strong>leaf node</strong>. A typical binary tree would look like this:</p><p><img src="img/binary-tree.png" alt="binary tree"></p><p>As the name implies, a <em>binary</em> tree has at most two children per-node, but tree structures that have many children per-node are known as <em>n-ary</em> trees. Tries are <em>n-ary</em> trees.</p><h2 id="secwhatdotriesstore">What do Tries Store?</h2><p>Like other search-oriented data structures, a trie stores <strong>keys</strong> and associated <strong>values</strong>. Together, the key and value are called an <strong>entry</strong>. The key is always a string, but the value could be of any type, as the trie just stores and retrieves it as an opaque value. Often this value is a unique identifier or pointer that gets you to some data related to the key (e.g., primary key of a record in a DBMS).</p><p>Like a map, a trie can also be used to store only keys with no associated values. For example, a simple list of dictionary words might not need associated values, but you might want to find all words that start with a given prefix. In these cases we use a variant of a trie that only stores keys with no associated values. The structure is similar, but we can save a little memory in each node.</p><h2 id="secaddingkeysandvalues">Adding Keys and Values</h2><p>A trie constructs a tree of nodes based on the letters in the keys added to it. The tree starts with a single root node that holds no values. When a new key/value pair is added, the trie follows this algorithm:</p><ul><li>let current node = root node</li><li>for each letter in the key<ul><li>find the child node of current node associated with that letter</li><li>if there is no child node associated with that letter, create a new node and add it to current node as a child associated with the letter</li><li>set current node = child node</li></ul></li><li>add value to current node</li></ul><blockquote><p><strong>Note:</strong> if you want to support multiple languages, the "letters" here refer to complete Unicode characters. In Go, full Unicode characters are represented by the <code>rune</code> type, and you must use particular constructs to iterate the runes in a string, as they may be different byte lengths. See the discussion in the <a href="../golang#secsimpletypes">Simple Types</a> section of The Go Language tutorial.</p></blockquote><p>For example, say we add the key <code>"go"</code> with the value <code>1</code> to the trie. The resulting structure would look like this:</p><p><img src="img/trie-1.png" alt="trie after adding the key &quot;go&quot; with value 1"></p><p>Since our tree was empty to begin with, we add a new node and level for each letter in the key. The final leaf node then holds the associated value.</p><p>If we next add the key <code>"git"</code> with the value <code>2</code>, the structure would grow to look like this:</p><p><img src="img/trie-2.png" alt="trie after adding the key &quot;git&quot; with value 2"></p><p>Note how we re-used the existing node for <code>"g"</code> but we added new nodes for <code>"i"</code> and <code>"t"</code>.</p><p>If we next add the key <code>"gob"</code> with the value <code>3</code>, the structure would grow to look like this:</p><p><img src="img/trie-3.png" alt="trie after adding the key &quot;gob&quot; with value 3"></p><p>Notice how we re-used the existing nodes for <code>"g"</code> and <code>"o"</code> and only had to add one new node for <code>"b"</code>. Although we reused those first two nodes, we can still tell that both the keys <code>"go"</code> and <code>"gob"</code> were added to the trie because there's a value stored in the node pointed to by <code>"o"</code> and the node pointed to by <code>"b"</code>. As you traverse down the tree, every time you see a value, you know that you've read a complete key.</p><p>When indexing keys that are not unique (e.g., last names), we will often need to add the same key to the trie multiple times but with different values. For example, say we added the key <code>"go"</code> again, but this time with the value <code>4</code>. Since we already added that key, we won't need to create any new nodes, but we will need to add the value <code>4</code> to the node we arrive at when following the algorithm above.</p><p><img src="img/trie-4.png" alt="trie after adding the key &quot;go&quot; with value 4"></p><p>As you might expect, the height of a trie is always equal to the length of the longest key added to it. This means that tries tend to be very wide and not terribly deep, which makes retrieval speed much quicker. Adding a new key requires creating at most <em>len(key)</em> nodes, but if your keys share common prefixes (which is typical), you will re-use nodes from previously-added keys.</p><h2 id="secretrievingkeysandvalues">Retrieving Keys and Values</h2><p>At this point you can see how this structure sets us up for very fast retrieval of keys that start with a prefix. To do so, we follow this algorithm:</p><ul><li>let current node = root node</li><li>for each letter in the prefix<ul><li>find the child node of current node associated with that letter</li><li>if there is no child associated with that letter, no keys start with the prefix, so return an empty/nil list</li><li>set current node = child node</li></ul></li><li>current node now points to the branch containing all keys that start with the prefix; recurse down the branch, gathering the keys and values, and return them</li></ul><p>The important thing to note here is that finding the start of the branch containing all keys and values takes at most <em>len(prefix)</em> lookups, <em>regardless of how many entries there are in the trie</em>. The retrieval complexity depends on the length of the key prefix, not the number of entries in the trie, so the retrieval performance remains about the same as we add more entries. Compare that with a binary search tree, which requires at most <em>log(n)</em> comparisons to find the first matching key, where <em>n</em> is the number of <em>entries</em> in the tree.</p><p>Since the branch we find for a short prefix might contain a lot of keys and values, we typically return only the first <em>m</em> entries from the branch, where <em>m</em> is a parameter passed by the caller (usually a relatively small value since we're often showing these as a list of suggestions). To get this subset, you do a depth-first recursion down the branch, following the letters in each node according to their alphabetical order. As soon as you gather <em>m</em> keys and values, you return to stop the recursion.</p><h2 id="sechybridtries">Hybrid Tries</h2><p>Although tries offer very fast retrieval, they aren't terribly space-efficient unless most of your keys are short and share common prefixes (i.e., dictionary words). Longer keys that don't share prefixes create a "leggy" tree structure, resembling a many-tentacled octopus!</p><p>In these situations, it's common to use a variant known as a <strong>hybrid trie</strong>. Instead of always creating a new node for each letter in the key, the leaf nodes in a hybrid trie store a list of key suffixes until those reach some maximum number, for example, 50. When the 51st key is added, the leaf node the transforms itself into a typical trie node, and creates a new leaf node for each distinct first-letter in the key suffixes it holds. Each of the new child leaf nodes then stores what remains of the key suffixes for their respective letter.</p><p>It's easier to show this visually than to describe it. Assume that we a hybrid trie where one of the leaf nodes has the maximum number of key suffixes allowed:</p><p><img src="img/hybrid-trie-1.png" alt="hybrid trie where one leaf node has max suffixes"></p><p>If we try to add the key <code>"guard"</code> to this, we can't simply add the suffix <code>"uard"</code> to the right leaf node, as it has reached the maximum number of suffixes. So the node transforms itself into a regular trie node, adding new leaf nodes for each distinct first letter in its existing key suffixes. Those new leaf nodes then store what remains of the key suffix. Finally, the node adds the remaining suffix for the new key to the new leaf node associated with <code>"u"</code>.</p><p><img src="img/hybrid-trie-2.png" alt="hybrid trie where one leaf node has max suffixes"></p><p>These diagrams depict only the keys, but you can create a hybrid trie that also stores associated values. The leaf nodes would store key-suffix and value pairs instead of just the key suffixes.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script></body></html>