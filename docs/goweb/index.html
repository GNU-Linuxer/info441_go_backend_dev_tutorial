<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Go Web Servers"><meta property="og:description" content="How create a web service in Go"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Go Web Servers</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Go Web Servers</h1><p class="subtitle">How create a web service in Go</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jul 15, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>As I mentioned in the <a href="../http/">HTTP tutorial</a>, a web server is just a program that listens on a port for HTTP requests and responds accordingly. You can write a web server in any language that gives you access to the computer's network interface, but some languages include code in their standard library that handles all the low-level details for you. Go is one of those languages, so building a simple web server in Go is quite easy. The standard library takes care of most of the work, allowing you to focus on the server's logic and functionality.</p><h2 id="sechellowebingo">Hello Web in Go</h2><p>When we <a href="../golang/">learned the Go language</a>, we started with the traditional <a href="../golang/#sechelloworldingo">"Hello, World!" program</a>. To learn Go web servers, we should start with a "Hello, Web!" program:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"log"</span>
    <span class="token string">"net/http"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//HelloHandler handles requests for the `/hello` resource</span>
<span class="token keyword">func</span> <span class="token function">HelloHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"Hello, Web!\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//get the value of the ADDR environment variable</span>
    addr <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"ADDR"</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//if it's blank, default to ":80", which means</span>
    <span class="token comment" spellcheck="true">//listen port 80 for requests addressed to any host</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
        addr <span class="token operator">=</span> <span class="token string">":80"</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//create a new mux (router)</span>
    <span class="token comment" spellcheck="true">//the mux calls different functions for</span>
    <span class="token comment" spellcheck="true">//different resource paths</span>
    mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//tell it to call the HelloHandler() function</span>
    <span class="token comment" spellcheck="true">//when someone requests the resource path `/hello`</span>
    mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> HelloHandler<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//start the web server using the mux as the root handler,</span>
    <span class="token comment" spellcheck="true">//and report any errors that occur.</span>
    <span class="token comment" spellcheck="true">//the ListenAndServe() function will block so</span>
    <span class="token comment" spellcheck="true">//this program will continue to run until killed</span>
    log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"server is listening at %s..."</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> mux<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><h2 id="seccompileinstallandrun">Compile, Install, and Run</h2><p>Before I explain each piece of this, let's try running it. Create a new directory inside your <code>$GOPATH/src</code> directory named <code>hellosvr</code> and create a new file in that directory named <code>main.go</code>:</p><pre class="language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$GOPATH</span>/src/hellosvr
<span class="token function">cd</span> <span class="token variable">$GOPATH</span>/src/hellosvr
<span class="token function">touch</span> main.go</code></pre><p>Open that main.go file in your favorite editor and copy the code above into it. Then run these commands to set the <code>ADDR</code> environment variable, compile/install the server, and start it:</p><pre class="language-bash"><code class="language-bash"><span class="token function">export</span> ADDR<span class="token operator">=</span>localhost:4000
go <span class="token function">install</span>
hellosvr   <span class="token comment" spellcheck="true">#hellosvr.exe on Windows</span></code></pre><p>The <code>export ...</code> line sets an <a href="../env/">environment variable</a> that is visible within this shell and any program launched from this shell. Our program above reads this environment variable at the start of the <code>main()</code> function to know which network address it should listen on. Using an environment variable instead of a hard-coded string makes our program more flexible. We can switch this network address without having to recompile the program.</p><p>The <code>go install</code> command will compile the executable and install (copy) it to the <code>$GOPATH/bin</code> directory. If you get an error while running <code>go install</code>, that's probably due to a compilation error. Read the error message carefully, and check the code to make sure you copied it completely and correctly.</p><p>If you get a "command not found" error while running <code>hellosvr</code> (or <code>hellosvr.exe</code> on Windows), ensure that you added <code>$GOPATH/bin</code> to your <a href="../env/#secdeclaringpersistentuserglobalvariables">system path in a persistent way</a>. If <code>$GOPATH/bin</code> is not in your system path, you can be more explicit about where the executable is: <code>$GOPATH/bin/hellosvr</code>.</p><p>If all went well, you should see a message saying <code>server is listening at localhost:4000...</code> and your command-line will remain occupied as the server is still running. To test the server, open a web browser and go to the URL <a href="http://localhost:4000/hello">http://localhost:4000/hello</a>. You should see "Hello, Web!" in the browser window.</p><p>If you're more of a command-line person, you can also test this server using <code>curl</code>. Open another terminal window and execute this command:</p><pre class="language-bash"><code class="language-bash">curl http://localhost:4000/hello</code></pre><p>If you want to see the response headers, include the <code>-i</code> flag:</p><pre class="language-bash"><code class="language-bash">curl -i http://localhost:4000/hello</code></pre><p>And if you want to see all the request and response details, use the <code>-v</code> flag:</p><pre class="language-bash"><code class="language-bash">curl -v http://localhost:4000/hello</code></pre><p>To stop the web server, hit <code>Ctrl+c</code> in the terminal window where you started it.</p><p>Note that in bash you can combine the install and run commands into one line like this:</p><pre class="language-bash"><code class="language-bash">go <span class="token function">install</span> <span class="token operator">&amp;&amp;</span> hellosvr   <span class="token comment" spellcheck="true">#hellosvr.exe on Windows</span></code></pre><p>This will run the <code>go install</code> command, and if it is successful, will then run your built executable. This is handy during development when you need to restart your server after making changes to the source code. To restart, hit <code>Ctrl+c</code> to stop your server, and then use the up-arrow to recall the last command, which will be <code>go install &amp;&amp; hellosvr</code>. Then hit enter to re-run the command, which will recompile your server with the changes, and restart it.</p><h2 id="secreadingenvironmentvariables">Reading Environment Variables</h2><p>The first line in <code>main()</code> reads an environment variable named <code>ADDR</code> to get the network address on which the server should listen. This address is in the form <code>"host:port"</code>, where <code>host</code> is the IP address or host name to bind to, and <code>port</code> is the port number to listen on.</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//get the value of the ADDR environment variable</span>
addr <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"ADDR"</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//if it's blank, default to ":80", which means</span>
<span class="token comment" spellcheck="true">//listen port 80 for requests addressed to any host</span>
<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
    addr <span class="token operator">=</span> <span class="token string">":80"</span>
<span class="token punctuation">}</span></code></pre><p>We set this environment variable above using the <code>export ADDR=localhost:4000</code> command. Since <code>localhost</code> is defined in the hosts file as the loopback address, the address <code>"localhost:4000"</code> instructs the Go web server to listen on port 4000 for requests that come through the loopback address only. That means the server won't accept connections from other computers. If you want to accept connections from other computers, use the address <code>:4000</code> instead. That will listen for requests that come through any of the network interfaces on your computer.</p><p>If the <code>ADDR</code> environment variable is not set, we would get an empty string back from <code>os.Getenv()</code>. The <code>ListenAndServe()</code> function won't accept an empty address, as it needs to know at least which port number you want to listen on, so we handle this case by defaulting to <code>":80"</code>, which will accept requests from other computers and listen on the default HTTP port 80.</p><p>On a Unix-based operating system, only programs launched by the root account are allowed to list on low port numbers (&lt;1024). On your development machine, you typically sign-in using a non-root user account, so to avoid having to use <code>sudo</code> when starting your server, it's common to use a port number greater than 1024. Any port number not already in use is fine. In production you should always listen on the standard HTTP or HTTPS ports, so that users don't have to include a port number in the URL.</p><h2 id="secmuxes">Muxes</h2><p>The next few lines create a new mux and register one handler function for the <code>"/hello"</code> resource path:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//create a new mux (router)</span>
<span class="token comment" spellcheck="true">//the mux calls different functions for</span>
<span class="token comment" spellcheck="true">//different resource paths</span>
mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//tell it to call the HelloHandler() function</span>
<span class="token comment" spellcheck="true">//when someone requests the resource path `/hello`</span>
mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> HelloHandler<span class="token punctuation">)</span></code></pre><p>The term <strong>mux</strong> is short for "multiplexer," meaning that it can handle requests for multiple resource paths while routing the request to the appropriate handler function. This mux is passed to the <code>http.ListenAndServe()</code> function as the second parameter, so all requests are passed to this mux. The mux then determines which function to call based on requested resource path.</p><p>The <code>.HandleFunc()</code> method adds a new resource path and associated handler function to the mux. When the mux receives a request for the resource path <code>/hello</code>, it will call our <code>HelloHandler()</code> function to handle the request.</p><p>The request processing flows like this:</p><p><img src="img/mux.png" alt="http mux request flow"></p><p>If you use a resource path string like <code>"/hello"</code> that doesn't end with a <code>/</code>, the mux will call your handler function only when the requested resource path matches this string <strong>exactly</strong>. But if you use a resource path string like <code>"/hello/"</code> that does end with a <code>/</code>, the mux will call your handler function when the requested resource path <strong>starts with</strong> this string. So <code>"/hello"</code> will match only <code>"/hello"</code>, but <code>"/hello/"</code> will match <code>"/hello/"</code> and <code>"/hello/foo"</code> and <code>"/hello/foo/bar"</code>, etc. This starts-with matching can be handy when you want to support the use of unique row/document identifiers after the prefix (e.g., <code>"/users/123456"</code> for the user with ID <code>123456</code>).</p><p>You can of course add as many resource paths and associated handler functions to the mux as you want, but for can't add the same resource path twice. If you want multiple handler functions called for a given resource path, create a new handler function that calls the other ones. Or write a <a href="http://nauvalatmaja.com/2016/04/15/function-composition-in-go/">generic compose function using closures</a>.</p><p>The mux in the standard library is often adequate, but if you need more complicated routing, check out the <a href="http://www.gorillatoolkit.org/pkg/mux">mux package in the Gorilla Toolkit</a>. This package lets you use regular expressions in resource path strings, and filter based on HTTP methods, protocols, header values, etc.</p><h2 id="sechandlerfunctions">Handler Functions</h2><p>The second parameter passed to the <code>.HandleFunc()</code> method must be a function with a very particular signature. The function must accept two parameters, the first of type <code>http.ResponseWriter</code> and the second of type <code>*http.Request</code>. The <a href="https://golang.org/pkg/net/http/#ResponseWriter">http.ResponseWriter</a> type is an <strong>interface</strong> with methods that allow you to write HTTP response headers and body data. The <code>*http.Request</code> type is a pointer to an <a href="https://golang.org/pkg/net/http/#Request">http.Request</a> struct, which contains information about the HTTP request. Our <code>HelloHandler()</code> function has this signature:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//HelloHandler handles requests for the `/hello` resource</span>
<span class="token keyword">func</span> <span class="token function">HelloHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"Hello, Web!\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>You can name the parameters whatever you want, but it's customary to name them <code>w</code> and <code>r</code> for "writer" and "request." The values passed for these parameters are created by the HTTP server in the Go standard library when a new request is received, so you can just use them without having to worry about how they were created.</p><p>Here we use the <code>http.ResponseWriter</code> to write a simple greeting string in plain text. The <code>.Write()</code> method accepts a byte slice so that you can write any sort of data to the response including binary, so we convert our string to a byte slice using the syntax <code>[]byte(...)</code>. In Go you can convert a value to another compatible type by using the target type name as a sort of function. For example, to convert a byte slice to a string, you use the syntax <code>string(myByteSlice)</code>. If the conversion can't be done automatically, or if it could fail for some reason (e.g., converting a string to an integer), you must use some other conversion function (e.g., <a href="https://golang.org/pkg/strconv/#Atoi">strconv.Atoi()</a>) and handle any errors that occur.</p><h2 id="sechandlers">Handlers</h2><p>In addition to the <code>.HandleFunc()</code> method, a mux also has a <code>.Handle()</code> method that accepts an <code>http.Handler</code> for a resource path. The <a href="https://golang.org/pkg/net/http/#Handler">http.Handler</a> type is an interface with just one method: <code>ServeHTTP(http.ResponseWriter, *http.Request)</code>. Any struct that implements this method is an <code>http.Handler</code>.</p><p>Handlers are used for cases where your handler function needs access to some extra data. Since handler functions are called directly from the mux, and therefore must conform to the signature described earlier, there is no opportunity to pass extra data along as a third or fourth parameter. Instead, you can create a struct to hold that data, and implement the <code>.ServeHTTP()</code> method on that struct. When the <code>.ServeHTTP()</code> method is invoked, your method will have access to the struct data via the <a href="../golang/#secreceivers">receiver parameter</a>.</p><p>For example, say you wanted to invoke different functions depending on the requested HTTP method (a feature of the Gorilla Toolkit mux). You could support this fairly easily using a struct that tracked a handler function per-method:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//MethodMux sends the request to the function</span>
<span class="token comment" spellcheck="true">//associated with the HTTP request method</span>
<span class="token keyword">type</span> MethodMux <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//use a map where the  key is a string (method name) </span>
    <span class="token comment" spellcheck="true">//and the value is the associated handler function</span>
    HandlerFuncs <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//ServeHTTP sends the request to the appropriate handler based on</span>
<span class="token comment" spellcheck="true">//the HTTP method in the request</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>mm <span class="token operator">*</span>MethodMux<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//r.Method will be the method used in the request (GET, PUT, PATCH, POST, etc.)</span>
    fn <span class="token operator">:=</span> mm<span class="token punctuation">.</span>HandlerFuncs<span class="token punctuation">[</span>r<span class="token punctuation">.</span>Method<span class="token punctuation">]</span>
    <span class="token keyword">if</span> fn <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"that method is not allowed"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusMethodNotAllowed<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//NewMethodMux constructs a new MethodMux</span>
<span class="token keyword">func</span> <span class="token function">NewMethodMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>MethodMux <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>MethodMux<span class="token punctuation">{</span>
        HandlerFuncs<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Since the <code>MethodMux</code> struct implements <code>.ServeHTTP()</code> it can be used wherever an <code>http.Handler</code> is required, so you can pass it directly to the <code>mux.Handle()</code> method:</p><pre class="language-go"><code class="language-go">mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

methmux <span class="token operator">:=</span> <span class="token function">NewMethodMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
methmux<span class="token punctuation">.</span>HandlerFuncs<span class="token punctuation">[</span><span class="token string">"GET"</span><span class="token punctuation">]</span> <span class="token operator">=</span> HelloHandler

mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> methmux<span class="token punctuation">)</span></code></pre><p>With this code, our <code>HelloHandler</code> function will be called only if the request method was <code>GET</code>. If the request method was something else, it will respond with a "method not allowed" error (status code 405). The <code>http.Error()</code> function conveniently writes the error message and status code to the response stream, but note that it doesn't stop processing the request. If you want to stop processing the request after writing an error to the response, simply <code>return</code> from the handler function.</p><p>If we wanted a different function called when the request method was <code>POST</code>, we just add that to the HanderFuncs map:</p><pre class="language-go"><code class="language-go">methmux<span class="token punctuation">.</span>HandlerFuncs<span class="token punctuation">[</span><span class="token string">"POST"</span><span class="token punctuation">]</span> <span class="token operator">=</span> SomeOtherHandlerFunction</code></pre><p>You might have already guessed this, but the <code>http.ServeMux</code> struct is also an <code>http.Handler</code> because it implements the <code>.ServeHTTP()</code> method. The second parameter you pass to <code>http.ListenAndServe()</code> function is an <code>http.Handler</code> and this becomes the root handler for the server. All requests are passed to that handler's <code>.ServeHTTP()</code> method, and the handler processes the request according to its own logic. A handler might delegate the request to another handler, which is what we are doing in the code above. The <code>mux</code> will examine the requested resource path and if it matches <code>/hello</code>, the mux will invoke the <code>methmux.ServeHTTP()</code> method. That method then looks at the HTTP method in the request, and decides which handler function to invoke.</p><p>This ability to compose HTTP handlers is quite powerful. We will return to it when we learn about implementing middleware functions.</p><h2 id="secstartingtheserver">Starting the Server</h2><p>The last line of our program starts the server and logs any errors that occur:</p><pre class="language-go"><code class="language-go">log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"server is listening at %s..."</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> mux<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>The <code>http.ListenAndServe()</code> function starts the web server and blocks until the web server is stopped. If there was an error starting the server, it will return that error, and here we use <code>log.Fatal()</code> to log that error to the console.</p><p>Since <code>http.ListenAndServe()</code> blocks, it's common to write a status message to the log just before calling this function. If you confirm the address on which the server is attempting to listen, that can help you debug problems such as trying to listen on a low port when running as a non-root user.</p><h2 id="secmoredetails">More Details</h2><p>Everything you need to know about a given HTTP request is available on the <a href="https://golang.org/pkg/net/http/#Request">http.Request</a> struct, or via one of it's methods. See the <a href="https://golang.org/pkg/net/http/#Request">Request documentation</a> for more details.</p><p>Similarly, the <a href="https://golang.org/pkg/net/http/#ResponseWriter">http.ResponseWriter</a> interface provides several methods for writing response status codes, headers, and body data. See the <a href="https://golang.org/pkg/net/http/#ResponseWriter">ResponseWriter</a> documentation for more details.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href="..">table of contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>