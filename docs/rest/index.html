<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="REST APIs"><meta property="og:description" content="Designing APIs according to the RESTful pattern"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>REST APIs</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px;margin-bottom:1em}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-SQFSBJB996"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-SQFSBJB996")</script></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">REST APIs</h1><p class="subtitle">Designing APIs according to the RESTful pattern</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Oct 30, 2021 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>Most web servers we build these days expose a set of URLs that are meant to be requested by code rather than a human with a web browser. These URLs accept and return raw data, encoded in a text format like JSON, so they essentially act like an application programming interface (API) for our server-side system.</p><p>As the name suggests, an API is an interface to a system used by programmers writing code, just as a graphical user interface (GUI) is an interface used by humans operating a mouse and keyboard. When we design a GUI, we apply various <a href="http://a.co/a8siRrh">design principles</a> and follow <a href="https://material.io/">platform-specific conventions</a> to create an interface that is <em>intuitive</em> for our end users. An API must also be designed, and just like a GUI, we should apply those same design principles and follow the conventions our client programmers are already familiar with in order to create a programming interface that is intuitive and a joy to use.</p><p>But this begs the question: what are the established conventions for web APIs? What should the resource paths in the URLs look like? How should we interpret the various HTTP methods? How should we allow clients to specify options in their requests? And how should we ensure that older clients continue to work if we need to make changes to the API in the future?</p><p>There have been several attempts to establish conventions for web-based APIs, but there is one pattern that is currently dominant: REST. In this tutorial I will explain the REST design pattern and show you how to use it when designing your own web APIs.</p><h2 id="secwhatisrest">What is REST?</h2><p>REST is technically an acronym that stands for <strong>RE</strong>presentative <strong>S</strong>tate <strong>T</strong>ransfer, though you'll rarely see it spelled out. The name comes from <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">Chapter 5 of Roy Fielding's dissertation</a>, in which he articulated an architectural design pattern for highly-scalable hypermedia systems. He derived this pattern from an examination of several network protocols, HTTP being chief among them.</p><p>He concluded that HTTP scaled extremely well because it uses a design pattern that transmits representations of resource states in a stateless way. That's very abstract and slightly confusing, so let's break that down and explain what he means.</p><p>A <strong>resource</strong> is anything the system can manage: files on disk, models in a database, the shared data of a multi-player game, or even controllers for physical systems. A web server may be able to manage many different kinds of resources, and our API needs to allow programmers to refer to specific resources in a coherent manner.</p><p>Each of these resources has a <strong>state</strong> of some sort, which is the current value of the resource. The state for a file on disk is the file's contents. The state of a model in a database includes the values of the various properties of that model. The state for shared data in a multi-player game would be the positions, status, and actions of all the various players and bots. The state for a controller of a physical system would be the various settings and sensor readings captured by the controller. The state of a resource can be structured and complex, but ultimately it's a series of bytes that capture the current value of the entire resource.</p><p>If we want to transmit the current state of a resource across the network, we must encode that state into some sort of portable <strong>representation</strong>, and for many resources, we can encode them into more than one kind of representation. For example, an image can be encoded into any sort of common raster-based binary representation: PNG, GIF, JPEG, etc. A database row (or any set of properties and values) can be encoded into JSON, XML, or several other text-based representations.</p><p>Once a system can encode and transmit a representation of a resource's current state, it can also allow clients to post new or updated state representations to insert or update resources managed by the server. This allows coordinated transitions to resource states: multiple clients can attempt to update the same resource at the same time by posting updated state representations, and the server can decide how to handle that (last one in wins, first one in wins, or some sort of merge operation).</p><p>Although resource states are transmitted between clients and servers, the <em>requests themselves</em> are entirely stateless, meaning that they don't rely upon any state maintained on the network connection between requests. Each request is entirely <em>self-describing</em>: it names a resource, specifies an action to perform on that resource, and provides any resource representation necessary to complete that action. This allows us to use caches and load balancers to handle very large amounts of requests. If each request is stateless and self-describing, we can distribute those requests among many instances of our web server, regardless of which server handled previous requests from the same client. Requests for the current state of a resource that changes infrequently can also be handled by a caching server that is relatively close to the client (e.g., a proxy server).</p><h2 id="secrestfulwebapis">RESTful Web APIs</h2><p>When we apply this REST pattern to the design of web-based APIs that manage data models in persistent DBMSs, the result is known as a <strong>RESTful Web API</strong>.</p><h3 id="secresources">Resources</h3><p>The resources managed by such an API are primarily models in persistent DBMS collections, not files on disk. In simple cases, the models exposed by the API can be the same as those stored in the database, but it's often a good idea to keep those logically separated so you can change the way you store your models over time, while still maintaining the same shapes in your public API for backwards compatibility. For example, if you choose to change your internal storage format to something like <a href="https://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a>, you can still project the current state of your model from the API as if you were only storing that most current state.</p><p>In the same way a Graphical User Interface (GUI) projects a simplified version of your computer that matches the way most humans think it works, your API should project models that match the way your <em>clients</em> think about the data managed by your service. That might be much simpler and more abstract than the messy realities of your internal database schema and processing. A novice can use a computer via a GUI without needing to know how it works internally; the same should be true of your service's API.</p><p>If the resources we are projecting are models in collections, we first need to decide how our HTTP resource paths map to those collections and models. The convention used by many APIs follows this pattern:</p><pre><code>/version/collection/unique-identifier/related-collection</code></pre><p>The <code>/version</code> segment identifies a version of the API, such as <code>/v1</code>. This provides a name-space for the rest of the path, allowing us to change the structure of those paths in the future while still supporting older clients. If we decide that we need to change the set of root collections in a way that would break older clients, our server can start supporting another set of URLs prefixed by <code>/v2</code> in addition to the existing set prefixed by <code>/v1</code>. Older clients will continue to work while new clients can take advantage of the newly-improved API.</p><p>Although a version prefix is very common in API design, some systems are moving to a custom HTTP header for indicating a specific API version. With this approach the URLs themselves are shorter and cleaner, but the API designer has to decide how to handle requests that omit the version header (e.g., respond with an error or assume the current version).</p><p>The <code>/collection</code> segment names a collection of models within your DBMS. For example <code>/v1/users</code> would refer to all user profiles managed by your system. What this API returns depends on the security model of your system: it may return only the profiles the current user is allowed to see, or it might return only the public properties of each profile (common on social media sites).</p><p>The <code>/unique-identifier</code> segment names a specific model within the collection. This identifier is typically the model's primary key value, but it could be some other value that is unique within the collection, or a special moniker that can be resolved from context. For example <code>/v1/users/1234</code> would refer to the user profile with the ID <code>1234</code>, while <code>/v1/users/me</code> would refer to the currently authenticated user. Again, the ability to reference a particular model doesn't guarantee the current user would be allowed to view or modify it--security must still be enforced on the server-side.</p><p>The identifier you use in your API should be not only unique, but also random and hard to guess given another ID. Many RDBMSs will let you assign monotonically-increasing integer IDs to your rows, but if you use those in your API, your attackers can easily guess a wide range of valid IDs. Instead, generate a new <a href="https://eager.io/blog/how-long-does-an-id-need-to-be/">sufficiently-long random ID</a> for use in the API, and either use that as the database primary key, or store it in a column with a unique index so you can find model(s) related to that ID quickly.</p><p>The <code>/related-collection</code> segment can be used to identify a subset of data related to a specific model. For example, <code>/v1/photos</code> would refer to all photos managed by the system, but <code>/v1/users/me/photos</code> would refer to all photos uploaded by me. And <code>/users/</code> would refer to all users profiles, but <code>/v1/users/me/friends</code> would refer to only those users in my friends list.</p><h3 id="secmethods">Methods</h3><p>As you probably remember from the <a href="../http/">HTTP Tutorial</a>, a request contains not only a resource path, but also a method. These method are used in RESTful Web APIs to specify the action the client wants to perform on the resource. The most commonly-used methods and their respective meanings are as follows:</p><table class="table is-striped"><thead><tr><th>method</th><th>meaning</th><th>safe</th><th>idempotent</th></tr></thead><tbody><tr><td>GET</td><td>return the current state of the resource</td><td>Y</td><td>Y</td></tr><tr><td>PUT</td><td>completely replace the current state of the resource</td><td>N</td><td>Y</td></tr><tr><td>PATCH</td><td>partially update the current state of the resource</td><td>N</td><td>Y</td></tr><tr><td>POST</td><td>add a new child resource</td><td>N</td><td>N</td></tr><tr><td>DELETE</td><td>delete the resource</td><td>N</td><td>Y</td></tr><tr><td>LINK</td><td>link the resource to some other resource</td><td>N</td><td>Y</td></tr><tr><td>UNLINK</td><td>unlink the resource from some other resource</td><td>N</td><td>Y</td></tr><tr><td>OPTIONS</td><td>list the methods the current user is allowed to use on this resource</td><td>Y</td><td>Y</td></tr></tbody></table><p><strong>Safe</strong> means that the method does not change the resource's state on the server, while <strong>idempotent</strong> means that multiple identical requests using that method will have the same effect on the resource state as just one request.</p><p>Although <code>POST</code> requests are not considered idempotent by default, particular REST APIs can make them idempotent by allowing clients to supply some sort of ID that is unique to the <code>POST</code> operation. If the caller gets a timeout or an unexpected (500-level) error, the caller can safely retry the request as long as it passes the same ID it used on the first request. The server can use this ID to de-duplicate requests and ensure they are processed only once (e.g., store the ID in a database column with a unique index and treat duplicate key exceptions as an indication the ID was already processed).</p><p>The <code>PUT</code>, <code>PATCH</code>, and <code>POST</code> methods are often confused by API designers. The <code>PUT</code> method should replace the current state of the resource entirely using the representation in the request body, while <code>PATCH</code> should update only the properties included in the request body. For example, if I do a <code>PUT</code> to <code>/v1/users/me</code>, I need to include an updated copy of my entire user profile in the request body, but if I do a <code>PATCH</code> instead, I can include just the properties I want to change (<code>{"firstName": "New Value"}</code>) and the other properties will remain as they were. The <code>POST</code> method is used to create new child resources, which in an information system means inserting new data. So a <code>POST</code> to <code>/v1/users/</code> would create a new user profile.</p><p>Of course, not all resources in your system will support all of these methods. For example, <code>POST</code> only makes sense on collections, and <code>DELETE</code> would rarely be supported on collections. Additionally, some users may be allowed to use certain methods while others may not, according to your system's authorization rules. For example, users may be allowed to modify or delete their own resources, but not resources created by others. Or administrators might be the only ones allowed to create new types of resources.</p><h3 id="secqueryingandsortingcollections">Querying and Sorting Collections</h3><p>The <code>/v1/users</code> resource refers to all user profiles, but often times clients want to query that collection to get a subset that matches a particular filter. Clients may also want to control the sorting order of those results. In RESTful APIs, these options are specified as query string arguments.</p><p>For example, the resource path <code>/v1/users?q=test</code> would refer to the set of users that match the query <code>test</code>. The server might match this query against several fields in the user profile, and even rank the results depending on which or how many fields matched the query string.</p><p>If the client wanted to change that sorting, the client could add another query string argument containing the set of properties to sort by. For example <code>/v1/users?q=test&amp;sort=lastName,firstName</code> would sort the results first by last name, and then by first name within the same last name. To specify a descending instead of ascending sort, the client can prefix the property name with <code>-</code>. For example, this would sort by last name descending: <code>/v1/users?q=test&amp;sort=-lastName,firstName</code></p><h3 id="secrequestingalternativerepresentations">Requesting Alternative Representations</h3><p>As noted earlier, many types of resources can be encoded in multiple representations, and this is especially true of data stored in a DBMS. API designers will typically specify a default representation for their resources (e.g., JSON), but may allow clients to request alternative formats.</p><p>The conventional way to support this is to allow clients to include an <code>Accept</code> header in their HTTP request listing the representation formats they support, in order of preference. These formats are expressed as a comma-delimited list of <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME types</a>. For example, a client requiring XML instead of JSON would set the <code>Accept</code> header to <code>application/xml</code>, but if the client only prefers XML and can still handle JSON, it would use <code>application/xml, application/json</code> instead. The server then includes a <code>Content-Type</code> header in the response, indicating which representation was used in the response body.</p><p>Supporting alternative representation is not terribly common these days, but it was common when XML and JSON were still competing for dominance, and it may become common again as new encodings become popular. It's also helpful for media resources that have fragmented support for various encodings on different types of clients (e.g., the WebM vs Ogg vs MP4 video encodings).</p><h2 id="secalternativestorest">Alternatives To REST</h2><p>The REST pattern has become very common in web API design, and when followed correctly, it reduces the cognitive load necessary to learn and become productive with a new API. But REST does have a few important drawbacks:</p><ul><li>Clients have little to no control over how much data is returned about a resource. Most APIs return the entire resource state, which could be quite large, even if a client only needs one or two of those properties.</li><li>Complex filtering can be quite difficult to express using query string parameters. For example, filtering a collection based on values in a related collection is easy in SQL, but difficult to model with a flat list of name/value pairs. Some API designers allow full predicate expressions, but simply concatenating these into your SQL queries creates a <a href="../godb/#secguardingagainstsqlinjectionattacks">SQL injection vulnerability</a> so never do that.</li><li>Computational resources, such as a predictive neural network, don't really fit well into a model that is focused on returning and accepting the state of that resource. A neural network has a state, but you'd rarely want to expose that to clients. Instead, you'd only want to accept inputs and respond with outputs, similar to a remote procedure call.</li></ul><p>These drawbacks have led some developers to define alternatives to the REST design pattern. For example, Facebook has been promoting <a href="http://graphql.org/">GraphQL</a>, which allows clients to make structured queries against resources. These queries are similar to what you can do in SQL, only they are expressed as a JSON document rather than a complete English-like syntax. GraphQL gives clients much more flexibility over how much data is returned, and makes complex filtering a bit easier.</p><p>Google is pushing another alternative called <a href="https://grpc.io/">gRPC</a>, which is based on remote procedure calls instead of HTTP resources and methods. A remote procedure call is like calling a function in a library, except that the library is running on a different machine across the network. RPC frameworks like gRPC generate <strong>stub functions</strong> for remotely-callable procedures, which have the same signature as the target function, but send a request across the network to call the actual implementation on the server. Client code can then import and call these stub functions without having to worry about the details of parameter marshaling and network requests. RPCs are typically faster than HTTP requests, as they use binary formats on the wire and thus involve less parsing and data conversion. They are also more strongly-typed than the JSON requests used in REST.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script></body></html>