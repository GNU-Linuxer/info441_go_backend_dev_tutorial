<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="The HyperText Transfer Protocol"><meta property="og:description" content="How HTTP works under the hood"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>The HyperText Transfer Protocol</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">The HyperText Transfer Protocol</h1><p class="subtitle">How HTTP works under the hood</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jul 13, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>The thing that defines the web more than anything else is its underlying communication standard: the <strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol (HTTP). If you want to build successful web applications, you need to understand this protocol and how it works. The good news is that it's stupidly simple. One of the reasons the web grew as fast as it did is because the underlying protocol is clear, straightforward, and uncomplicated. Anyone can learn it in a matter of minutes, and once you learn it, you'll understand what's really happening when you browse the web, make HTTP requests from JavaScript, or handle those requests on the server-side.</p><h2 id="seckeyterms">Key Terms</h2><p>Before we look at the protocol itself, we need to review and solidify a few key terms. The best way to do that is to look at the anatomy of a URL. A URL is a string of characters, but it's divided into a few distinct parts, each of which is used during an HTTP request.</p><p><img src="img/url.png" alt="anatomy of a URL"></p><h3 id="secprotocol">Protocol</h3><p>The first part of the URL names the <strong>protocol</strong> to use, which is sometimes referred to as the <strong>scheme</strong>. The name <code>http</code> refers to HTTP, and <code>https</code> refers to a combination of HTTP and <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security (TLS)</a>. When using TLS, all requests and responses are encrypted as they are sent across the network so that an attacker in the middle can't read the contents. This results in a bit of computational and size overhead, but today's computers and networks are fast-enough that HTTPS is quickly becoming the standard for all web traffic.</p><p>Never enter sensitive information into a web page where the URL starts with <code>http</code>, and never send sensitive data from JavaScript over an <code>http</code> connection. Anyone with access to the network can read everything sent over <code>http</code> in plain text. Make sure you use <code>https</code> when transmitting sensitive information.</p><h3 id="sechost">Host</h3><p>The next part is the <strong>host</strong> which is the name of the computer we want to talk to. The host can be a domain name such as <code>example.com</code>, or it can be a sub-domain like <code>api.example.com</code> or <code>ischool.uw.edu</code>. Domain names have to be purchased from domain registrars, but once you register one, you can create as many sub-domains as you like and adjust them whenever necessary.</p><p>To make a network connection, the client needs to translate the host name into a numeric IP address. It does this using the <a href="https://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System (DNS)</a>. The DNS is a bit like a telephone book that one can use to resolve a host name to an IP address, and you can access it right from the command line. Open a new command-line window (Terminal on Mac or Git Bash/PowerShell on Windows) and type this command:</p><pre class="language-bash"><code class="language-bash"><span class="token function">nslookup</span> ischool.uw.edu</code></pre><p><em>Sample Output</em></p><pre><code>Server:        192.168.0.1
Address:    192.168.0.1#53

Non-authoritative answer:
Name:    ischool.uw.edu
Address: 128.208.201.29</code></pre><p>In addition to <a href="https://linux.die.net/man/1/nslookup">nslookup</a>, Mac and Linux users can also use the more concise <a href="https://linux.die.net/man/1/host">host</a> command:</p><pre class="language-bash"><code class="language-bash">host ischool.uw.edu</code></pre><p><em>Sample Output</em></p><pre><code>ischool.uw.edu has address 128.208.201.29</code></pre><p>The iSchool host name resolves to only one address, but other domain names might resolve to several possible addresses. For example, try <code>uw.edu</code> instead. It should return multiple IP addresses, any of which can be used by a web client.</p><p>These commands talk to the DNS, but they also consult a hosts file on your local computer that contains well-known host names and their associated IP addresses. On Mac and Linux, this file is at <code>/etc/hosts</code>, and on Windows it's at <code>c:\Windows\System32\Drivers\etc\hosts</code>. To see the contents of this file use this command:</p><pre class="language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># on Mac and Linux</span>
<span class="token function">cat</span> /etc/hosts

<span class="token comment" spellcheck="true"># on Windows</span>
<span class="token function">cat</span> c:\Windows\System32\Drivers\etc\hosts </code></pre><p>You'll probably have at least one line in that file that defines the host <code>localhost</code> to be the IPv4 address <code>127.0.0.1</code>, and possibly another line that defines the IPv6 address to be <code>::1</code>. These are known as "loopback addresses" because they just loop back to the same machine from which the request is made: your local computer. Thus, the host <code>localhost</code> is an alias for your computer.</p><h2 id="secport">Port</h2><p>The host and associated IP address can get you connected to a server across the Internet, but that server might be listening for network requests on many different ports. You can think of an IP address like the street address of an apartment building, while the <strong>port number</strong> is the number of a specific apartment inside. To connect to a web server, we need both the host/IP and a port number.</p><p>As a convention, web servers listen on port <code>80</code> for unencrypted HTTP requests, and port <code>443</code> for encrypted HTTPS requests. If you don't specify a port number in your URL, the browser will assume these conventional ports. But you can override this by including a port number in your URL, like so: <code>http://localhost:4000/path/to/resource</code>. This tells the client to connect to port <code>4000</code> instead of the conventional port <code>80</code>.</p><h2 id="secresourcepath">Resource Path</h2><p>After the host and optional port number, the segment up until the <code>?</code> is known as the <strong>resource path</strong>. Technically, this can take any form that the server knows how to interpret, so it doesn't strictly need to look like a file path, but people have gotten so used to the path form that most developers continue to use it.</p><p>Although this looks like a file path, it's critical for server-side development to understand that <strong>it can refer to anything the server can manipulate</strong>: a file, a database table/record, an in-memory game state, a neural network, a connected device, or even a controller for a giant mechanical killer robot. The term "resource" is purposely vague and open-ended so that one can enable the manipulation of just about anything via HTTP requests.</p><h2 id="secquerystringparametersandvalues">Query String, Parameters, and Values</h2><p>The last part of the URL above contains the <strong>query string</strong>, which allows the client to pass additional parameters and values that are relevant for the requested resource. These parameters are typically used only when getting the state of the resource, and they are often used to supply filters, sorts, or other options supported by the resource. For example, when getting the <code>/users</code> resource, which represents all user accounts in the system, one might supply a query string like <code>?q=dave&amp;max=50</code> to find the first 50 users with the name <code>dave</code>.</p><p>The query string starts with a <code>?</code> and is followed by one or more name/value pairs. The name/value pairs are separated by <code>&amp;</code>. The name and value are separated by <code>=</code>. For obvious reasons, literal <code>&amp;</code> and <code>=</code> characters within parameter names or values must be encoded as <code>%26</code> and <code>%3D</code> respectively, and a literal <code>%</code> must be encoded as <code>%25</code>. The number after the <code>%</code> is the hex representation of the character's Unicode number. The <code>encodeURIComponent()</code> function in JavaScript can be used to do this encoding in the browser, and similar functions are available in most other languages.</p><p>Technically speaking, <code>- _ . ! ~ * ' ( )</code> and space must also be encoded, as well as characters outside the ASCII range, but most client libraries handle this for you, so you rarely need to worry about this.</p><h2 id="sechttprequests">HTTP Requests</h2><p>Now that we have our terms straight, let's see how these URL elements are used in an HTTP request.</p><p><img src="img/req-get.png" alt="http get request format"></p><p>HTTP requests are just plain text, so you can easily read and type them. The first line (simply called the "request line") contains the <strong>method</strong>, <strong>resource path</strong> (which we already discussed <a href="#secresourcepath">earlier</a>), and requested <strong>protocol version</strong>.</p><h3 id="secmethodsandresources">Methods and Resources</h3><p>The core philosophy of HTTP is that clients invoke methods on resources. The resource is the object and the method is the verb. Or to put it another way, the resource path identifies a thing the server can manage, and the method specifies an action the server should take on that resource.</p><p>There are several methods defined in the HTTP standard, and the most commonly-used are as follows:</p><table class="table is-striped"><thead><tr><th>method</th><th>meaning</th></tr></thead><tbody><tr><td>GET</td><td>return the current state of the resource</td></tr><tr><td>PUT</td><td>completely replace the current state of the resource</td></tr><tr><td>PATCH</td><td>partially update the current state of the resource</td></tr><tr><td>POST</td><td>add a new child resource</td></tr><tr><td>DELETE</td><td>delete the resource</td></tr><tr><td>LINK</td><td>link the resource to some other resource</td></tr><tr><td>UNLINK</td><td>unlink the resource from some other resource</td></tr><tr><td>OPTIONS</td><td>list the methods the current user is allowed to use on this resource</td></tr></tbody></table><p>Servers may choose to support other methods, including custom methods they define. This is generally fine, but sometimes you can run into troubles if there is a proxy server in the middle that rejects requests with non-standard methods for security reasons. In that case, developers commonly use <code>POST</code> with a query string parameter or other custom header that indicates what the real method is.</p><h3 id="secprotocolversion">Protocol Version</h3><p>The request line ends with a protocol version the client wishes to speak. HTTP, like all standards, is an evolving one, and there have been a few versions of HTTP defined over the years. The example above uses <a href="https://tools.ietf.org/html/rfc2616">HTTP/1.1</a> which is widely supported, but <a href="https://developers.google.com/web/fundamentals/performance/http2/">HTTP/2.0</a> has now been defined and support for it is growing.</p><p>By allowing clients to request a particular protocol version, servers and clients can start supporting the newer version while still being able to fall back to the older version if the other side doesn't yet support the new version. For example, a client can request <code>HTTP/2.0</code> but the server can reply saying it only supports <code>HTTP/1.1</code>. The client can then gracefully downgrade and use the 1.1 version for the rest of the conversation.</p><h3 id="secheaders">Headers</h3><p>The next lines in the request specify the headers.</p><h2 id="sechttpresponses">HTTP Responses</h2></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href="..">table of contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>