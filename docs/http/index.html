<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="The HyperText Transfer Protocol"><meta property="og:description" content="How HTTP works under the hood"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>The HyperText Transfer Protocol</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px;margin-bottom:1em}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-SQFSBJB996"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-SQFSBJB996")</script></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">The HyperText Transfer Protocol</h1><p class="subtitle">How HTTP works under the hood</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Oct 23, 2021 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>The thing that defines the web more than anything else is its underlying communication standard: the <strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol (HTTP). If you want to build successful web applications, you need to understand this protocol and how it works. The good news is that it's stupidly simple. One of the reasons the web grew as fast as it did is because the underlying protocol is clear, straightforward, and uncomplicated. Anyone can learn it in a matter of minutes, and once you learn it, you'll understand what's really happening when you browse the web, make HTTP requests from JavaScript, or handle those requests on the server-side.</p><h2 id="seckeyterms">Key Terms</h2><p>Before we look at the protocol itself, we need to review and solidify a few key terms. The best way to do that is to look at the anatomy of a URL. A URL is a string of characters, but it's divided into a few distinct parts, each of which is used during an HTTP request.</p><p><img src="img/url.png" alt="anatomy of a URL"></p><h3 id="secprotocol">Protocol</h3><p>The first part of the URL names the <strong>protocol</strong> to use, which is sometimes referred to as the <strong>scheme</strong>. The name <code>http</code> refers to HTTP, and <code>https</code> refers to a combination of HTTP and <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security (TLS)</a>. When using TLS, all requests and responses are encrypted as they are sent across the network so that an attacker in the middle can't read the contents. This results in a bit of computational and size overhead, but today's computers and networks are fast-enough that HTTPS is quickly becoming the standard for all web traffic.</p><p>Never enter sensitive information into a web page where the URL starts with <code>http</code>, and never send sensitive data from JavaScript over an <code>http</code> connection. Anyone with access to the network can read everything sent over <code>http</code> in plain text. Make sure you use <code>https</code> when transmitting sensitive information.</p><h3 id="sechost">Host</h3><p>The next part is the <strong>host</strong> which is the name of the computer we want to talk to. The host can be a domain name such as <code>example.com</code>, or it can be a sub-domain like <code>api.example.com</code> or <code>ischool.uw.edu</code>. Domain names have to be purchased from domain registrars, but once you register one, you can create as many sub-domains as you like and adjust them whenever necessary.</p><p>To make a network connection, the client needs to translate the host name into a numeric IP address. It does this using the <a href="https://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System (DNS)</a>. The DNS is a bit like a telephone book that one can use to resolve a host name to an IP address, and you can access it right from the command line. Open a new command-line window (Terminal on Mac or Git Bash/Linux Subsystem on Windows) and type this command:</p><pre class="language-bash"><code class="language-bash"><span class="token function">nslookup</span> ischool.uw.edu</code></pre><p><em>Sample Output</em></p><pre><code>Server:        192.168.0.1
Address:    192.168.0.1#53

Non-authoritative answer:
Name:    ischool.uw.edu
Address: 128.208.201.29</code></pre><p>In addition to <a href="https://linux.die.net/man/1/nslookup">nslookup</a>, Mac and Linux users can also use the more concise <a href="https://linux.die.net/man/1/host">host</a> command:</p><pre class="language-bash"><code class="language-bash">host ischool.uw.edu</code></pre><p><em>Sample Output</em></p><pre><code>ischool.uw.edu has address 128.208.60.39
ischool.uw.edu has address 128.208.203.143</code></pre><p>The iSchool host name resolves to two addresses, but other domain names might resolve to even more possible addresses. For example, try <code>uw.edu</code> instead. It should return several IP addresses, any of which can be used by a web client.</p><p>Mac and Linux users can also use the more powerful <code>dig</code> command to see details about the query sent to the DNS and its reply:</p><pre class="language-bash"><code class="language-bash"><span class="token function">dig</span> ischool.uw.edu</code></pre><p>These commands talk to the DNS, but they also consult a hosts file on your local computer that contains well-known host names and their associated IP addresses. On Mac and Linux, this file is at <code>/etc/hosts</code>, and on Windows it's at <code>c:\Windows\System32\Drivers\etc\hosts</code>. To see the contents of this file use this command:</p><pre class="language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># on Mac and Linux</span>
<span class="token function">cat</span> /etc/hosts

<span class="token comment" spellcheck="true"># on Windows</span>
<span class="token function">cat</span> c:\Windows\System32\Drivers\etc\hosts </code></pre><p>You'll probably have at least one line in that file that defines the host <code>localhost</code> to be the IPv4 address <code>127.0.0.1</code>, and possibly another line that defines the IPv6 address to be <code>::1</code>. These are known as "loopback addresses" because they just loop back to the same machine from which the request is made: your local computer. Thus, the host <code>localhost</code> is an alias for your computer.</p><h3 id="secport">Port</h3><p>The host and associated IP address can get you connected to a server across the Internet, but that server might be listening for network requests on many different ports. You can think of an IP address like the street address of an apartment building, while the <strong>port number</strong> is the number of a specific apartment inside. To connect to a web server, we need both the host/IP and a port number.</p><p>As a convention, web servers listen on port <code>80</code> for unencrypted HTTP requests, and port <code>443</code> for encrypted HTTPS requests. If you don't specify a port number in your URL, the browser will assume these conventional ports. But you can override this by including a port number in your URL, like so: <code>http://localhost:4000/path/to/resource</code>. This tells the client to connect to port <code>4000</code> instead of the conventional port <code>80</code>.</p><h3 id="secorigin">Origin</h3><p>A quick aside: the combination of the protocol, host, and port defines an <strong>origin</strong> in HTTP. Origins are the primary security boundary within the browser. Data written to local storage can be read only by code served from the same origin. Cookies are automatically sent during requests to the same origin from which the cookie came, but never to other origins. By default, HTTP requests initiated from JavaScript are limited to the same origin from which the JavaScript came (see the <a href="../cors/">CORS</a> tutorial for more details on how to override this on the server).</p><h3 id="secresourcepath">Resource Path</h3><p>After the host and optional port number, the segment up until the <code>?</code> is known as the <strong>resource path</strong>. Technically, this can take any form that the server knows how to interpret, so it doesn't strictly need to look like a file path, but that path syntax is useful for modeling any set of hierarchically-organized resources.</p><p>Although this looks like a file path, it's critical for server-side development to understand that <strong>it can refer to anything the server can manipulate</strong>: a file, a database table/record, an in-memory game state, a neural network, a connected device, or even a controller for a giant mechanical killer robot. The term "resource" is purposely vague and open-ended so that one can enable the manipulation of <a href="https://en.wikipedia.org/wiki/Hyper_Text_Coffee_Pot_Control_Protocol">just about anything via HTTP requests</a>.</p><h3 id="secquerystringparametersandvalues">Query String, Parameters, and Values</h3><p>The last part of the URL above contains the <strong>query string</strong>, which allows the client to pass additional parameters and values that are relevant for the requested resource. These parameters are typically used only when getting the state of the resource, and they are often used to supply filters, sorts, or other options supported by the resource. For example, when getting the <code>/users</code> resource, which represents all user accounts in the system, one might supply a query string like <code>?q=dave&amp;max=50</code> to find the first 50 users with the name <code>dave</code>.</p><p>The query string starts with a <code>?</code> and is followed by one or more name/value pairs. The name/value pairs are separated by <code>&amp;</code>. The name and value are separated by <code>=</code>. For obvious reasons, literal <code>&amp;</code> and <code>=</code> characters within parameter names or values must be encoded as <code>%26</code> and <code>%3D</code> respectively, and a literal <code>%</code> must be encoded as <code>%25</code>. The number after the <code>%</code> is the hex representation of the character's Unicode number. The <code>encodeURIComponent()</code> function in JavaScript can be used to do this encoding in the browser, and similar functions are available in most other languages.</p><p>Technically speaking, <code>- _ . ! ~ * ' ( )</code> and space must also be encoded, as well as characters outside the ASCII range, but most client libraries handle this for you, so you rarely need to worry about this.</p><h2 id="sechttprequests">HTTP Requests</h2><p>Now that we have our terms straight, let's see how these URL elements are used in an HTTP request.</p><p><img src="img/req-get.png" alt="http get request format"></p><p>HTTP 1.1 requests are just plain text, so you can easily read and type them. The first line (simply called the "request line") contains the <strong>method</strong>, <strong>resource path</strong> (which we already discussed <a href="#secresourcepath">earlier</a>), and requested <strong>protocol version</strong>.</p><h3 id="secmethodsandresources">Methods and Resources</h3><p>The core philosophy of HTTP is that clients invoke <em>methods</em> on <em>resources</em>. The resource is the object and the method is the verb. Or to put it another way, the resource path identifies a thing the server can manage, and the method specifies an action the server should take on that resource.</p><p>There are several methods defined in the HTTP standard, and the most commonly-used are as follows:</p><table class="table is-striped"><thead><tr><th>method</th><th>meaning</th></tr></thead><tbody><tr><td>GET</td><td>return the current state of the resource</td></tr><tr><td>PUT</td><td>completely replace the current state of the resource</td></tr><tr><td>PATCH</td><td>partially update the current state of the resource</td></tr><tr><td>POST</td><td>add a new child resource</td></tr><tr><td>DELETE</td><td>delete the resource</td></tr><tr><td>LINK</td><td>link the resource to some other resource</td></tr><tr><td>UNLINK</td><td>unlink the resource from some other resource</td></tr><tr><td>OPTIONS</td><td>list the methods the current user is allowed to use on this resource</td></tr></tbody></table><p>Servers may choose to support other methods, including custom methods they define. This is generally fine, but sometimes you can run into troubles if there is a proxy server in the middle that rejects requests with non-standard methods for security reasons. In that case, developers commonly use <code>POST</code> with a query string parameter or other custom header that indicates what the real method is.</p><h3 id="secprotocolversion">Protocol Version</h3><p>The request line ends with a protocol version the client wishes to speak. HTTP, like all standards, is an evolving one, and there have been a few versions of HTTP defined over the years. The example above uses <a href="https://tools.ietf.org/html/rfc2616">HTTP/1.1</a> which is widely supported, but <a href="https://developers.google.com/web/fundamentals/performance/http2/">HTTP/2.0</a> has now been defined and support for it is growing.</p><p>By allowing clients to request a particular protocol version, servers and clients can start supporting the newer version while still being able to fall back to the older version if the other side doesn't yet support the new version. For example, a client can request <code>HTTP/2.0</code> but the server can reply saying it only supports <code>HTTP/1.1</code>. The client can then gracefully downgrade and use the 1.1 version for the rest of the conversation.</p><h3 id="secheaders">Headers</h3><p>The next lines in the request specify one or more <strong>headers</strong>. A header is a name/value pair, like a parameter, that provides some additional meta-data about the request. The <code>Host</code> header is required on all requests and must be set to the <a href="#sechost">host name</a> the client thinks it is talking to. This allows a single server to host several different web sites at the same time: it can use the <code>Host</code> header to determine which site the client is requesting.</p><p>The HTTP specification defines several <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">standard headers</a>. The ones you will most commonly use when making requests are as follows:</p><table class="table is-striped"><thead><tr><th>header</th><th>meaning</th></tr></thead><tbody><tr><td>Authorization</td><td>Some sort of token that identifies an authenticated session or a user account. The server defines what it accepts in this header.</td></tr><tr><td>Content-Length</td><td>If you are sending content to the server, this specifies how many bytes you are sending. This is typically set for you automatically by the library you use to make the request. This tells the server how much data to expect so it knows when its done reading the request off the network.</td></tr><tr><td>Content-Type</td><td>If you are sending content, this specifies the <a href="https://en.wikipedia.org/wiki/Media_type">MIME type</a> you are using for that data (e.g., JSON, XML, HTML, or some sort of media type).</td></tr><tr><td>Cookie</td><td>A value the server provided in the <code>Set-Cookie</code> response header during a previous request. Cookies are handled automatically within the browser and by most HTTP client libraries that offer a "cookie jar" implementation.</td></tr><tr><td>If-Modified-Since</td><td>If set to a date/time, the server will respond with the resource's state only if that state has been modified since the specified date/time. Useful when requesting large resources that don't change very often (video, large images, etc).</td></tr></tbody></table><h2 id="secletstryit">Let's Try It!</h2><p>As noted earlier, HTTP/1.1 is just plain text so you can manually type HTTP requests at the command line. So let's do it! We will use the <code>nc</code> (netcat) command to manually send an HTTP request to Google's web server and view the responses.</p><p>Open a new command line window. If you're on Mac or Linux, you already have the <code>nc</code> command installed. If you're on Windows and if you have Docker installed, you can run a BusyBox Linux container and use the <code>nc</code> command from within the container. To run a BusyBox container, use this command (requires Docker):</p><pre class="language-bash"><code class="language-bash">docker run -it --rm busybox</code></pre><p>Now use the <code>nc</code> command to connect to port 80 on Google's web server, and then type the remaining two lines of text exactly as you see them below. After the second line hit Enter twice to send a blank line, which signals the end of your request.</p><pre class="language-bash"><code class="language-bash">nc www.google.com 80
GET / HTTP/1.1
Host: www.google.com</code></pre><p>After you send the blank line it should respond with a standard HTTP response message followed by a bunch of HTML. That's Google's home page! You requested the resource path <code>/</code>, which is the home page for the entire web site.</p><p>Hit <code>Ctrl+c</code> to exit out of netcat and return to your own command prompt.</p><p>What you just did is what your web browser does when you enter <code>http://www.google.com/</code> into the address bar. The browser parses the URL and determines that the protocol is <code>http</code>, the host is <code>www.google.com</code> and the resource path is <code>/</code>. It then opens a network connection to port 80 (default for HTTP) on <code>www.google.com</code> and sends at least those two lines (most browsers include a bunch more headers that provide the server with extra meta-data).</p><h2 id="sechttpresponses">HTTP Responses</h2><p>After making your request, the server will respond with a message that looks something like this:</p><p><img src="img/resp.png" alt="HTTP response message format"></p><p>The first line tells the client what version of the protocol the server is using, as well as the response status code and message.</p><h3 id="secstatuscodes">Status Codes</h3><p>The status code tells the client whether the request was successful or not. There are several <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">status codes defined in the HTTP standard</a>, but they bucket into the following ranges:</p><table class="table is-striped"><thead><tr><th>range</th><th>meaning</th></tr></thead><tbody><tr><td>100-199</td><td>still working on it, more to come</td></tr><tr><td>200-299</td><td>successful</td></tr><tr><td>300-399</td><td>request the URL in the <code>Location</code> response header instead</td></tr><tr><td>400-499</td><td>client made a bad request</td></tr><tr><td>500-599</td><td>something went wrong on the server-side</td></tr></tbody></table><p>Most HTTP client libraries will handle 100 and 300-range status codes automatically, so your client-side code only has to deal with 200, 400, and 500-range codes. In general, you should treat any code &gt;= 400 as an error, but note that these error-range codes are distinct from a network error: if the host is unreachable you will get a network error and no response at all.</p><p>The message that follows the status code is mostly redundant, but it's helpful in cases where a service defines new non-standard status codes, such as those defined in the now famous <a href="https://en.wikipedia.org/wiki/Hyper_Text_Coffee_Pot_Control_Protocol">HyperText Coffee Pot Control Protocol</a> (check out the meaning of <a href="https://tools.ietf.org/html/rfc2324#section-2.3.2">status code 418</a>).</p><h3 id="secresponseheaders">Response Headers</h3><p>Similar to requests, HTTP responses also contain one or more headers. These headers can provide additional meta-data about the response. The most commonly-used ones are as follows:</p><table class="table is-striped"><thead><tr><th>header</th><th>meaning</th></tr></thead><tbody><tr><td>Content-Type</td><td>The <a href="https://en.wikipedia.org/wiki/Media_type">MIME type</a> used for the data in the response body. For example <code>application/json; charset=utf-8</code> means that the response body contains data encoded into JSON using the <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8 character set</a>.</td></tr><tr><td>Content-Length</td><td>The number of bytes the server is sending in the response body.</td></tr><tr><td>Expires and Cache-Control</td><td>Specifies if and for how long the client may cache the response body.</td></tr><tr><td>Last-Modified</td><td>The date/time the resource was last modified (can be used in the <code>If-Modified-Since</code> header during subsequent requests for this resource if the server says its OK to cache the response).</td></tr><tr><td>Location</td><td>For 300-range (Redirect) responses, a URL that the client should ask for instead; for 201 (Created) responses, the URL for the newly-created resource.</td></tr><tr><td>Retry-After</td><td>The number of seconds, or a specific date/time, after which the client may ask for the resource. This is commonly returned when the server is throttling requests and the client makes too many within a given time period. The client should wait until the Retry-After time before making another request.</td></tr><tr><td>Set-Cookie</td><td>A cookie value that should be sent back in the <code>Cookie</code> header with all subsequent requests to this same origin. Cookies are handled automatically in the browser and by most HTTP client libraries that support a "cookie jar" implementation.</td></tr></tbody></table><h3 id="secresponsebody">Response Body</h3><p>Following the response headers is the response body. For a <code>GET</code> request, this will be the current state of the requested resource, encoded in the MIME type specified in the <code>Content-Type</code> response header. The number of bytes in the response body is indicated by the <code>Content-Length</code> header. If the server doesn't know the final total size, but still wants to start writing the data is has, the server can use <a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding">chunked transfer encoding</a>, which involves writing chunks of data at a time, each proceeded by a content length.</p><h2 id="sechttp2">HTTP/2</h2><p>The examples so far have been in version 1.1 of HTTP, which uses simple plain-text, human-readable messages. Although these plain text messages make the protocol easy to see and understand, they are not as efficient as a more-compact, binary protocol would be. These inefficiencies led many browser and server vendors to experiment with binary protocols (e.g., SPDY), which eventually became the basis for a new version 2.0 of HTTP, known as <a href="https://http2.github.io/">HTTP/2</a>. This version is now supported by all the major browser vendors, as well as more recent web servers (e.g., NGINX has supported it since version 1.9.5 released in September 2016, and the web server in the Go standard library has supported it since Go 1.6 was released in February 2016).</p><p>Although HTTP/2 is no longer human-readable, it still retains all the same concepts outlined in this tutorial. The developer tools within the browsers will still show you all the request and response headers, bodies, and status codes, but on the wire they are encoded into a very company binary format. This should increase the overall speed of requests/responses, while also reducing the number of bytes that have to be transmitted across our networks.</p><p>For more details, see the <a href="https://tools.ietf.org/html/rfc7540">HTTP/2 specification (RFC 7540)</a>.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script></body></html>