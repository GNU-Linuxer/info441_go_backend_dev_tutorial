<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Sharing Values with Go Handlers"><meta property="og:description" content="How to make global values available to your HTTP handler functions"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Sharing Values with Go Handlers</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px;margin-bottom:1em}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-SQFSBJB996"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-SQFSBJB996")</script></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Sharing Values with Go Handlers</h1><p class="subtitle">How to make global values available to your HTTP handler functions</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Oct 23, 2021 by <a href="https://www.linkedin.com/in/david-stearns-09a27319">Dave Stearns</a></p><p>HTTP handler functions in Go must have a very particular signature: <code>func(http.ResponseWriter, *http.Request)</code>. The web server implementation in the standard library needs to call these functions, so they must conform to a type declared in the <code>http</code> package, and that type only allows for those two parameters. But what if those handler functions need access to some values that are created and initialized during your program's <code>main()</code> function? For example, what if they need to use a database connection that is created and initialized based on environment variables read at startup?</p><p>There are four possible approaches I know of, but only two that I recommend, and one that I prefer. Let's look at each of them so that you can see why I recommend the ones I do.</p><h2 id="secglobalvariables">Global Variables</h2><p>The first possible but very flawed approach is to use global variables that are initialized during your <code>main()</code> function, and read by your handler functions. Although this would work, it's not a good idea, and professional developers will chastise you for doing it. The primary reason is that global variables obfuscate the dependencies between different parts of your code.</p><p>The Go compiler can catch a wide range of programming errors because the language is statically-typed, but it can't ensure that a global variable is initialized before it is used, nor that it never gets used after it is cleared. This makes it easy to forget that the global needs initialization, or to introduce subtle runtime bugs that only show up under particular circumstances.</p><p>For example, say you used a global to hold your MongoDB master session, initialized it during your <code>main()</code> function, and then used it in your handlers. Now say that you add lots of other time-consuming initialization code to your <code>main()</code> function, so you decide to move the initialization code into a separate goroutine so that it runs concurrently. You've now introduced a subtle timing bug: if the web server starts and receives a request before your initialization code finishes, your handler function will try to use an uninitialized global variable, and generate a panic.</p><p>The root problem here is that your handler function is not making its dependencies explicit in a way that's obvious to other developers, nor in a way the compiler can enforce. A better approach is to use a technique where your handler function can't be added to the server mux without receiving references to the global values it needs.</p><h2 id="sechttphandlerimplementations">http.Handler Implementations</h2><p>One way to make your dependencies obvious and force (or at least encourage) initialization is to make all of your handlers be structs that implement the <a href="https://golang.org/pkg/net/http/#Handler">http.Handler</a> interface instead of simple handler functions. As discussed in the <a href="../goweb/">Go Web Servers</a> tutorial, a handler can either be a simple function with the signature <code>func(http.ResponseWriter, *http.Request)</code>, or it can be a struct that implements the <code>http.Handler</code> interface. Since a struct must be created and initialized before it's used, we can add fields to that struct for each value our handler needs.</p><p>For example, a set of handlers that all need an <code>*mgo.Session</code> to talk to a MongoDB server could be written like this:</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> MyHandler <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Session <span class="token operator">*</span>mgo<span class="token punctuation">.</span>Session
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>MyHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...use h.Session to query the database...</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> MyOtherHandler <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Session <span class="token operator">*</span>mgo<span class="token punctuation">.</span>Session
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>MyOtherHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...use h.Session to query the database...</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//dial MongoDB using environment variables</span>
    <span class="token comment" spellcheck="true">//to get the host address</span>
    mongosess<span class="token punctuation">,</span> err <span class="token operator">:=</span> mgo<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>

    mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//add an instance of MyHandler, </span>
    <span class="token comment" spellcheck="true">//initializing it with the mongo session</span>
    mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/some/api"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>MyHandler<span class="token punctuation">{</span>mongosess<span class="token punctuation">}</span><span class="token punctuation">)</span>
    mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/some/other/api"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>MyOtherHandler<span class="token punctuation">{</span>mongosess<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>This approach makes the dependencies much more explicit, but it also requires a lot more code. Instead of writing a single function per handler, we now have to declare a new struct type and a <code>ServeHTTP()</code> method for it. If you have ten handlers that all need that same <code>*mgo.Session</code>, you have to declare ten different struct types, each with a field for the session, and ten <code>ServeHTTP()</code> methods.</p><p>This approach also doesn't strictly require the code that creates an instance of <code>MyHandler</code> to initialize all the fields with valid values. If no values are included in the static initializer expression (e.g., <code>&amp;MyHandler{}</code>), the <code>Session</code> field will remain <code>nil</code>. If the <code>ServeHTTP()</code> method tries to use that field, it will generate a runtime panic, but not until that handler is first called. One could make the <code>Session</code> field unexported and provide a <code>NewMyHandler()</code> constructor function, but that would be even more code, as you'd have to write a constructor for every handler struct type.</p><h2 id="secclosures">Closures</h2><p>Another approach that allows you to check initialization at startup is to use closures. You might remember closures from JavaScript, but if you don't, they are created when a function is declared inside another function. The closure gives the inner function access to the stack of the outer function, which includes all of its parameters and local variables.</p><p>For example, instead of declaring <code>MyHandler</code> as a struct with fields for all the values the handler needs, we can create a function that accepts those values as parameters, checks them, and returns the actual HTTP handler function. The closure gives the HTTP handler function access to all of the parameters passed to the outer function. It would look something like this:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">MyHandler</span><span class="token punctuation">(</span>mongosess <span class="token operator">*</span>mgo<span class="token punctuation">.</span>Session<span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> mongosess <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"nil MongoDB session!"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//use `mongosess` to access the database</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">MyOtherHandler</span><span class="token punctuation">(</span>mongosess <span class="token operator">*</span>mgo<span class="token punctuation">.</span>Session<span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> mongosess <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"nil MongoDB session!"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//use `mongosess` to access the database</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mongosess<span class="token punctuation">,</span> err <span class="token operator">:=</span> mgo<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
    mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//call functions passing the session,</span>
    <span class="token comment" spellcheck="true">//and pass their return values to HandleFunc()</span>
    mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/some/api"</span><span class="token punctuation">,</span> <span class="token function">MyHandler</span><span class="token punctuation">(</span>mongosess<span class="token punctuation">)</span><span class="token punctuation">)</span>
    mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/some/api"</span><span class="token punctuation">,</span> <span class="token function">MyOtherHandler</span><span class="token punctuation">(</span>mongosess<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>This requires less code than the handler struct approach, and it allows us to check the values of our dependencies at startup. Instead of passing a reference to the <code>MyHandler</code> function to <code>mux.HandleFunc()</code>, we <em>call</em> <code>MyHandler()</code> passing the parameters it wants. It then <em>returns</em> a reference to the actual HTTP handler function, which gets passed to <code>mux.HandleFunc()</code>. Since functions are values, we can return a function from a function, thereby creating a closure!</p><p>If you have many HTTP handler functions that all need the same values, you can create just one outer function that returns a map, slice, or struct containing all of your HTTP handler functions. This would allow you to check the values just once, but the code in your <code>main()</code> function would have to capture the return value and read from it while adding the handler functions to the mux.</p><p>This technique works quite well, and it's one that I recommend, but I have found that some inexperienced developers are confused by closures and thus tend to make mistakes when using them. Thankfully, there's one more approach that is easier to understand, and works just as well.</p><h2 id="secreceivers">Receivers</h2><p>As I discussed in the <a href="../golang/#secreceivers">Go Language</a> tutorial, a function can have one "receiver" parameter, which is essentially like the <code>this</code> keyword in object-oriented languages. Receivers are used to add methods to a type, typically a struct type. The methods use the receiver parameter to reference the current value of the struct fields.</p><p>Interestingly, this receiver is not considered to be part of the function's type. That means an HTTP handler function can have a receiver and still match the type <code>func(http.ResponseWriter, *http.Request)</code>, which is what the <code>.HandleFunc()</code> method wants. This further means that we can add the same receiver type to many HTTP handler functions, and they all can use that receiver to reference the same values.</p><p>I call this receiver type the "handler context" because it defines a context within which the handler function is called. Continuing with our MongoDB session example, the handler context struct would look like this:</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> HandlerContext <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    mongosess <span class="token operator">*</span>mgo<span class="token punctuation">.</span>Session
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//NewHandlerContext constructs a new HandlerContext,</span>
<span class="token comment" spellcheck="true">//ensuring that the dependencies are valid values</span>
<span class="token keyword">func</span> <span class="token function">NewHandlerContext</span><span class="token punctuation">(</span>mongosess <span class="token operator">*</span>mgoSession<span class="token punctuation">)</span> <span class="token operator">*</span>HandlerContext <span class="token punctuation">{</span>
    <span class="token keyword">if</span> mongosess <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"nil MongoDB session!"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>HandlerContext<span class="token punctuation">{</span>mongosess<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>ctx <span class="token operator">*</span>HandlerContext<span class="token punctuation">)</span> <span class="token function">MyHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...use ctx.session to query the database...</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>ctx <span class="token operator">*</span>HandlerContext<span class="token punctuation">)</span> <span class="token function">MyOtherHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...use ctx.session to query the database...</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mongosess<span class="token punctuation">,</span> err <span class="token operator">:=</span> mgo<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//construct the handler context</span>
    hctx <span class="token operator">:=</span> <span class="token function">NewHandlerContext</span><span class="token punctuation">(</span>mongosess<span class="token punctuation">)</span>

    mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//pass a reference to MyHandler and</span>
    <span class="token comment" spellcheck="true">//MyOtherHandler, bound to our</span>
    <span class="token comment" spellcheck="true">//handler context instance</span>
    mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span>hctx<span class="token punctuation">.</span>MyHandler<span class="token punctuation">)</span>  
    mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span>hctx<span class="token punctuation">.</span>MyOtherHandler<span class="token punctuation">)</span> 
<span class="token punctuation">}</span></code></pre><p>Here we declare a struct for the handler context, adding a field for each value the handlers need. We also provide a constructor function that checks the values before returning a new instance. We then add a receiver to each HTTP handler function, which is a pointer to one of these handler context structs. The HTTP hander functions can then reference any of the fields in the handler context struct.</p><p>When we add these HTTP handler functions to the mux, we prefix the function name with an instance of the handler context struct. This effectively binds the function to that struct instance. When the HTTP server calls the function, the receiver will already be set to the handler context instance, allowing the handler function to read all of its fields.</p><p>This approach works just as well (or in some cases better) than the closure approach, and many developers find it easier to understand. Thus, this is the approach I recommend the most.</p><h2 id="secrequestscopedvalues">Request-Scoped Values</h2><p>A final word of warning: these techniques are for values that are shared between all requests and not for values that are specific to a given request. For example, a connection to your persistent database is something that would typically be shared across all requests, while session state related to the value of the <code>Authorization</code> header is particular to the current request.</p><p>Values that are specific to a request are known as <strong>request-scoped values</strong> and these must be stored in the <a href="https://golang.org/pkg/net/http/#Request.Context">request context</a>. The Go web server processes requests concurrently, so it may invoke your handler multiple times at the same time. Since each request generates a new <code>http.Request</code> struct, you can safely store request-specific data in its context.</p><p>Request-scoped values are most typically used when implementing <a href="../gomiddleware/">middleware</a>, which is the subject of our next tutorial....</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://www.linkedin.com/in/david-stearns-09a27319">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script></body></html>