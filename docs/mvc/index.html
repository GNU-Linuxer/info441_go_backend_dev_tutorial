<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="The Model-View-Controller (MVC) Architecture"><meta property="og:description" content="How complex information applications are structured"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>The Model-View-Controller (MVC) Architecture</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px;margin-bottom:1em}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">The Model-View-Controller (MVC) Architecture</h1><p class="subtitle">How complex information applications are structured</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jan 14, 2018 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>In the <a href="../eventarch/">Event-Driven Architecture Tutorial</a> I showed how to build interactive web applications using event listener functions that modify the application's state and re-render that state to the page. That was a simple form of a much more pervasive and powerful architectural pattern known as Model-View-Controller (MVC). Most JavaScript application frameworks are based on some variation of the MVC pattern, so before we dive into learning React, we should try to understand the MVC pattern in general.</p><p>MVC was developed in the early days of personal desktop computers, graphical user interfaces (GUIs), and object-oriented programming (OOP). These new platforms enabled new kinds of interactive graphical applications that required new approaches to code architecture. It was not at all immediately obvious how one should architect something as complex as a spreadsheet or word processing application. Developers experimented with many options before eventually settling on the MVC pattern. It worked so well that it became the standard architecture for GUI applications. Once JavaScript and the DOM matured, the MVC pattern was applied to client-side web applications, resulting in several competing libraries/frameworks (e.g., React, Angular, Vue, etc.).</p><p>To understand MVC, let's look at each of the concepts in turn, and see how they are applied in a simple JavaScript application.</p><h2 id="secmodels">Models</h2><p>The <strong>Model</strong> part of Model-View-Controller refers to a data object that is being manipulated by the application. A model is simply an instance of a class (in the OOP sense) that is responsible for managing some chunk of data. It ensures that the data is created and modified correctly according to the rules of the application. In many MVC variants, the model is also responsible to raising events when the data inside the model changes.</p><p>Note that models only care about the data they manage. Models do not render that data to the screen, nor do they handle saving that data to some kind of persistent data store. Their only concern is managing their data and enforcing the application's rules regarding changes to those data. Models are the most narcissistic of objects: they only know and care about about themselves.</p><p>For example, if we were to build a simple task list application using the MVC architecture, we would define two models: <code>Task</code> and <code>TaskList</code>. The <code>Task</code> model would manage the data for a specific task and enforce rules (e.g., the task title must be non-blank). The <code>TaskList</code> would manage the overall list of tasks. Both models would also allow callers to add event listener functions that will be called whenever the data inside the model changes, similar to how the DOM allows us to add an event listener function that is called when users click on elements or press keys on the keyboard.</p><h2 id="secviews">Views</h2><p>A <strong>view</strong> is an object that is responsible for rendering a model to an output device (typically the screen, but perhaps a printer). The view doesn't manage the data: that's the model's job. The view just reads the data from the model and renders it to the output device. It also listens for change events raised by the model and automatically re-renders itself whenever the model changes.</p><p>How the view renders the model is up to the view. For example, a <code>TaskListView</code> might render a <code>TaskList</code> model as a simple bulleted list, but a <code>TaskCalendarView</code> might render the <code>TaskList</code> as a set of events on a calendar, and a <code>TaskSummaryView</code> might render some summary statistics like the number of completed and uncompleted tasks. All of those views could render the same <code>TaskList</code> in different ways, and all of them could render to the screen at the same time. Since they are rendering the same model, any changes to that model would cause all views to automatically re-render so that they always show the correct up-to-date data.</p><h2 id="seccontrollers">Controllers</h2><p>A <strong>controller</strong> is an object that is responsible for loading/saving models from/to persistent storage, and connecting those models to views. In the original MVC architecture, the controller was also the component responsible for handling user events and updating the models in response. In more recent variations of MVC, the views assume that responsibility, as they are the ones creating the on-screen elements, and are thus better equipped to handle the events raised by those elements. In this newer style, views know about models, but they do not know anything about the controllers that connect them to those models.</p><p>The following illustrates these relationships:</p><p><img src="img/mvc.png" alt="mvc architectural diagram"></p><h2 id="secmvcinjavascript">MVC in JavaScript</h2><p>Let's see how this architecture would be applied to a web application written in JavaScript.</p><h3 id="secmodels-1">Models</h3></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>