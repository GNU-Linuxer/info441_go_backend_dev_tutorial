<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Protecting Data Structures with Mutexes"><meta property="og:description" content="How to make a complex data structure safe for concurrent use"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Protecting Data Structures with Mutexes</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px;margin-bottom:1em}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-SQFSBJB996"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-SQFSBJB996")</script></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Protecting Data Structures with Mutexes</h1><p class="subtitle">How to make a complex data structure safe for concurrent use</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Oct 23, 2021 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>A Go web server processes each new HTTP request on a new <strong>goroutine</strong>, which is an independent thread of execution. These goroutines are multiplexed on top of operating system threads, and if your CPU has multiple cores, several goroutines may be executing simultaneously, in parallel. Even if you have only on CPU core, the goroutines are still executing independently of each other, so the CPU may suspend one goroutine at any time and switch to executing another.</p><p>All of this concurrent execution is great for throughput and resource utilization, but it does pose a problem when we want to share complex data structures across multiple HTTP requests, and thus multiple goroutines. For example, if we want to use a single <a href="../trie">trie index</a> during concurrent requests, multiple goroutines might be executing the code that manipulates the trie node tree at the same time. If we're not careful, we could easily corrupt the node tree.</p><p>For example, consider this scenario:</p><ul><li>the web server starts with an empty <a href="../trie/">trie</a></li><li>a new request A is received that starts to add a new key <code>"go"</code> to the trie</li><li>a new request B is received that starts to add a new key <code>"git"</code> to the trie</li><li>request A determines that the root node has no child node for the letter <code>"g"</code> and enters the <code>if</code> block where it will create a new child and add it to the root node, but it is suspended before it can add the new child</li><li>request B starts to execute, determines that the root has no child node for the letter <code>"g"</code>, and completes the <code>if</code> block where it creates a new child and adds it to the root node</li><li>request B is suspended and request A resumes execution</li><li>request A is still inside the <code>if</code> block, so it creates a new child for <code>"g"</code> and tries to add it to the root node</li></ul><p>At this point something bad is about to happen. The link to the child node added by request B will probably be overwritten, causing the entire branch under that node to be lost and garbage collected.</p><p>A custom structure like a trie is not the only complex data structure in Go that is subject to this problem. <strong>The built-in slice and map types are also not safe for concurrent use</strong>. You cannot share a slice or map between multiple goroutines without risking a race condition resulting in data corruption and loss.</p><blockquote><p><strong>Note:</strong> If you only read from a data structure, and never change its state after it is initialized, it is safe to share it between multiple concurrent goroutines. But if you ever write to that structure or do anything with it that could change its state from multiple concurrent goroutines, you must use one of the synchronization features to protect it from concurrent use.</p></blockquote><h2 id="secsynchronization">Synchronization</h2><p>Preventing this sort of problem requires some way to <strong>synchronize</strong> multiple concurrent threads of execution. Go provides a few different mechanisms for doing that, but the one that would make the most sense for a shared data structure like a trie is a <strong>mutex</strong>, which is short for a "<strong>mut</strong>ual <strong>ex</strong>clusion lock." As the name implies, a mutex provides an exclusive lock that only one goroutine can obtain at a time.</p><p>The Go standard library provides two different kinds of mutexes in the <code>sync</code> package: a traditional <a href="https://golang.org/pkg/sync/#Mutex">Mutex</a> with one exclusive lock; and a <a href="https://golang.org/pkg/sync/#RWMutex">RWMutex</a> with separate read versus write locks.</p><h2 id="secusingamutex">Using a Mutex</h2><p>A <code>sync.Mutex</code> object represents a single mutually exclusive lock. Only one goroutine at a time will be able to obtain the lock. While a goroutine has the lock, all other goroutines attempting to obtain that same lock will be blocked until the mutex is unlocked by the goroutine that has the lock. This effectively allows you to create sections of code that only one goroutine may execute at a time.</p><p>For example, say we wanted to implement a simple stack data structure using a Go slice. As noted above, slices are not safe for concurrent use, but we can make them so by wrapping them with another object that also has a mutex.</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Stack represents a stack data structure</span>
<span class="token comment" spellcheck="true">//that is safe for concurrent use.</span>
<span class="token keyword">type</span> Stack <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    entries <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>   <span class="token comment" spellcheck="true">//slice for the entries</span>
    mx      sync<span class="token punctuation">.</span>Mutex <span class="token comment" spellcheck="true">//mutex to protect the slice</span>
<span class="token punctuation">}</span></code></pre><p>Note how we used lower-case names for the struct fields. This makes them unexported so that code in other packages cannot access them directly. This forces developers using this data structure to use the exported methods, which will ensure the mutex is used to protect the slice.</p><p>Next we add <code>.Push()</code> and <code>.Pop()</code> methods to that struct. Since both of these will manipulate the slice, they must use the mutex to obtain an exclusive lock before referencing the slice, and release that lock when they are done.</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Push pushes a new entry on to the stack</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Stack<span class="token punctuation">)</span> <span class="token function">Push</span><span class="token punctuation">(</span>entry <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//obtain the exclusive lock</span>
    s<span class="token punctuation">.</span>mx<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//append the new entry to the slice</span>
    s<span class="token punctuation">.</span>entries <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>entries<span class="token punctuation">,</span> entry<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//release the exclusive lock</span>
    s<span class="token punctuation">.</span>mx<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//Pop pops the last entry off of the stack</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Stack<span class="token punctuation">)</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//obtain the exclusive lock</span>
    s<span class="token punctuation">.</span>mx<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//use defer to ensure that we release the lock, </span>
    <span class="token comment" spellcheck="true">//regardless of how we exit this function</span>
    <span class="token keyword">defer</span> s<span class="token punctuation">.</span>mx<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//if there are no entries, just return ""</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>entries<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">""</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//get the last entry in the slice</span>
    e <span class="token operator">:=</span> s<span class="token punctuation">.</span>entries<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>entries<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token comment" spellcheck="true">//remove that entry from the slice</span>
    s<span class="token punctuation">.</span>entries <span class="token operator">=</span> s<span class="token punctuation">.</span>entries<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>entries<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token comment" spellcheck="true">//return the entry</span>
    <span class="token keyword">return</span> e
<span class="token punctuation">}</span></code></pre><p>In the <code>Push()</code> method, we obtain the exclusive lock, append the new entry, and then release the lock. Since the mutex is exclusive, this guarantees that only one goroutine at a time will execute the line <code>s.entries = append(s.entries, entry)</code>.</p><p>Notice that in the <code>Pop()</code> method we used the <code>defer</code> keyword to ensure that the mutex lock is released, even if we exit the function early in the case of an empty slice. The statement following the <code>defer</code> keyword will be executed as we exit the function, regardless of how we exited it.</p><p>This <code>Stack</code> data structure can now be used by multiple goroutines at the same time without any concerns about data loss or corruption.</p><h2 id="secusinganrwmutex">Using an RWMutex</h2><p>A traditional Mutex is appropriate when you must synchronize all access to your data structure, such as in our Stack example above. But in other cases you may want to allow multiple concurrent readers while still synchronizing writers. In this case, you should use the <code>sync.RWMutex</code> instead.</p><p>An <code>RWMutex</code> actually has two locks: an exclusive write lock, and a non-exclusive read lock. Multiple goroutines can obtain the non-exclusive read lock at the same time, but only one goroutine can obtain the exclusive write lock at a time, and only if there are no current readers. When a goroutine attempts to obtain the exclusive write lock, it is blocked until the write lock is available <strong>and</strong> all existing readers have released their locks. When an exclusive write lock is pending, new readers are blocked from obtaining new read locks so that the pending writer has a chance to get what it needs. After the writer obtains and releases the exclusive write lock, the new readers are unblocked and are allowed to obtain their read locks.</p><p>An <code>RWMutex</code> is the better choice when you expect many more read operations than write operations. Since it allows multiple concurrent readers, those more common read operations will happen concurrently, giving you better throughput and performance. When you do need to change the state of your data structure, your code can still obtain an exclusive write lock that synchronizes access while you modify the state.</p><p>For example, say we wanted to use a map to cache frequently accessed data, and we wanted to share that map across multiple goroutines. Since maps are not safe for concurrent access, we need to protect it. But since we expect many more read operations than write operations, we should protect it using an <code>RWMutex</code> instead of the traditional mutex.</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Cache represents a cache of strings to ints that is</span>
<span class="token comment" spellcheck="true">//safe for concurrent use.</span>
<span class="token keyword">type</span> Cache <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    entries <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment" spellcheck="true">//map to store the entries</span>
    mx      sync<span class="token punctuation">.</span>RWMutex   <span class="token comment" spellcheck="true">//RWMutex to protect the map</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//NewCache constructs a new Cache</span>
<span class="token keyword">func</span> <span class="token function">NewCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Cache <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>Cache<span class="token punctuation">{</span>
        entries<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>We start by defining a new struct type like we did with the Stack example, but this time we use a <code>sync.RWMutex</code> instead of a <code>sync.Mutex</code>. We also define a constructor function, as the entries map must be initialized before it is used.</p><p>Next we add <code>.Set()</code> and <code>.Get()</code> methods to the struct. The <code>.Set()</code> method uses the exclusive write lock while the <code>.Get()</code> method uses the non-exclusive read lock.</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Set adds a new key and value to the map</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cache<span class="token punctuation">)</span> <span class="token function">Set</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">,</span> value <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//obtain an exclusive lock</span>
    c<span class="token punctuation">.</span>mx<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//set the key/value in the map</span>
    c<span class="token punctuation">.</span>entries<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
    <span class="token comment" spellcheck="true">//release the exclusive lock</span>
    c<span class="token punctuation">.</span>mx<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//Get retrieves the value for a given key</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cache<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//obtain a read lock</span>
    c<span class="token punctuation">.</span>mx<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//use defer to release the read lock</span>
    <span class="token comment" spellcheck="true">//as we exit the function</span>
    <span class="token keyword">defer</span> c<span class="token punctuation">.</span>mx<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//return the value from the map</span>
    <span class="token keyword">return</span> c<span class="token punctuation">.</span>entries<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre><p>Just as in the Stack example, the exclusive lock guarantees that the line <code>c.entries[key] = value</code> will be executed by only one goroutine at a time, which is what we want. But the non-exclusive read lock in the <code>.Get()</code> method can be obtained by multiple goroutines at the same time, so multiple readers can lookup the value for a key at the same time while there are no writers. Once a writer obtains the exclusive lock, however, calls to <code>c.mx.RLock()</code> will block until the writer releases the exclusive lock. Thus the exclusive lock synchronizes both writers and readers.</p><h2 id="secalookaheadtochannels">A Look Ahead to Channels</h2><p>Mutexes provide a simple way to protect a single data structure from concurrent use, but they can get hard to reason about as your structure becomes more complicated, or as you combine them with others to create assemblages like job queues with multiple concurrent workers.</p><p>For these more complex cases, Go offers another synchronization mechanism called <a href="https://tour.golang.org/concurrency/2">channels</a>. A channel is like a synchronized message box you can use to pass messages safely from one goroutine to another. One goroutine puts a message into the box, and another goroutine reads that message out of the box. The box can accept only one message at a time, or it can be configured to hold multiple messages in a queue. If the box is full, the goroutine writing messages blocks until another goroutine reads a message out of the box. If the box is empty, the goroutine reading messages blocks until a message is written to the box. Thus channels provide a way to not only pass messages safely between goroutines, but also synchronize those goroutines at various points in their execution.</p><p>Implementing something like <a href="https://en.wikipedia.org/wiki/MapReduce">MapReduce</a> or a job queue with multiple worker goroutines is far easier to do with channels than with mutexes. We will see how to do such things in a future tutorial.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script></body></html>