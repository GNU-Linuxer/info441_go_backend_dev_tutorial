<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Middleware Patterns in Go"><meta property="og:description" content="How to do pre and post-processing on all requests"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Middleware Patterns in Go</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px;margin-bottom:1em}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Middleware Patterns in Go</h1><p class="subtitle">How to do pre and post-processing on all requests</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Apr 15, 2018 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>So far you've seen how to build a <a href="../goweb/">Go web server</a> that routes requests to different functions depending on the requested URL. But what if you want execute some code before and after <em>every</em> request, regardless of the requested URL? For example, what if you wanted to log all requests made to your server, or allow all of your APIs to be callable <a href="../cors/">cross-origin</a>, or ensure that the current user has authenticated before calling the handler for a secure resource? We can do all of these things easily and efficiently using a middleware handler.</p><p>A <strong>middleware handler</strong> is simply an <code>http.Handler</code> that wraps another <code>http.Handler</code> to do some pre- and/or post-processing of the request. It's called "middleware" because it sits in the middle between the Go web server and the actual handler.</p><p><img src="img/flow.png" alt="architectural diagram showing middleware in the request/response flow"></p><h2 id="secloggingmiddleware">Logging Middleware</h2><p>To see how this works, let's build a simple web server with a logging middleware handler. Create a new directory inside your <code>$GOPATH/src</code> directory, and create a file within that directory named <code>main.go</code>. Add this code to that file:</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"log"</span>
    <span class="token string">"net/http"</span>
    <span class="token string">"os"</span>
    <span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">HelloHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">CurrentTimeHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    curTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Kitchen<span class="token punctuation">)</span>
    w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"the current time is %v"</span><span class="token punctuation">,</span> curTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    addr <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"ADDR"</span><span class="token punctuation">)</span>

    mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/v1/hello"</span><span class="token punctuation">,</span> HelloHandler<span class="token punctuation">)</span>
    mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/v1/time"</span><span class="token punctuation">,</span> CurrentTimeHandler<span class="token punctuation">)</span>

    log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"server is listening at %s"</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> mux<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>You can run this server by setting the <code>ADDR</code> environment variable and using <code>go run main.go</code>:</p><pre class="language-bash"><code class="language-bash"><span class="token function">export</span> ADDR<span class="token operator">=</span>localhost:4000
go run main.go</code></pre><p>Once the server is running, you can open <a href="http://localhost:4000/v1/hello">http://localhost:4000/v1/hello</a> in your browser to see the <code>HelloHandler()</code> response, and <a href="http://localhost:4000/v1/time">http://localhost:4000/v1/time</a> to see the <code>CurrentTimeHandler()</code> response.</p><p>Now suppose we want to log all requests made to this server, listing the request method, resource path, and how long it took to handle. We could add similar code to every handler function, but it would be much better if we could handle that logging in just one place. We can use a middleware handler to do just that.</p><p>Start by defining a new struct that implements the <code>ServeHTTP()</code> method of the <a href="https://golang.org/pkg/net/http/#Handler">http.Handler</a> interface. The struct should have a field to track the real <code>http.Handler</code>, which it will call in between the pre- and post-processing of the request.</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Logger is a middleware handler that does request logging</span>
<span class="token keyword">type</span> Logger <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    handler http<span class="token punctuation">.</span>Handler
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//ServeHTTP handles the request by passing it to the real</span>
<span class="token comment" spellcheck="true">//handler and logging the request details</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>Logger<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    l<span class="token punctuation">.</span>handler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s %s %v"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Method<span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//NewLogger constructs a new Logger middleware handler</span>
<span class="token keyword">func</span> <span class="token function">NewLogger</span><span class="token punctuation">(</span>handlerToWrap http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span> <span class="token operator">*</span>Logger <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>Logger<span class="token punctuation">{</span>handlerToWrap<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>The <code>NewLogger()</code> constructor function takes an <code>http.Handler</code> to wrap and returns a new <code>Logger</code> instance wrapped around it. Since an <code>http.ServeMux</code> satisfies the <code>http.Handler</code> interface, you can wrap an entire mux with the logger middleware. And since <code>Logger</code> implements the <code>ServeHTTP()</code> method, it also satisfies the <code>http.Handler</code> interface, so you can pass it to the <code>http.ListenAndServe()</code> function instead of the mux you wrapped. Change your <code>main()</code> function to look like this:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    addr <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"ADDR"</span><span class="token punctuation">)</span>

    mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/v1/hello"</span><span class="token punctuation">,</span> HelloHandler<span class="token punctuation">)</span>
    mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/v1/time"</span><span class="token punctuation">,</span> CurrentTimeHandler<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//wrap entire mux with logger middleware</span>
    wrappedMux <span class="token operator">:=</span> <span class="token function">NewLogger</span><span class="token punctuation">(</span>mux<span class="token punctuation">)</span>

    log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"server is listening at %s"</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//use wrappedMux instead of mux as root handler</span>
    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> wrappedMux<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>Now restart your web server and re-request your APIs. Because we wrapped the entire mux, you should see all requests logged to your terminal, regardless of which resource path is requested!</p><h2 id="secchainingmiddleware">Chaining Middleware</h2><p>Because every middleware constructor both accepts and returns an <code>http.Handler</code>, you can chain multiple middleware handlers together. For example, say we also want to add a header to all responses written by all of the handlers added to that mux. We would first create another middleware handler.</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//ResponseHeader is a middleware handler that adds a header to the response</span>
<span class="token keyword">type</span> ResponseHeader <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    handler http<span class="token punctuation">.</span>Handler
    headerName <span class="token builtin">string</span>
    headerValue <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//NewResponseHeader constructs a new ResponseHeader middleware handler</span>
<span class="token keyword">func</span> <span class="token function">NewResponseHeader</span><span class="token punctuation">(</span>handlerToWrap http<span class="token punctuation">.</span>Handler<span class="token punctuation">,</span> headerName <span class="token builtin">string</span><span class="token punctuation">,</span> headerValue <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>ResponseHeader <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>ResponseHeader<span class="token punctuation">{</span>handlerToWrap<span class="token punctuation">,</span> headerName<span class="token punctuation">,</span> headerValue<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//ServeHTTP handles the request by adding the response header</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>rh <span class="token operator">*</span>ResponseHeader<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//add the header</span>
    w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>rh<span class="token punctuation">.</span>headerName<span class="token punctuation">,</span> rh<span class="token punctuation">.</span>headerValue<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//call the wrapped handler</span>
    rh<span class="token punctuation">.</span>handler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>To use this and the logger middleware handler at the same time, just wrap one around the other:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...existing code...</span>

    <span class="token comment" spellcheck="true">//wrap entire mux with logger and response header middleware</span>
    wrappedMux <span class="token operator">:=</span> <span class="token function">NewLogger</span><span class="token punctuation">(</span><span class="token function">NewResponseHeader</span><span class="token punctuation">(</span>mux<span class="token punctuation">,</span> <span class="token string">"X-My-Header"</span><span class="token punctuation">,</span> <span class="token string">"my header value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"server is listening at %s"</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//use wrappedMux instead of mux as root handler</span>
    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> wrappedMux<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>You can chain together as many middleware handlers as you want by wrapping each around the others. This works fine when you have only a few middleware handlers (which is typical), but if you find yourself adding many, you should try the <a href="https://medium.com/@matryer/writing-middleware-in-golang-and-how-go-makes-it-so-much-fun-4375c1246e81">Adapter pattern</a> outlined in Mat Ryer's excellent article <a href="https://medium.com/@matryer/writing-middleware-in-golang-and-how-go-makes-it-so-much-fun-4375c1246e81">Writing Middleware in #golang and how Go makes it so much fun</a>. The Adapter pattern can be difficult to understand, but it allows you to chain many middleware handlers together in a very elegant way.</p><h2 id="secmiddlewareandrequestscopedvalues">Middleware and Request-Scoped Values</h2><p>Now let's consider a slightly more complicated example. Say we have several handlers that all require an authenticated user, and let's also say that we have a function that can return that authenticated user or an error from an <code>http.Request</code>. For example:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">GetAuthenticatedUser</span><span class="token punctuation">(</span>r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>User<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//validate the session token in the request,</span>
    <span class="token comment" spellcheck="true">//fetch the session state from the session store,</span>
    <span class="token comment" spellcheck="true">//and return the authenticated user</span>
    <span class="token comment" spellcheck="true">//or an error if the user is not authenticated</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">UsersMeHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    user<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">GetAuthenticatedUser</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"please sign-in"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusUnauthorized<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//GET = respond with current user's profile</span>
    <span class="token comment" spellcheck="true">//PATCH = update current user's profile</span>
<span class="token punctuation">}</span></code></pre><p>The <code>UsersMeHandler()</code> needs the currently authenticated user, so it calls <code>GetAuthenticatedUser()</code> and handles any errors that are returned. This works fine, but what if we start adding more handlers that also require the currently authenticated user? We could duplicate this block of code at the start of every handler, but duplicating code is never a good idea. Instead, let's use a middleware handler to ensure that the user is authenticated before calling the ultimate handler.</p><p>We can start by defining a middleware handler similar to those above:</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> EnsureAuth <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    handler http<span class="token punctuation">.</span>Handler
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>ea <span class="token operator">*</span>EnsureAuth<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    user<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">GetAuthenticatedUser</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"please sign-in"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusUnauthorized<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//TODO: call the real handler, but how do we share the user?</span>
    ea<span class="token punctuation">.</span>handler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">NewEnsureAuth</span><span class="token punctuation">(</span>handlerToWrap http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span> <span class="token operator">*</span>EnsureAuth <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>EnsureAuth<span class="token punctuation">{</span>handlerToWrap<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>The <code>ServeHTTP()</code> method starts with that same block of code, and if <code>GetAuthenticatedUser()</code> returns an error, our middleware handler will respond and never call the real handler. But we still have a problem: how do we share the <code>user</code> variable with the real handler?</p><p>Since this value is specific to the request, we don't want to share it using the techniques discussed in the <a href="../gohandlerctx/">Sharing Values with Go Handlers Tutorial</a>, as those are for values shared amongst all requests. Instead, we should store this user in the <strong>request context</strong>.</p><p>Request contexts were introduced in Go version 1.7, and they allow several advanced techniques, but the one we are concerned with here is the storage of <strong>request-scoped values</strong>. The request context gives us a spot to store and retrieve key/value pairs that stay with the <code>http.Request</code> object. Since a new instance of that object is created at the start of every request, anything we put into it will be particular to the current request.</p><p>Start by defining a key type and value for the authenticated user we need to store:</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> contextKey <span class="token builtin">int</span>
<span class="token keyword">const</span> authenticatedUserKey contextKey <span class="token operator">=</span> <span class="token number">0</span></code></pre><p>And now use them in the <code>ServeHTTP()</code> method of our middleware handler to add the currently authenticated user to the request context:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>ea <span class="token operator">*</span>EnsureAuth<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    user<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">GetAuthenticatedUser</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"please sign-in"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusUnauthorized<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//create a new request context containing the authenticated user</span>
    ctxWithUser <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> authenticatedUserKey<span class="token punctuation">,</span> user<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//create a new request using that new context</span>
    rWithUser <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">WithContext</span><span class="token punctuation">(</span>ctxWithUser<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//call the real handler, passing the new request</span>
    ea<span class="token punctuation">.</span>handler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> rWithUser<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>Note that putting the user into the request context involves creating a new context based on the current one, adding the user to it as a value, and creating a new request object with that new context. We then pass that new request to the real handler so that it can retrieve the value from the context. This ensures that middleware handlers earlier in the chain don't see these values when our middleware handler returns.</p><p>Retrieving the value in our handler function looks like this:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">UsersMeHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//get the authenticated user from the request context</span>
    user <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>authenticatedUserKey<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>User<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//do stuff with that user...</span>
<span class="token punctuation">}</span></code></pre><p>Here we use the <code>authenticatedUserKey</code> constant to retrieve the value from the context, but the return type of the <code>.Value()</code> method is <code>interface{}</code>. Recall that the empty interface type (<code>interface{}</code>) in Go is like the <code>Object</code> type in Java: it allows us to store any type we want, but to do anything with that value when we retrieve it, we must cast it back into the real type. In Go, we do a <a href="https://tour.golang.org/methods/15"><strong>type assertion</strong></a>, which the last bit of that line: <code>.(*User)</code>. This checks the real type of the value, and if it is <code>*User</code>, it assigns that type to our <code>user</code> variable.</p><h3 id="secanalternative">An Alternative</h3><p>The syntax for storing and retrieving request-scoped values is a bit clumsy-looking, and it tends to obscure dependencies, so <a href="https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39">some developers have argued against using it</a>. Instead, they advocate modifying the function signature of handlers that require additional request-scoped values. If these handler functions truly require these values, then they should make those dependencies explicit, and require some sort of middleware adapter when being added to a web server mux.</p><p>For example, our <code>UsersMeHandler()</code> from above could be changed to look like this:</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">UsersMeHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">,</span> user <span class="token operator">*</span>User<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//do stuff with the `user`...</span>
<span class="token punctuation">}</span></code></pre><p>Adding this extra parameter means that this function no longer conforms to the HTTP handler function signature, so to use this with an <code>http.ServeMux</code>, we need to adapt it. We could do this using a slightly modified version of the middleware handler above:</p><pre class="language-go"><code class="language-go"><span class="token comment" spellcheck="true">//authenticatedHandler is a handler function that also requires a user</span>
<span class="token keyword">type</span> AuthenticatedHandler <span class="token keyword">func</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">,</span> <span class="token operator">*</span>User<span class="token punctuation">)</span>

<span class="token keyword">type</span> EnsureAuth <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    handler AuthenticatedHandler
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>ea <span class="token operator">*</span>EnsureAuth<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    user<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">GetAuthenticatedUser</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"please sign-in"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusUnauthorized<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

    ea<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">,</span> user<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">NewEnsureAuth</span><span class="token punctuation">(</span>handlerToWrap AuthenticatedHandler<span class="token punctuation">)</span> <span class="token operator">*</span>EnsureAuth <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>EnsureAuth<span class="token punctuation">{</span>handlerToWrap<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Here we define a new type for an <code>AuthenticatedHandler</code>, which is a handler function that takes one additional parameter of type <code>*User</code>. We then change our <code>EnsureAuth</code> middleware to wrap one of these authenticated handler functions rather than an <code>http.Handler</code>. Our <code>ServeHTTP()</code> method can then simply pass the user to the authenticated handler function as a third parameter.</p><p>The slight drawback to this approach is that <code>EnsureAuth</code> is now an adapter that must be wrapped around every authenticated handler function as we add it to a mux. For example, this is how we would use it in the <code>main()</code> function:</p><pre class="language-go"><code class="language-go">mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/v1/users/"</span><span class="token punctuation">,</span> <span class="token function">NewEnsureAuth</span><span class="token punctuation">(</span>UsersHandler<span class="token punctuation">)</span><span class="token punctuation">)</span>
mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/v1/users/me"</span><span class="token punctuation">,</span> <span class="token function">NewEnsureAuth</span><span class="token punctuation">(</span>UsersMeHandler<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Instead of wrapping an entire mux just once, we have to wrap each of our authenticated handler functions as we add them to the mux. This is because the <code>.HandleFunc()</code> method requires a function with only two parameters, not three.</p><p>This slight drawback could be overcome by creating your own <code>AuthenticatedServeMux</code> struct, with methods that accept <code>AuthenticatedHandler</code> functions instead of the normal HTTP handler functions. You could then create an instance of this authenticated mux, add all of your authenticated handlers to it, and then add the authenticated mux to the main server mux.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>