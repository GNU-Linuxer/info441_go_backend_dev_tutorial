<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Cross-Origin Resource Sharing"><meta property="og:description" content="Enable JavaScript from different origins to call your APIs"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Cross-Origin Resource Sharing</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Cross-Origin Resource Sharing</h1><p class="subtitle">Enable JavaScript from different origins to call your APIs</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Jul 16, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><blockquote><p><strong>WARNING:</strong> this tutorial assumes you have a good working knowledge of HTTP. If you don't, read the <a href="../http/">HTTP tutorial</a> first.</p></blockquote><p>Back in the early 2000s, web browsers started allowing JavaScript to make HTTP requests without requiring a page navigation. This was very exciting, as it enabled a new form of web application that felt more like a native desktop application. But the browser vendors faced a difficult question: should we allow JavaScript to make requests to a different <a href="../http/#secorigin">origin</a> than the origin the current page came from? In other words, should JavaScript loaded into a page served from <code>example.com</code> be able to make HTTP requests to <code>example.com:4000</code> or <code>api.example.com</code> or even <code>some-other-domain.com</code>?</p><p>On the one hand, browsers have always allowed page authors to include images and script files served from other origins: this was how one could include a JavaScript library file hosted on a <a href="https://en.wikipedia.org/wiki/Content_delivery_network">Content Delivery Network (CDN)</a>. Fetching these resources resulted in an HTTP request to a different origin, so why not let JavaScript do that directly?</p><p>On the other hand, there were some very significant security concerns with allowing cross-origin requests initiated from JavaScript. Many sites use cookies to track authenticated sessions, and browsers automatically send any cookies they have for an origin when they make a request to it. If a user was signed-in to a sensitive site like their bank, and if that user was lured to a malicious page on <code>evil.com</code>, JavaScript within that page could easily make HTTP requests to the user's bank, and the browser would happily send along the authenticated session cookie. Thus the malicious page could conduct transactions on the user's behalf without the user even knowing that it's occurring.</p><p>Not surprisingly, the browser vendors decided to restrict cross-origin HTTP requests made from JavaScript. This posed issues for emerging web services that wanted to provide APIs that were callable from any web application, regardless of what origin the application came from.</p><p>Several creative hacks were developed to make this possible, the most popular being the <a href="https://en.wikipedia.org/wiki/JSONP">JSONP technique</a>. But these were always acknowledged as short-term hacks that needed to be replaced by a long-term solution. The great minds of the Web got together to figure out how to enable open API servers without compromising security. The result was the <a href="https://www.w3.org/TR/cors/">Cross-Origin Resource Sharing</a> standard, more commonly referred to as CORS.</p><h2 id="sechowcorsworks">How CORS Works</h2><p>The CORS standard defines new HTTP headers and some rules concerning how browsers and servers should use those headers to negotiate a cross-origin HTTP request from JavaScript. The rules discuss two different scenarios: simple requests; and more dangerous requests that require a separate preflight authorization request.</p><h3 id="secsimplerequests">Simple Requests</h3><p>Simple cross-origin requests are defined as follows:</p><ul><li>The method is GET, HEAD, or POST</li><li>The request may contain only <a href="https://www.w3.org/TR/cors/#terminology">"simple" headers</a>, such as <code>Accept</code>, <code>Accept-Language</code>, <code>Content-Type</code>, and <code>Viewport-Width</code>.</li><li>If a <code>Content-Type</code> header is included, it may only be one of the following:<ul><li><code>application/x-www-form-urlencoded</code> (format used when posting an HTML <code>&lt;form&gt;</code>)</li><li><code>multipart/form-data</code> (format used when posting an HTML <code>&lt;form&gt;</code> with <code>&lt;input type="file"&gt;</code> fields)</li><li><code>text/plain</code> (just plain text)</li></ul></li></ul><p>If JavaScript in a page makes an HTTP request that meets these conditions, the browser will send the request to the server, adding an <code>Origin</code> header set to the current page's origin. The server may use this <code>Origin</code> request header to determine where the request came from, and decide if it should process the request.</p><p>If the server does process the request and responds with a 200 (OK) status code, it must also include a response header named <code>Access-Control-Allow-Origin</code> set to the value in the <code>Origin</code> request header, or <code>*</code>. This tells the browser that it's OK to let the client-side JavaScript see the response.</p><p><img src="img/cors-simple.png" alt="simple CORS request flow"></p><p>This header protects older servers that were built before the CORS standard, and are therefore not expecting cross-origin requests to be allowed. Since this header was defined with the CORS standard, older servers will not include it in their responses, so the browser will block the client-side JavaScript from seeing those responses.</p><p>Supporting simple cross-origin requests on the server-side is therefore as simple as adding one header to your response: <code>Access-Control-Allow-Origin: *</code>. If you want to restrict access to only a small set of white-listed origins, you can compare the <code>Origin</code> request header against that list and respond accordingly.</p><h3 id="secpreflightrequests">Preflight Requests</h3><p>If the client-side JavaScript makes a cross-origin request that doesn't conform to the restrictive "simple request" criteria, the browser does some extra work to determine if the request should be sent to the server. The browser sends what's known as a "preflight request," which is a separate HTTP request for the same resource path, but using the <code>OPTIONS</code> HTTP method instead of the actual request method. The browser also adds the following headers to the preflight request:</p><ul><li><code>Origin</code> set to the origin of the current page.</li><li><code>Access-Control-Request-Method</code> set to the method the JavaScript is attempting to use in the actual request.</li><li><code>Access-Control-Request-Headers</code> set to a comma-delimited list of non-simple headers the JavaScript is attempting to include in the actual request.</li></ul><p>When the server receives the preflight request, it can examine these headers to determine if the actual request should be allowed. If so, the server should respond with a 200 (OK) status code, and include the following response headers:</p><ul><li><code>Access-Control-Allow-Origin</code> set to the value of the <code>Origin</code> request header, or <code>*</code> (same as in simple request).</li><li><code>Access-Control-Allow-Methods</code> set to a comma-delimited list of HTTP methods the server will allow on the requested resource.</li><li><code>Access-Control-Allow-Headers</code> set to a comma-delimited list of non-simple headers the server will allow in a request for the resource.</li><li><code>Access-Control-Expose-Headers</code> set to a comma-delimited list of <strong>response</strong> headers the browser should expose to the JavaScript if the actual request is sent. If you want the JavaScript to access one of your non-simple response headers (e.g., <code>Authorization</code>), you must include that header name in this list. Otherwise the header simply won't be in the response headers returned to the client-side JavaScript.</li><li><code>Access-Control-Allow-Credentials</code> set to <code>true</code> if the server will allow the browser to send cookies during the actual request. If omitted or set to <code>false</code>, the browser will not include cookies in the actual request.</li><li><code>Access-Control-Max-Age</code> set to the maximum number of seconds the browser is allowed to cache and reuse this preflight response if the JavaScript makes additional non-simple requests for the same resource. This cuts down on the amount of preflight requests, especially for client applications that make repeated requests to the same resources.</li></ul><p>All of the following must be true for the browser to then send the actual request to the server:</p><ul><li>The <code>Access-Control-Allow-Origin</code> response header matches <code>*</code> or the value in the <code>Origin</code> request header.</li><li>The actual request method is found in the <code>Access-Control-Allow-Methods</code> response header.</li><li>The non-simple request headers are all found in the <code>Access-Control-Allow-Headers</code> response header.</li></ul><p>If any of these are not true, the browser doesn't send the actual request and instead generates an HTTP error.</p><p><img src="img/cors-preflight.png" alt="preflight CORS request flow"></p><h2 id="seccorsandcsrfattacks">CORS and CSRF Attacks</h2><p>Supporting CORS naturally exposes your server to Cross-Site Request Forgery (CSRF) attacks, especially if your site uses cookies for authentication. Once you support CORS, an attacker could lure one of your authenticated users to a malicious web page, and use JavaScript in that web page to access your server's APIs on the user's behalf. If the malicious developer sets the <code>.withCredentials</code> property on the <code>XMLHttpRequest</code> object, or sets the <code>credentials</code> property in the options passed to the new <code>fetch()</code> API, the browser will send all stored cookies for the target origin with the request, with no warning shown to the user.</p><p>The easiest way to protect against a CSRF attack is to simply not use cookies for authentication tokens. Cookies are set using the <code>Set-Cookie</code> response header, and provided in requests using the <code>Cookie</code> header, and both of these are automatically handled by the browser. If you use some other header that is not automatically handled, such as <code>Authorization</code>, the attacker would have to explicitly set that header to the user's current authentication token. Since these tokens are typically stored in Local Storage, and since JavaScript from one origin can't read the Local Storage belonging to another origin, the attacker has no way to access the authentication token, and therefore can't send it with the request.</p><p>If you still want to use cookies, and still want to support requests from any origin, there are a few other techniques you can use, including <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#Synchronizer_.28CSRF.29_Tokens">synchronizer tokens</a>, <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#Double_Submit_Cookie">double submit cookies</a>, and the <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#Encrypted_Token_Pattern">encrypted token pattern</a>.</p><h2 id="seccorsmiddlewareingo">CORS Middleware in Go</h2><p>If you are building a web server that exposes many APIs, and you want many or all of them to be callable from any origin, you will quickly notice that managing all of these headers requires a good bit of code that you don't want to repeat in every handler function. Thankfully we can use a technique called "middleware" to handle this logic in one place.</p><p>A middleware handler is simply an <code>http.Handler</code> that wraps another <code>http.Handler</code> to do some pre- and/or post-processing of the request. It's called "middleware" because it sits in the middle between the Go web server and the actual handler.</p><p>A CORS middleware handler would look something like this:</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> CORSHandler <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Handler http<span class="token punctuation">.</span>Handler
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>ch <span class="token operator">*</span>CORSHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//use the `Origin` and `Access-Control-Request-*` headers to</span>
    <span class="token comment" spellcheck="true">//determine if this request should be allowed</span>
    <span class="token comment" spellcheck="true">//for example...</span>
    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Origin"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"http://evil.com"</span> <span class="token punctuation">{</span>
        http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"sorry, no evil requests"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusUnauthorized<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//set the various CORS response headers depending on</span>
    <span class="token comment" spellcheck="true">//what you want your server to allow</span>
    w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Origin"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//...more CORS response headers...</span>

    <span class="token comment" spellcheck="true">//if this is preflight request, the method will</span>
    <span class="token comment" spellcheck="true">//be OPTIONS, so call the real handler only if</span>
    <span class="token comment" spellcheck="true">//the method is something else</span>
    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Method <span class="token operator">!=</span> <span class="token string">"OPTIONS"</span> <span class="token punctuation">{</span>
        ch<span class="token punctuation">.</span>Handler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">NewCORSHandler</span><span class="token punctuation">(</span>handlerToWrap http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span> <span class="token operator">*</span>CORSHandler <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>CORSHandler<span class="token punctuation">{</span>handlerToWrap<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>Since a <a href="../goweb/#secmuxes">mux</a> implements the <code>http.Handler</code> interface, you can use this <code>CORSHandler</code> to wrap an entire mux, thereby adding CORS support to all the handler functions that are added to that mux:</p><pre class="language-go"><code class="language-go">mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> HelloHandler<span class="token punctuation">)</span>
corsHandler <span class="token operator">:=</span> <span class="token function">NewCORSHandler</span><span class="token punctuation">(</span>mux<span class="token punctuation">)</span></code></pre><p>And since <code>CORSHandler</code> also implements <code>http.Handler</code>, you can pass the CORSHandler to the <code>http.ListenAndServe()</code> function as the root handler for the server:</p><pre class="language-go"><code class="language-go">log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> corsHandler<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>With this code, all requests will first go through the <code>CORSHandler.ServeHTTP()</code> method, and if the HTTP request method is something other than <code>OPTIONS</code>, the request will be sent on to the mux. The mux will then use the requested resource path to determine which handler function to call.</p><p>Middleware is a powerful concept that can be used whenever you want to do pre- or post-processing of a request. Since each middleware handler both accepts and is an <code>http.Handler</code>, you can combine multiple middleware handlers together into a chain of wrapped handlers, each of which get executed during each request.</p><p>For an elegant application of this technique, see Mat Ryer's excellent article <a href="https://medium.com/@matryer/writing-middleware-in-golang-and-how-go-makes-it-so-much-fun-4375c1246e81">Writing middleware in #golang and how Go makes it so much fun</a>.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>