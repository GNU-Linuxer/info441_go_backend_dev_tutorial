<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Cross-Origin Resource Sharing"><meta property="og:description" content="Enable JavaScript from different origins to call your APIs"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Cross-Origin Resource Sharing</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px;margin-bottom:1em}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-SQFSBJB996"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-SQFSBJB996")</script></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Cross-Origin Resource Sharing</h1><p class="subtitle">Enable JavaScript from different origins to call your APIs</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Oct 23, 2021 by <a href="https://www.linkedin.com/in/david-stearns-09a27319">Dave Stearns</a></p><blockquote><p><strong>WARNING:</strong> this tutorial assumes you have a good working knowledge of HTTP. If you don't, read the <a href="../http/">HTTP tutorial</a> first.</p></blockquote><p>Back in the early 2000s, web browsers started allowing JavaScript to make HTTP requests without requiring a page navigation. This was very exciting, as it enabled a new form of web application that felt more like a native desktop application. But the browser vendors faced a difficult question: should we allow JavaScript to make requests to a different <a href="../http/#secorigin">origin</a> than the origin the current page came from? In other words, should JavaScript loaded into a page served from <code>example.com</code> be able to make HTTP requests to <code>example.com:4000</code> or <code>api.example.com</code> or even <code>some-other-domain.com</code>?</p><p>On the one hand, browsers have always allowed page authors to include images and script files served from other origins: this was how one could include a JavaScript library file hosted on a <a href="https://en.wikipedia.org/wiki/Content_delivery_network">Content Delivery Network (CDN)</a>. Fetching these resources resulted in an HTTP request to a different origin, so why not let JavaScript do that directly?</p><p>On the other hand, there were some very significant security concerns with allowing cross-origin requests initiated from JavaScript. Many sites use cookies to track authenticated sessions, and browsers automatically send any cookies they have for an origin when they make a request to it. If a user was signed-in to a sensitive site like their bank, and if that user was lured to a malicious page on <code>evil.com</code>, JavaScript within that page could easily make HTTP requests to the user's bank, and the browser would happily send along the authenticated session cookie. Thus the malicious page could conduct transactions on the user's behalf without the user even knowing that it's occurring.</p><p>Not surprisingly, the browser vendors decided to restrict cross-origin HTTP requests made from JavaScript. This posed issues for emerging web services that wanted to provide APIs that were callable from any web application, regardless of what origin the application came from.</p><p>Several creative hacks were developed to make this possible, the most popular being the <a href="https://en.wikipedia.org/wiki/JSONP">JSONP technique</a>. But these were always acknowledged as short-term hacks that needed to be replaced by a long-term solution. The great minds of the Web got together to figure out how to enable open API servers without compromising security. The result was the <a href="https://www.w3.org/TR/cors/">Cross-Origin Resource Sharing</a> standard, more commonly referred to as CORS.</p><h2 id="sechowcorsworks">How CORS Works</h2><p>The CORS standard defines new HTTP headers and some rules concerning how browsers and servers should use those headers to negotiate a cross-origin HTTP request from JavaScript. The rules discuss two different scenarios: simple requests; and more dangerous requests that require a separate preflight authorization request.</p><h3 id="secsimplerequests">Simple Requests</h3><p>Simple cross-origin requests are defined as follows:</p><ul><li>The method is GET, HEAD, or POST</li><li>The request may contain only <a href="https://www.w3.org/TR/cors/#terminology">"simple" headers</a>, such as <code>Accept</code>, <code>Accept-Language</code>, <code>Content-Type</code>, and <code>Viewport-Width</code>.</li><li>If a <code>Content-Type</code> header is included, it may only be one of the following:<ul><li><code>application/x-www-form-urlencoded</code> (format used when posting an HTML <code>&lt;form&gt;</code>)</li><li><code>multipart/form-data</code> (format used when posting an HTML <code>&lt;form&gt;</code> with <code>&lt;input type="file"&gt;</code> fields)</li><li><code>text/plain</code> (just plain text)</li></ul></li></ul><p>If JavaScript in a page makes an HTTP request that meets these conditions, the browser will send the request to the server, adding an <code>Origin</code> header set to the current page's origin. The server may use this <code>Origin</code> request header to determine where the request came from, and decide if it should process the request.</p><blockquote><p><strong>NOTE:</strong> The inclusion of the POST method here opens up a possible attack vector that you must consider. It was included so that existing HTML forms that post cross-origin wouldn't break (e.g., a "contact us" form that posts to an emailing service). But this can be exploited by an attacker if the target of that POST wasn't meant to be called cross-origin. For example, there was a time when the Docker daemon accepted POST requests from the Docker CLI over HTTP, and the POST request conformed to this "simple request" definition: it didn't require any headers beyond those listed above, and it didn't require any post body. That meant that <em>any</em> JavaScript served from <em>any</em> origin could make an AJAX request to that same Docker daemon API! But that API was never meant to be callable cross-origin, so it created a gaping vulnerability. To make matters worse, the Docker daemon wasn't checking the <code>Origin</code> header to ensure the request actually came from the local CLI, and not a web page loaded from the Internet. Thankfully, some <a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Cherny-Well-That-Escalated-Quickly-How-Abusing-The-Docker-API-Led-To-Remote-Code-Execution-Same-Origin-Bypass-And-Persistence_wp.pdf">security researchers discovered this</a>, and Docker fixed the vulnerability. The moral of the story is, if your server supports simple POST requests that are not meant to be called cross-origin, you must check the <code>Origin</code> header and reject the request if it's not set to what you expect.</p></blockquote><p>If the server does process the request and responds with a 200 (OK) status code, it must also include a response header named <code>Access-Control-Allow-Origin</code> set to the value in the <code>Origin</code> request header, or <code>*</code>. This tells the browser that it's OK to let the client-side JavaScript see the response.</p><p><img src="img/cors-simple.png" alt="simple CORS request flow"></p><p>This header protects older servers that were built before the CORS standard, and are therefore not expecting cross-origin requests to be allowed. Since this header was defined with the CORS standard, older servers will not include it in their responses, so the browser will block the client-side JavaScript from seeing those responses.</p><p>Supporting simple cross-origin requests on the server-side is therefore as simple as adding one header to your response: <code>Access-Control-Allow-Origin: *</code>. If you want to restrict access to only a small set of white-listed origins, you can compare the <code>Origin</code> request header against that list and respond accordingly.</p><h3 id="secpreflightrequests">Preflight Requests</h3><p>If the client-side JavaScript makes a cross-origin request that doesn't conform to the restrictive "simple request" criteria, the browser does some extra work to determine if the request should be sent to the server. The browser sends what's known as a "preflight request," which is a separate HTTP request for the same resource path, but using the <code>OPTIONS</code> HTTP method instead of the actual request method. The browser also adds the following headers to the preflight request:</p><ul><li><code>Origin</code> set to the origin of the current page.</li><li><code>Access-Control-Request-Method</code> set to the method the JavaScript is attempting to use in the actual request.</li><li><code>Access-Control-Request-Headers</code> set to a comma-delimited list of non-simple headers the JavaScript is attempting to include in the actual request.</li></ul><p>When the server receives the preflight request, it can examine these headers to determine if the actual request should be allowed. If so, the server should respond with a 200 (OK) status code, and include the following response headers:</p><ul><li><code>Access-Control-Allow-Origin</code> set to the value of the <code>Origin</code> request header, or <code>*</code> (same as in simple request).</li><li><code>Access-Control-Allow-Methods</code> set to a comma-delimited list of HTTP methods the server will allow on the requested resource.</li><li><code>Access-Control-Allow-Headers</code> set to a comma-delimited list of non-simple headers the server will allow in a request for the resource.</li><li><code>Access-Control-Expose-Headers</code> set to a comma-delimited list of <strong>response</strong> headers the browser should expose to the JavaScript if the actual request is sent. If you want the JavaScript to access one of your non-simple response headers (e.g., <code>Authorization</code>), you must include that header name in this list. Otherwise the header simply won't be in the response headers returned to the client-side JavaScript.</li><li><code>Access-Control-Allow-Credentials</code> set to <code>true</code> if the server will allow the browser to send cookies during the actual request. If omitted or set to <code>false</code>, the browser will not include cookies in the actual request.</li><li><code>Access-Control-Max-Age</code> set to the maximum number of seconds the browser is allowed to cache and reuse this preflight response if the JavaScript makes additional non-simple requests for the same resource. This cuts down on the amount of preflight requests, especially for client applications that make repeated requests to the same resources.</li></ul><p>All of the following must be true for the browser to then send the actual request to the server:</p><ul><li>The <code>Access-Control-Allow-Origin</code> response header matches <code>*</code> or the value in the <code>Origin</code> request header.</li><li>The actual request method is found in the <code>Access-Control-Allow-Methods</code> response header.</li><li>The non-simple request headers are all found in the <code>Access-Control-Allow-Headers</code> response header.</li></ul><p>If any of these are not true, the browser doesn't send the actual request and instead generates an HTTP error.</p><p><img src="img/cors-preflight.png" alt="preflight CORS request flow"></p><h2 id="seccorsandcsrfattacks">CORS and CSRF Attacks</h2><p>Supporting CORS naturally exposes your server to Cross-Site Request Forgery (CSRF) attacks, especially if your site uses cookies for authentication. Once you support CORS, an attacker could lure one of your authenticated users to a malicious web page, and use JavaScript in that web page to access your server's APIs on the user's behalf. If the malicious developer sets the <code>.withCredentials</code> property on the <code>XMLHttpRequest</code> object, or sets the <code>credentials</code> property in the options passed to the new <code>fetch()</code> API, the browser will send all stored cookies for the target origin with the request, with no warning shown to the user.</p><p>The easiest way to protect against a CSRF attack is to simply not use cookies for authentication tokens. Cookies are set using the <code>Set-Cookie</code> response header, and provided in requests using the <code>Cookie</code> header, and both of these are automatically handled by the browser. If you use some other header that is not automatically handled, such as <code>Authorization</code>, the attacker would have to explicitly set that header to the user's current authentication token. Since these tokens are typically stored in Local Storage, and since JavaScript from one origin can't read the Local Storage belonging to another origin, the attacker has no way to access the authentication token, and therefore can't send it with the request.</p><p>If you still want to use cookies, and still want to support requests from any origin, there are a few other techniques you can use, including <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#Synchronizer_.28CSRF.29_Tokens">synchronizer tokens</a>, <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#Double_Submit_Cookie">double submit cookies</a>, and the <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#Encrypted_Token_Pattern">encrypted token pattern</a>.</p><h2 id="seccorsmiddlewareingo">CORS Middleware in Go</h2><p>If you are building a web server that exposes many APIs, and you want many or all of them to be callable from any origin, you will quickly notice that managing all of these headers requires a good bit of code that you don't want to repeat in every handler function. Thankfully we can use a technique called "middleware" to handle this logic in one place. For more details, see my <a href="../gomiddleware">Middleware in Go tutorial</a>.</p></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://www.linkedin.com/in/david-stearns-09a27319">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script></body></html>