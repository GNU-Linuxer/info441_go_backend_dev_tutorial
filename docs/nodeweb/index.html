<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><link rel="stylesheet" href="../lib/bulma.min.css"><link rel="stylesheet" href="../lib/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="../lib/prism.css"><link rel="icon" href="../img/page-icon.png"><meta property="og:type" content="website"><meta property="og:site_name" content="INFO Tutorials"><meta property="og:title" content="Node.js Microservices"><meta property="og:description" content="Building focused web services in JavaScript"><meta property="og:image" content="https://drstearns.github.io/tutorials/img/page-icon.png"><title>Node.js Microservices</title><style>.is-funky{background-image:linear-gradient(to right,#006064,#880E4F)}.is-funky .subtitle,.is-funky .title{color:#fff}.screenshot{border:1px dotted #ccc;padding:10px;margin-bottom:1em}.bookmark-link{color:#ddd;margin-left:.25em}.home-link{color:#eee}.home-link:hover{color:#fff}.byline{font-size:.85rem;font-style:italic}.shaded{background-color:#eee}</style></head><body><header><div class="hero is-funky"><div class="hero-body"><div class="container"><div class="columns is-mobile"><div class="column"><h1 class="title">Node.js Microservices</h1><p class="subtitle">Building focused web services in JavaScript</p></div><div class="column is-narrow"><a href=".." class="home-link"><span class="icon is-medium"><i class="fa fa-home" aria-hidden="true" aria-label="back to table of contents"></i></span></a></div></div></div></div></div></header><main class="section"><div class="container"><div class="content"><p class="byline">Last edited on Oct 26, 2017 by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a></p><p>You can build a web server in any language that allows you to listen on a port for HTTP requests, and respond accordingly. So far we've <a href="../goweb/">seen how to do that in Go</a>, but you can build web servers in many different languages, including JavaScript.</p><p>Some students find it difficult to understand how one could build a web <em>server</em> in JavaScript because their only use of JavaScript thus far has been in the web <em>browser</em>. But the web browser is only one possible execution environment for the JavaScript language. Shortly after Google open-sourced their V8 JavaScript interpreter, a few enterprising folks realized they could use it to run JavaScript at the command-line instead. And if they injected a few global functions and objects written in C, they could allow that JavaScript to do all kinds of fun things: read from/write to the file system; listen on network ports and respond to requests; make requests to other servers and process the results; etc.</p><p>The project was named "Node.js" because they wanted to use this runtime engine primarily for writing low-level network node services. But their first release in 2011 also included a basic HTTP server that allowed one to build a simple web service entirely in JavaScript.</p><p>Web server frameworks were quickly developed on top of this new exciting platform, the most popular of them being <a href="https://expressjs.com/">Express.js</a>, <a href="http://koajs.com/">Koa.js</a>, <a href="https://www.meteor.com/">Meteor</a>, <a href="https://hapijs.com/">hapi</a>, and <a href="http://sailsjs.com/">Sails</a>. These frameworks make it easier to build full-featured web servers on top of Node's somewhat minimalist HTTP module, so they are very commonly used.</p><h2 id="secgettingsetup">Getting Setup</h2><p>Since JavaScript is an interpreted language, the Node.js runtime must be installed on any machine that will run your code. Node.js also comes with the <code>npm</code> package manager, which helps you install various open-source packages, including the aforementioned frameworks like Express.js.</p><h3 id="secmacusers">Mac Users</h3><p>If you are on a Mac and you have <a href="https://brew.sh/">homebrew</a> installed, use it to install Node.js:</p><pre class="language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Mac users with Homebrew</span>
brew <span class="token function">install</span> node</code></pre><p>If you don't want to use homebrew, <a href="https://nodejs.org/en/download/current/">download and run the Node.js installer</a> for Mac.</p><h3 id="secwindowsusers">Windows Users</h3><p>If you are on Windows, <a href="https://nodejs.org/en/download/current/">download and run the Node.js installer</a> for Windows.</p><h3 id="seclinuxusers">Linux Users</h3><p>If you are on Linux, <a href="https://nodejs.org/en/download/package-manager/">follow the installation instructions for your distro</a>.</p><h2 id="secstartinganewproject">Starting a New Project</h2><p>Create a new directory somewhere on your development machine and <code>cd</code> into that directory (unlike Go, Node.js doesn't have a central workspace directory, so you can create this directory anywhere). To start a new Node.js project in that directory run this command:</p><pre class="language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># creates a new package.json file</span>
<span class="token function">npm</span> init -y</code></pre><p><code>npm</code> is the package manager installed with the Node.js runtime, and it has several sub-commands. The <code>init</code> command creates a new <code>package.json</code> file, which is used to track meta-data about your project (a "package" in npm-speak). By default it uses the directory name as your package name, and if that directory is a git repository, it will also add a <code>repository</code> key containing the URL to your <code>origin</code> remote (i.e., URL to your repo on GitHub). You should add and commit this file to your git repo.</p><p>This <code>package.json</code> file will also track all the other packages your package depends upon. So far that is blank, but let's add a few dependencies:</p><pre class="language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># installs packages and records dependencies in package.json</span>
<span class="token function">npm</span> <span class="token function">install</span> --save express morgan</code></pre><p>The <code>install</code> sub-command will download the packages you name from the <a href="https://www.npmjs.com/">central npm package repository</a> and install them into a <code>node_modules</code> sub-directory. These packages are just a bunch of JavaScript that someone else wrote, so you can look inside that directory and read all the code.</p><blockquote><p>Since anyone can publish packages to this repository, be careful how you spell the names of the packages you want to install. There have already been several <a href="https://www.theregister.co.uk/2017/08/02/typosquatting_npm/">typosquatting attacks</a> where developers published packages with names very similar to the most popular packages, but containing malicious code.</p></blockquote><p>The <code>--save</code> option not only downloads and installs the packages, but also adds them to the <code>dependencies</code> key in your <code>package.json</code> file. After you add/commit the updated <code>package.json</code> file to your repo, other developers will be able to know which packages this project depends upon. Those other developers will also be able to install all dependencies with the one simple command:</p><pre class="language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># installs all dependencies listed in package.json</span>
<span class="token function">npm</span> <span class="token function">install</span></code></pre><h2 id="secbuildinganhttpserver">Building an HTTP Server</h2><p>The two packages we installed above are as follows:</p><ul><li><code>express</code>: a popular web server framework that makes it easy to build HTTP servers</li><li><code>morgan</code>: express middleware that logs all requests</li></ul><p>As described in the <a href="../gomiddleware">Middleware Patterns in Go</a> tutorial, middleware is code that can do pre- and post-processing of every request. The Express.js framework has <a href="http://expressjs.com/en/guide/using-middleware.html">built-in support for middleware</a>, and there are <a href="http://expressjs.com/en/resources/middleware.html">many middleware packages</a> already in existence that do just about everything you'll ever need to do.</p><p>To see how you can use the Express.js framework and these middleware packages, let's create a simple HTTP server. Create a new file in your project directory named <code>index.js</code>, open it in your favorite code editor, and add this to it:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//put interpreter into strict mode</span>
<span class="token string">"use strict"</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//require the express and morgan packages</span>
<span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"express"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> morgan <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"morgan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//create a new express application</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Adding the <code>"use strict";</code> directive is always a good idea, as it <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">disables several forgiving JavaScript features</a> that make it very easy to introduce subtle bugs.</p><p>The <code>require()</code> function is a global function added by Node. This function loads packages from your <code>node_modules</code> sub-directory, or your own packages defined in other files. If the string you pass does not start with <code>./</code> or <code>../</code>, the function will look for a sub-directory within <code>node_modules</code> that matches the supplied name (e.g., <code>node_modules/express</code>). If the string does start with <code>./</code> or <code>../</code>, the function will treat that as a relative path to the other JavaScript module file.</p><p>The <code>require()</code> function loads the requested package and returns a reference to the package's exported API. This API might be a JavaScript object with several properties and methods, or it might be a single function. The <code>express</code> package exports a single function that you can use to create a new Express application, which is what we do in that last line.</p><p>Those familiar with ES6 features may wonder what the difference is between <code>require()</code> and the ES6 <code>export</code> and <code>import</code> module system. The Node.js project defined <code>require()</code> long before the ES6 module feature, so they are two separate things that achieve similar ends. The Node.js folks have written <a href="https://medium.com/the-node-js-collection/an-update-on-es6-modules-in-node-js-42c958b890c">a few articles detailing the problems with replacing the former with the later</a>, so it's unlikely to occur anytime soon. One can use <a href="https://babeljs.io/docs/plugins/transform-es2015-modules-commonjs/">Babel to transpile the latter to the former</a>, but it's easier to simply use the built-in <code>require()</code> function.</p><h3 id="secreadingenvironmentvariables">Reading Environment Variables</h3><p>Just as we did when we wrote web servers in Go, it's good practice to let those running your web server specify the network address at which the server should listen. An easy way to do that is via an environment variable. Node exposes all environment variables via the global <code>process.env</code> object. Each environment variable is a key on that object:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//get ADDR environment variable,</span>
<span class="token comment" spellcheck="true">//defaulting to ":80"</span>
<span class="token keyword">const</span> addr <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>ADDR <span class="token operator">||</span> <span class="token string">":80"</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//split host and port using destructuring</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>host<span class="token punctuation">,</span> port<span class="token punctuation">]</span> <span class="token operator">=</span> addr<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>After getting the <code>ADDR</code> environment variable, we use an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">ES6 destructuring assignment</a> to split apart the host and port segments of the address. The express application will make us pass these values separately to its <code>.listen()</code> method, so we have to split the address apart.</p><p>It's safe to use this new destructuring assignment because we control the version of the interpreter running our code, and <a href="http://node.green/">the current V8 interpreter supports destructuring</a>. It's also safe to destructure the result of <code>.split()</code> in JavaScript, even if the string doesn't contain the delimiter: asking for an array index that doesn't yet exist simply returns <code>undefined</code> in JavaScript, with no runtime error.</p><h3 id="secaddingthemiddleware">Adding the Middleware</h3><p>Next add the JSON body-parsing and request-logging middleware to your express application:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//add JSON request body parsing middleware</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//add the request logging middleware</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">morgan</span><span class="token punctuation">(</span><span class="token string">"dev"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Global middleware that should be invoked on every request are added using <code>app.use()</code>. The first one we add here is a middleware handler function that automatically parses any JSON that might be in the request body. The parsed JSON data will be available on the <code>.body</code> property of the request object, which all other handler functions can read. This particular middleware handler function is built-in to the express package since version 4.16.0.</p><blockquote><p><strong>NOTE:</strong> if you are using a version of express prior to 4.16.0, you must install the <code>body-parser</code> package and use the <code>bodyParser.json()</code> method to get this JSON-parsing middleware handler instead. For details on this package, see their <a href="https://github.com/expressjs/body-parser">API documentation</a>.</p></blockquote><p>The <code>morgan</code> package's <a href="https://github.com/expressjs/morgan#api">API</a> is a single function that takes a request logging format string, or a function that does custom formatting. In this case we use the predefined <code>"dev"</code> logging format, which provides colorful output that is helpful when doing development. The middleware handler function returned from <code>morgan("dev")</code> will log each request to standard out (i.e., your terminal, or wherever you've redirected standard out).</p><p>As opposed to middleware in Go, each of these middleware handler functions are being added to a chain of functions that are called during each request. When the first one finishes, it specifically tells Express to call the next function in the chain. If a handler function in the chain doesn't tell Express to call the next handler in the chain, the processing of the request ends.</p><h3 id="secaddingyourownhandlers">Adding Your Own Handlers</h3><p>Next add a handler for <code>GET</code> requests to the root resource path <code>/</code>:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//add handler for `GET /`</span>
app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"text/plain"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"Hello, Node.js!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Handlers are added by invoking a method on the application that has the same name as the HTTP method you want to handle: in this case <code>app.get()</code> for an HTTP <code>GET</code> request. The first parameter is the resource path you want to handle requests for, and the second is a JavaScript function that will be invoked when the server receives a request with the specified method for the specified resource path.</p><p>If you want your handler function to be called for <em>any</em> HTTP method, then call <code>app.use()</code> instead, but still pass the resource path as the first parameter. It will then be up to your code to examine the actual HTTP method on the request object.</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//handler for *any* HTTP method</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//req.method contains the actual request method</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//...cases for different methods</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>In Express, middleware and specific resource handler functions are really the same thing: they are just functions that take the three arguments: <code>req</code>, <code>res</code>, and <code>next</code>. If you add them with <code>app.use()</code> and don't supply a resource path in the first parameter, they are invoked on every request. If you use a specific HTTP method name, such as <code>app.get()</code>, then the handler functions are invoked only when the HTTP method matches that method name. If you provide a resource path as the first parameter, the handler functions are invoked only when the requested resource path matches the resource path you pass as the first parameter.</p><p>For the handler function itself, we are using an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">ES6 lambda-style function</a>, also known as an "arrow function." This is just new-fangled syntax for a more traditional in-line anonymous function, so the following is equivalent:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//equivalent to code above</span>
app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"text/plain"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"Hello, Node.js!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>NOTE:</strong> JavaScript lambda functions do have one important difference from traditional in-line anonymous functions: the <code>this</code> keyword is lexically-scoped in the former, where it's globally-scoped (by default) in the latter. In this case it doesn't matter, as we aren't using the <code>this</code> keyword in the handler function, and there would be little reason to do so.</p></blockquote><p>Express handler functions are passed three parameters:</p><ul><li><code>req</code>: an object containing <a href="https://expressjs.com/en/4x/api.html#req">information about the request</a></li><li><code>res</code>: an object that lets you <a href="https://expressjs.com/en/4x/api.html#res">send responses back to the client</a></li><li><code>next</code>: a function to call if you <a href="https://expressjs.com/en/guide/error-handling.html">encounter an error</a>, or if you want the remaining handler functions in the chain to be called.</li></ul><p>The <code>req</code> parameter is similar to the <code>*http.Request</code> in Go, and the <code>res</code> parameter is similar to the <code>http.ResponseWriter</code> in Go.</p><p>The <code>next</code> parameter is unique to Express: specific resource path handlers like this one typically handle the request and therefore don't need to invoke the next handler in the chain, so they only call <code>next()</code> to report an error. General middleware handlers added to the beginning of the chain call <code>next()</code> once they have finished their preprocessing work. This triggers Express to call the next handler in the chain, until some handler (like our specific resource path handler above) doesn't call <code>next()</code>. At that point, the request processing is finished.</p><h3 id="secstartlisteningforrequests">Start Listening for Requests</h3><p>After adding your various resource path handlers, the last thing to do is tell the application to listen on the requested host and port:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//start the server listening on host:port</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> host<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//callback is executed once server is listening</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`server is listening at http://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>addr<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">...`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Note that the <code>port</code> number comes first, followed by the <code>host</code>. You can omit the <code>host</code> parameter, and the server will then listen for requests sent to any host.</p><p>The last parameter can be a function that will be invoked once the server has bound to the port. Here we provide a function that simply writes a message to standard out that the server is listening at the requested address. We use the new <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">ES6 template strings</a> feature to dynamically insert the value of the <code>addr</code> variable into the middle of the string.</p><h2 id="sectryitout">Try it Out!</h2><p>At this point your script is ready to run. In your terminal, run these commands to start the server:</p><pre class="language-bash"><code class="language-bash"><span class="token function">export</span> ADDR<span class="token operator">=</span>localhost:4000
node index.js</code></pre><p>The first command sets the <code>ADDR</code> environment variable so that our server will listen on port 4000 and only accept requests through the loopback address. The second command runs our script using the Node.js runtime engine.</p><p>If you did everything correctly, you should see the message <code>server is listening at http://localhost:4000...</code> printed to your terminal, but you won't get your prompt back. Since the server is still running, it occupies that terminal window. You'll see the request logging messages printed there.</p><p>Now open <a href="http://localhost:4000">http://localhost:4000</a> in your web browser. You should see "Hello, Node.js!" as the response. Congratulations! You just wrote your first Node/Express web server!</p><p>To stop your server and get your command prompt back, switch back to your terminal window and hit <code>Ctrl+c</code>.</p><h2 id="secrespondingwithjson">Responding with JSON</h2><p>In the example above, we responded to the client with plain text, but Express also makes it very easy to respond with JSON instead. For example:</p><pre class="language-javascript"><code class="language-javascript">app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"/v1/channels"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//assuming some function that gets all</span>
    <span class="token comment" spellcheck="true">//of the defined channel records from the database </span>
    <span class="token keyword">let</span> allChannels <span class="token operator">=</span> <span class="token function">getAllChannelsFromDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//write those to the client, encoded in JSON</span>
    res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span>allChannels<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The <code>.json()</code> method on the response object accepts any value, runs it through <code>JSON.stringify()</code>, and writes the result to the client. It also sets the <code>Content-Type</code> header to <code>application/json</code> automatically, so you don't have to do that yourself.</p><h2 id="secresourcepathparameters">Resource Path Parameters</h2><p>When you specify a resource path when adding a handler function, that path can be a literal string, or a <a href="https://expressjs.com/en/guide/routing.html">regular expression</a>. You can also ask Express to accept any token for a path segment, and make the value of that token available in the handler function. For example, say you wanted to add a handler for the resource path <code>/channels/&lt;channel-id&gt;</code> where <code>&lt;channel-id&gt;</code> could be any valid channel ID. In express, you'd use a resource path like so:</p><pre class="language-javascript"><code class="language-javascript">app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"/channels/:chanid"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//actual channel ID value is in req.params.chanid</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"client asked for "</span> <span class="token operator">+</span> req<span class="token punctuation">.</span>params<span class="token punctuation">.</span>chanid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>A colon (<code>:</code>) in front of a path segment tells Express to accept any token in that segment, and make the actual token requested available on the <code>req.params</code> object. This object will have one key for each colon-prefixed path segment. The associated value will be whatever token was in the actual requested resource path.</p><h2 id="secasynchronousio">Asynchronous I/O</h2><p>Since JavaScript is single-threaded, Node.js forces you to do all I/O operations asynchronously. Every time you read from a file, read from the network, or talk to a database, it's done asynchronously. To get the results, you must supply a callback function, similar to how AJAX requests work in the browser.</p><p>Most of the <a href="https://nodejs.org/api/">core Node.js API functions</a> accept your callback function as the last parameter passed to the API function. This is fine for a single request, but it can lead to "callback hell" when you need to do several I/O operations in a row. In these cases, consider using the <a href="http://bluebirdjs.com/docs/getting-started.html">bluebird.js</a> library to wrap these sorts of APIs with <a href="https://drstearns.github.io/tutorials/ajax/#secasynchronousrequestsandpromises">Promises</a>.</p><p>Many of the popular NPM packages now return Promises from their APIs, which makes serializing several asynchronous requests into a chain much easier. If you've never used Promises before, see the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">Using Promises</a> topic in the MDN documentation, as well as the Google article <a href="https://developers.google.com/web/fundamentals/primers/promises">JavaScript Promises: an Introduction</a>.</p><h2 id="secerrorhandling">Error Handling</h2><p>As noted earlier, specific resource handlers don't typically call the <code>next()</code> function unless they need to report an error. By default, if your JavaScript handler function throws an exception, Express will catch that exception and write the error with a full stack trace back to the client. That's fine during development, but a stack trace in the response doesn't look very professional in production, and it does leak information that could be helpful to an attacker.</p><p>To handle errors more appropriately, add another handler function to your Express application, but this time, define it to take four parameters instead of three:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//error handler that will be called if</span>
<span class="token comment" spellcheck="true">//any handler earlier in the chain throws</span>
<span class="token comment" spellcheck="true">//an exception or passes an error to next()</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//write a stack trace to standard out,</span>
    <span class="token comment" spellcheck="true">//which writes to the server's log</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span>stack<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//but only report the error message</span>
    <span class="token comment" spellcheck="true">//to the client, with a 500 status code</span>
    res<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"text/plain"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The first parameter <code>err</code> will be a reference to the <code>Error</code> object that was thrown by the handler, or passed to the <code>next()</code> function. The other three are the same as the ones passed to any other handler.</p><h2 id="seccreatingyourownmodules">Creating Your own Modules</h2><p>As noted earlier, the <code>require()</code> function can load not only published packages installed to your <code>node_modules</code> directory, but also your own packages defined in other JavaScript files. A "package" is just a JavaScript file that exports a public API. That public API is exported by setting the value of the <code>module.exports</code> property.</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//some-module.js</span>
<span class="token string">"use strict"</span>

<span class="token keyword">function</span> <span class="token function">someExportedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">anotherExportedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">privateNonExportedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//export the public functions</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    someExportedFunction<span class="token punctuation">,</span>
    anotherExportedFunction
<span class="token punctuation">}</span></code></pre><p>Here we set <code>module.exports</code> to an object containing two keys: <code>someExportedFunction</code>, and <code>anotherExportedFunction</code>. The values associated with those keys are the functions of the same name defined in this package. Whatever you set <code>module.exports</code> to will become your package's public API returned from the <code>require()</code> function:</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//myModule is set to the module.exports value</span>
<span class="token comment" spellcheck="true">//defined in `some-module.js`</span>
<span class="token keyword">let</span> myModule <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./some-module.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//use the public API functions</span>
myModule<span class="token punctuation">.</span><span class="token function">someExportedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myModule<span class="token punctuation">.</span><span class="token function">anotherExportedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Like the <code>express</code> package, you can set <code>module.exports</code> to a function instead if you only need to export one function.</p><h2 id="secdockerizinganodewebserver">Dockerizing a Node Web Server</h2><p>A Go web server is fully-compiled to machine code for the target platform, but a Node.js web server is just JavaScript so it still requires the Node.js runtime in order to execute. That means any Docker container image created for a Node.js app must have the Node.js runtime installed within it. Thankfully, the Node.js team maintains <a href="https://hub.docker.com/_/node/">several official Docker container images with Node.js pre-installed</a>.</p><p>To create a Docker container image for your Node.js web server, create a <code>Dockerfile</code> like this:</p><pre class="language-docker"><code class="language-docker"><span class="token comment" spellcheck="true"># use `node` image as the base</span>
<span class="token keyword">FROM</span> node
<span class="token comment" spellcheck="true"># set the current working directory to /app</span>
<span class="token keyword">WORKDIR</span> /app
<span class="token comment" spellcheck="true"># copy the package.json file to the work directory</span>
<span class="token keyword">COPY</span> package.json .
<span class="token comment" spellcheck="true"># run npm install to install all dependent packages</span>
<span class="token keyword">RUN</span> npm install
<span class="token comment" spellcheck="true"># copy your JavaScript source files</span>
<span class="token keyword">COPY</span> . .
<span class="token comment" spellcheck="true"># declare that your server will listen on port 80</span>
<span class="token keyword">EXPOSE</span> 80
<span class="token comment" spellcheck="true"># set the entrypoint command</span>
<span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span><span class="token string">"node"</span><span class="token punctuation">,</span> <span class="token string">"index.js"</span><span class="token punctuation">]</span></code></pre><p>The <code>WORKDIR</code> command creates a directory within the new container image and sets that as the current working directory. All other paths within the container image are then evaluated as relative to that working directory.</p><p>We next <code>COPY</code> the package.json file to the working directory and <code>RUN</code> the command <code>npm install</code> to install all of our dependent packages. We run this command within the container so that any packages that include native code will be compiled for Linux rather than our host OS. Most NPM packages contain only JavaScript, which doesn't require compilation, but some packages include a bit of native C code to do things that aren't yet possible through the Node.js API. By running <code>npm install</code> within the new container image, we ensure that any native code is compiled for the container's OS, which is Linux.</p><p>Lastly, we copy our own JavaScript source files into the container image, declare our port number, and set the entrypoint command to be <code>node index.js</code>.</p><p>Since we are executing <code>npm install</code> within the new container image, we don't need nor want to copy the packages in our own <code>node_modules</code> sub-directory on our host OS. To ignore those files, create a <code>.dockerignore</code> file in the same directory as your <code>Dockerfile</code>. Like the <code>.gitignore</code> file, this file tells Docker to ignore specific files and directories when building. Set your <code>.dockerignore</code> file to contain the following:</p><pre><code>node_modules
npm-debug.log</code></pre><p>You can then build and run your new Docker container using the usual commands:</p><pre class="language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># build the container image</span>
docker build -t your-dockerhub-name/your-container-name <span class="token keyword">.</span>

<span class="token comment" spellcheck="true"># run an instance of the container, publishing port 80</span>
docker run -d -p 80:80 your-dockerhub-name/your-container-name</code></pre><h2 id="secfurtherreading">Further Reading</h2><p>This tutorial introduced you to the basics of building a web server in Node.js and Express.js. To learn more, see the following resources:</p><ul><li><a href="https://nodejs.org/api/">Node.js API documentation</a></li><li><a href="https://expressjs.com/">Express.js documentation</a></li><li><a href="https://docs.npmjs.com/">NPM documentation</a></li><li><a href="https://nodejs.org/en/docs/guides/nodejs-docker-webapp/">Dockerizing a Node.js web app</a></li></ul></div></div></main><footer class="footer"><div class="container"><div class="content"><p>Created by <a href="https://ischool.uw.edu/people/faculty/dlsinfo">Dave Stearns</a>, <a href="https://ischool.uw.edu">The Information School</a>, <a href="https://uw.edu">University of Washington</a></p><p><a href=".."><span class="icon"><i class="fa fa-home"></i> </span>back to contents</a></p></div></div></footer><script>var headings=document.querySelectorAll("h2,h3,h4,h5");headings.forEach(function(e){var a=document.createElement("a");a.textContent="#",a.href="#"+e.id,a.classList.add("bookmark-link"),e.appendChild(a)})</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-102177301-1","auto"),ga("send","pageview")</script></body></html>